import { AliasHash } from '@aztec/barretenberg/account_id';
import { GrumpkinAddress } from '@aztec/barretenberg/address';
import { InitHelpers } from '@aztec/barretenberg/environment';
import { MemoryMerkleTree } from '@aztec/barretenberg/merkle_tree';
import { WorldStateConstants } from '@aztec/barretenberg/world_state';
export function parseGenesisAliasesAndKeys(accounts) {
    const aliases = [];
    const spendingKeys = [];
    for (let i = 0; i < accounts.length; ++i) {
        const { alias: { aliasHash, address }, signingKeys: { signingKey1, signingKey2 }, } = accounts[i];
        const accountPublicKey = new GrumpkinAddress(address);
        aliases.push({
            accountPublicKey,
            aliasHash: new AliasHash(aliasHash),
            index: i * 2,
        });
        spendingKeys.push({
            userId: accountPublicKey,
            treeIndex: i * 2,
            key: signingKey1,
            hashPath: Buffer.alloc(0),
        });
        spendingKeys.push({
            userId: accountPublicKey,
            treeIndex: i * 2 + 1,
            key: signingKey2,
            hashPath: Buffer.alloc(0),
        });
    }
    return {
        aliases,
        spendingKeys,
    };
}
export async function getUserSpendingKeysFromGenesisData(userPublicKeys, accountsData, hasher, rollupSize) {
    // get all of the account note commitments from the genesis store
    const accounts = InitHelpers.parseAccountTreeData(accountsData);
    const commitments = accounts.flatMap(x => [x.notes.note1, x.notes.note2]);
    const size = 1 << Math.ceil(Math.log2(rollupSize));
    const notesInSubtree = size * WorldStateConstants.NUM_NEW_DATA_TREE_NOTES_PER_TX;
    // extract the spending keys and find those for the given users
    const aliasesAndKeys = parseGenesisAliasesAndKeys(accounts);
    const userSpendingKeys = aliasesAndKeys.spendingKeys.filter(key => userPublicKeys.some(userKey => userKey.equals(key.userId)));
    // for each spending key we want to generate the merkle sub tree that contains it's note
    // cache the generated merkle trees so we don't regenerate them unnecessarily
    const merkleTrees = {};
    for (const key of userSpendingKeys) {
        const subTreeIndex = Math.floor(key.treeIndex / notesInSubtree);
        const subTreeStartNoteIndex = subTreeIndex * notesInSubtree;
        if (!merkleTrees[subTreeIndex]) {
            // not generated this sub tree before, generate it now
            const commitmentsForSubTree = commitments.slice(subTreeStartNoteIndex, subTreeStartNoteIndex + notesInSubtree);
            const zeroNotes = Array(notesInSubtree - commitmentsForSubTree.length).fill(MemoryMerkleTree.ZERO_ELEMENT);
            const fullTreeNotes = [...commitmentsForSubTree, ...zeroNotes];
            merkleTrees[subTreeIndex] = await MemoryMerkleTree.new(fullTreeNotes, hasher);
        }
        // retrieve the hash path for the note
        const hashPathForKey = merkleTrees[subTreeIndex].getHashPath(key.treeIndex - subTreeStartNoteIndex);
        key.hashPath = hashPathForKey.toBuffer();
    }
    return userSpendingKeys;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZ2VuZXNpc19zdGF0ZS9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDM0QsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzlELE9BQU8sRUFBZSxXQUFXLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMzRSxPQUFPLEVBQVUsZ0JBQWdCLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMzRSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQVN0RSxNQUFNLFVBQVUsMEJBQTBCLENBQUMsUUFBdUI7SUFDaEUsTUFBTSxPQUFPLEdBQVksRUFBRSxDQUFDO0lBQzVCLE1BQU0sWUFBWSxHQUFrQixFQUFFLENBQUM7SUFDdkMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDeEMsTUFBTSxFQUNKLEtBQUssRUFBRSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsRUFDN0IsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxHQUMxQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNoQixNQUFNLGdCQUFnQixHQUFHLElBQUksZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRXRELE9BQU8sQ0FBQyxJQUFJLENBQUM7WUFDWCxnQkFBZ0I7WUFDaEIsU0FBUyxFQUFFLElBQUksU0FBUyxDQUFDLFNBQVMsQ0FBQztZQUNuQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUM7U0FDYixDQUFDLENBQUM7UUFFSCxZQUFZLENBQUMsSUFBSSxDQUFDO1lBQ2hCLE1BQU0sRUFBRSxnQkFBZ0I7WUFDeEIsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDO1lB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
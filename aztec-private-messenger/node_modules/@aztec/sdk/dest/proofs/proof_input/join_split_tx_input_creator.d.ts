/// <reference types="node" resolution-mode="require"/>
import { EthAddress, GrumpkinAddress } from '@aztec/barretenberg/address';
import { BridgeCallData } from '@aztec/barretenberg/bridge_call_data';
import { ProofId } from '@aztec/barretenberg/client_proofs';
import { Pedersen } from '@aztec/barretenberg/crypto';
import { Grumpkin } from '@aztec/barretenberg/ecc';
import { NoteAlgorithms } from '@aztec/barretenberg/note_algorithms';
import { AuthAlgorithms } from '../../auth_algorithms/index.js';
import { Note } from '../../note/index.js';
import { SpendingKeyAccount } from '../proof_request_data/index.js';
import { JoinSplitTxInput } from './join_split_tx_input.js';
import { PaymentProofInput } from './proof_input.js';
export declare class JoinSplitTxInputCreator {
    private noteAlgos;
    private grumpkin;
    private pedersen;
    constructor(noteAlgos: NoteAlgorithms, grumpkin: Grumpkin, pedersen: Pedersen);
    createTx(accountPublicKey: GrumpkinAddress, proofId: ProofId, assetId: number, publicValue: bigint, publicOwner: EthAddress, recipientPrivateOutput: bigint, senderPrivateOutput: bigint, bridgeCallData: BridgeCallData, defiDepositValue: bigint, recipient: GrumpkinAddress, recipientSpendingKeyRequired: boolean, inputNotes: Note[], { spendingPublicKey, aliasHash, accountIndex, accountPath }: SpendingKeyAccount, dataRoot: Buffer, allowChain: number, hideNoteCreator: boolean, authAlgos: AuthAlgorithms): Promise<{
        tx: JoinSplitTxInput;
        viewingKeys: import("@aztec/barretenberg/viewing_key").ViewingKey[];
        partialStateSecretEphPubKey: GrumpkinAddress;
        signingData: Buffer;
        outputNotes: Note[];
    }>;
    /**
     * This method creates a chain of J/S txs to merge 3 or more notes and produces 2 output notes.
     * We do this by splitting the notes into settled and pending (there must be at most 1 pending note!).
     * Then we pair a settled note with a settled/pending note to produce a pending output note.
     * Then we pair that pending output note with another settled note to produce a new pending output note.
     * Repeat this until we have 2 notes remaining, one pending and one settled.
     */
    createChainedTxs(accountPublicKey: GrumpkinAddress, assetId: number, notes: Note[], spendingKeyAccount: SpendingKeyAccount, dataRoot: Buffer, authAlgos: AuthAlgorithms): Promise<{
        proofInputs: PaymentProofInput[];
        outputNotes: Note[];
    }>;
    private createGibberishNote;
    private createNote;
    private createClaimNote;
    private createEphemeralPrivKey;
    private createEphemeralKeyPair;
}
//# sourceMappingURL=join_split_tx_input_creator.d.ts.map
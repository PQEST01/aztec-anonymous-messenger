import { GrumpkinAddress } from '@aztec/barretenberg/address';
import { AccountTx, ProofData } from '@aztec/barretenberg/client_proofs';
import { createDebugLogger } from '@aztec/barretenberg/log';
import { HashPath } from '@aztec/barretenberg/merkle_tree';
import { OffchainAccountData } from '@aztec/barretenberg/offchain_tx_data';
import { TxId } from '@aztec/barretenberg/tx_id';
import { WorldStateConstants } from '@aztec/barretenberg/world_state';
import { CoreAccountTx } from '../core_tx/index.js';
const debug = createDebugLogger('bb:account_proof');
export class AccountProofCreator {
    constructor(prover, worldState, db) {
        this.prover = prover;
        this.worldState = worldState;
        this.db = db;
    }
    async createProofInput(accountPublicKey, aliasHash, migrate, spendingPublicKey, newAccountPublicKey, newSpendingPublicKey1, newSpendingPublicKey2, spendingKeyExists = true) {
        // Regarding `!migrate` check: see explanation in `getAccountPathAndIndex`
        const create = accountPublicKey.equals(spendingPublicKey) && !migrate;
        const merkleRoot = this.worldState.getRoot();
        const { path: accountPath, index: accountIndex } = await this.getAccountPathAndIndex(accountPublicKey, spendingKeyExists ? spendingPublicKey : accountPublicKey, migrate);
        const tx = new AccountTx(merkleRoot, accountPublicKey, newAccountPublicKey || accountPublicKey, newSpendingPublicKey1 || GrumpkinAddress.ZERO, newSpendingPublicKey2 || GrumpkinAddress.ZERO, aliasHash, create, migrate, accountIndex, accountPath, spendingPublicKey);
        const signingData = await this.prover.computeSigningData(tx);
        return { tx, signingData };
    }
    async createProof({ tx, signature }, txRefNo, timeout) {
        debug('creating proof...');
        const start = new Date().getTime();
        const proof = await this.prover.createAccountProof(tx, signature, timeout);
        debug(`created proof: ${new Date().getTime() - start}ms`);
        debug(`proof size: ${proof.length}`);
        const proofData = new ProofData(proof);
        const txId = new TxId(proofData.txId);
        const { aliasHash, newAccountPublicKey, newSpendingPublicKey1, newSpendingPublicKey2, migrate } = tx;
        const coreTx = new CoreAccountTx(txId, newAccountPublicKey, aliasHash, newSpendingPublicKey1?.x(), newSpendingPublicKey2?.x(), migrate, txRefNo, new Date());
        const offchainTxData = new OffchainAccountData(newAccountPublicKey, aliasHash, newSpendingPublicKey1?.x(), newSpendingPublicKey2?.x(), txRefNo);
        return { tx: coreTx, proofData, offchainTxData, outputNotes: [] };
    }
    async getAccountPathAndIndex(accountPublicKey, spendingPublicKey, migrate) {
        // migrate flag explanation:
        // There is a system-wide assumption (enforced at account creation) that a user's registered spending keys and
        // account keys cannot match, and therefore if a user trys to spend using keys that match, they are performing an
        // "unregistered" action. I.e. they are spending notes which don't require a registered spending key. Unfortunately
        // when importing account registrations from the old system we didn't account for the fact that prior to June 2021
        // users had registrations with no spending keys (only an alias), and such dormant registrations ended up
        // inheriting their account keys as registered spending keys. In order to allow such accounts to migrate their
        // aliases, we have an expectional case in we perform the "registered" action instead of the "unregistered" action.
        if (spendingPublicKey.equals(accountPublicKey) && !migrate) {
            return {
                path: this.worldState.buildZeroHashPath(WorldStateConstants.DATA_TREE_DEPTH),
                index: 0,
            };
        }
        else {
            const spendingKey = await this.db.getSpendingKey(accountPublicKey, spendingPublicKey);
            if (spendingKey === undefined) {
                throw new Error('Unknown spending key.');
            }
            const immutableHashPath = HashPath.fromBuffer(spendingKey.hashPath);
            const path = await this.worldState.buildFullHashPath(spendingKey.treeIndex, immutableHashPath);
            return {
                path,
                index: spendingKey.treeIndex,
            };
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3VudF9wcm9vZl9jcmVhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3Byb29mcy9hY2NvdW50X3Byb29mX2NyZWF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzlELE9BQU8sRUFBaUIsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3hGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzVELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUMzRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUMzRSxPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDakQsT0FBTyxFQUFjLG1CQUFtQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDbEYsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBS3BELE1BQU0sS0FBSyxHQUFHLGlCQUFpQixDQUFDLGtCQUFrQixDQUFDLENBQUM7QUFFcEQsTUFBTSxPQUFPLG1CQUFtQjtJQUM5QixZQUFvQixNQUFxQixFQUFVLFVBQXNCLEVBQVUsRUFBWTtRQUEzRSxXQUFNLEdBQU4sTUFBTSxDQUFlO1FBQVUsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUFVLE9BQUUsR0FBRixFQUFFLENBQVU7SUFBRyxDQUFDO0lBRTVGLEtBQUssQ0FBQyxnQkFBZ0IsQ0FDM0IsZ0JBQWlDLEVBQ2pDLFNBQW9CLEVBQ3BCLE9BQWdCLEVBQ2hCLGlCQUFrQyxFQUNsQyxtQkFBZ0QsRUFDaEQscUJBQWtELEVBQ2xELHFCQUFrRCxFQUNsRCxpQkFBaUIsR0FBRyxJQUFJO1FBRXhCLDBFQUEwRTtRQUMxRSxNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsaUJBQWlCLENB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
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EthAddress, GrumpkinAddress } from '@aztec/barretenberg/address';
import { AssetValue } from '@aztec/barretenberg/asset';
import { EthereumProvider, Receipt, SendTxOptions, TxHash } from '@aztec/barretenberg/blockchain';
import { BridgeCallData } from '@aztec/barretenberg/bridge_call_data';
import { BridgePublishQuery, BridgePublishQueryResult, DefiSettlementTime, Tx } from '@aztec/barretenberg/rollup_provider';
import { TxId } from '@aztec/barretenberg/tx_id';
import { DecodedBlock } from '@aztec/barretenberg/block_source';
import { ClientEthereumBlockchain } from '@aztec/blockchain';
import { EventEmitter } from 'events';
import { AddSpendingKeyController, DefiController, DepositController, FeeController, MigrateAccountController, RecoverAccountController, RegisterController, TransferController, WithdrawController } from '../controllers/index.js';
import { CoreSdk, SdkEvent } from '../core_sdk/index.js';
import { SchnorrSigner, Signer } from '../signer/index.js';
import { RecoveryPayload } from '../user/index.js';
import { UserAccountTx, UserDefiTx, UserPaymentTx } from '../user_tx/index.js';
import { AztecSdkUser } from './aztec_sdk_user.js';
import { GetFeesOptions } from './fee_calculator.js';
import { GetMaxTxValueOptions } from './tx_value_calculator.js';
export { GetFeesOptions, GetMaxTxValueOptions };
export interface AztecSdk {
    on(event: SdkEvent.VERSION_MISMATCH, listener: () => void): this;
    on(event: SdkEvent.UPDATED_USER_STATE, listener: (userId: GrumpkinAddress) => void): this;
    on(event: SdkEvent.UPDATED_WORLD_STATE, listener: (syncedToRollup: number, latestRollupId: number) => void): this;
    on(event: SdkEvent.DESTROYED, listener: (error?: string) => void): this;
}
export declare class AztecSdk extends EventEmitter {
    private core;
    private blockchain;
    private provider;
    private feeCalculator;
    private txValueCalculator;
    constructor(core: CoreSdk, blockchain: ClientEthereumBlockchain, provider: EthereumProvider);
    run(): Promise<void>;
    destroy(): Promise<void>;
    awaitSynchronised(timeout?: number): Promise<void>;
    isUserSynching(userId: GrumpkinAddress): Promise<boolean>;
    awaitUserSynchronised(userId: GrumpkinAddress, timeout?: number): Promise<void>;
    awaitSettlement(txId: TxId, timeout?: number): Promise<void>;
    awaitDefiDepositCompletion(txId: TxId, timeout?: number): Promise<void>;
    awaitDefiFinalisation(txId: TxId, timeout?: number): Promise<void>;
    awaitDefiSettlement(txId: TxId, timeout?: number): Promise<void>;
    awaitAllUserTxsSettled(timeout?: number): Promise<void>;
    awaitAllUserTxsClaimed(timeout?: number): Promise<void>;
    getLocalStatus(): Promise<{
        serverUrl: string;
        chainId: number;
        rollupContractAddress: EthAddress;
        permitHelperContractAddress: EthAddress;
        verifierContractAddress: EthAddress;
        feePayingAssetIds: number[];
        rollupSize: number;
        syncedToRollup: number;
        latestRollupId: number;
        dataSize: number;
        dataRoot: Buffer;
        useKeyCache: boolean;
        proverless: boolean;
        version: string;
    }>;
    getRemoteStatus(): Promise<import("@aztec/barretenberg/rollup_provider").RollupProviderStatus>;
    sendConsoleLog(clientData?: string[], preserveLog?: boolean): Promise<void>;
    isAccountRegistered(accountPublicKey: GrumpkinAddress, includePending?: boolean): Promise<boolean>;
    isAliasRegistered(alias: string, includePending?: boolean): Promise<boolean>;
    isAliasRegisteredToAccount(accountPublicKey: GrumpkinAddress, alias: string, includePending?: boolean): Promise<boolean>;
    getAccountPublicKey(alias: string): Promise<GrumpkinAddress | undefined>;
    getAccountIndex(alias: string): Promise<number | undefined>;
    getTxFees(assetId: number, { feeSignificantFigures }?: {
        feeSignificantFigures?: number | undefined;
    }): Promise<AssetValue[][]>;
    queryDefiPublishStats(query: BridgePublishQuery): Promise<BridgePublishQueryResult>;
    userExists(accountPublicKey: GrumpkinAddress): Promise<boolean>;
    addUser(accountPrivateKey: Buffer, registrationSync?: boolean, registrationSyncMarginBlocks?: number): Promise<AztecSdkUser>;
    removeUser(userId: GrumpkinAddress): Promise<void>;
    /**
     * Returns a AztecSdkUser for a locally resolved user.
     */
    getUser(userId: GrumpkinAddress): Promise<AztecSdkUser>;
    getUserSyncedToRollup(userId: GrumpkinAddress): Promise<number>;
    getUsers(): Promise<GrumpkinAddress[]>;
    getAccountKeySigningData(): Buffer;
    getSpendingKeySigningData(): Buffer;
    generateAccountKeyPair(account: EthAddress, provider?: EthereumProvider): Promise<{
        publicKey: GrumpkinAddress;
        privateKey: Buffer;
    }>;
    generateSpendingKeyPair(account: EthAddress, provider?: EthereumProvider): Promise<{
        publicKey: GrumpkinAddress;
        privateKey: Buffer;
    }>;
    createSchnorrSigner(privateKey: Buffer): Promise<SchnorrSigner>;
    derivePublicKey(privateKey: Buffer): Promise<GrumpkinAddress>;
    deriveLegacySigningMessageHash(address: EthAddress): Promise<Buffer>;
    getAssetIdByAddress(address: EthAddress, gasLimit?: number): number;
    getAssetIdBySymbol(symbol: string, gasLimit?: number): number;
    fromBaseUnits({ assetId, value }: AssetValue, symbol?: boolean, precision?: number): string;
    toBaseUnits(assetId: number, value: string): {
        assetId: number;
        value: bigint;
    };
    getAssetInfo(assetId: number): import("@aztec/barretenberg/blockchain").BlockchainAsset;
    isFeePayingAsset(assetId: number): Promise<boolean>;
    isVirtualAsset(assetId: number): boolean;
    mint({ assetId, value }: AssetValue, account: EthAddress, options?: SendTxOptions): Promise<TxHash>;
    setSupportedAsset(assetAddress: EthAddress, assetGasLimit?: number, options?: SendTxOptions): Promise<TxHash>;
    getBridgeAddressId(address: EthAddress, gasLimit?: number): number;
    setSupportedBridge(bridgeAddress: EthAddress, bridgeGasLimit?: number, options?: SendTxOptions): Promise<TxHash>;
    processAsyncDefiInteraction(interactionNonce: number, options?: SendTxOptions): Promise<TxHash>;
    getDepositFees(assetId: number, options?: {
        feeSignificantFigures?: number;
    }): Promise<AssetValue[]>;
    getPendingDepositTxs(): Promise<import("@aztec/barretenberg/rollup_provider").DepositTx[]>;
    createDepositController(depositor: EthAddress, assetValue: AssetValue, fee: AssetValue, recipient: GrumpkinAddress, recipientSpendingKeyRequired?: boolean, provider?: EthereumProvider): DepositController;
    getWithdrawFees(assetId: number, options?: GetFeesOptions & {
        recipient?: EthAddress;
        assetValue?: AssetValue;
    }): Promise<AssetValue[]>;
    getMaxWithdrawValue(userId: GrumpkinAddress, assetId: number, options?: GetMaxTxValueOptions & {
        recipient?: EthAddress;
    }): Promise<{
        assetId: number;
        value: bigint;
        fee: {
            assetId: number;
            value: bigint;
        };
    }>;
    createWithdrawController(userId: GrumpkinAddress, userSigner: Signer, assetValue: AssetValue, fee: AssetValue, to: EthAddress): WithdrawController;
    getTransferFees(assetId: number, options?: GetFeesOptions & {
        assetValue?: AssetValue;
    }): Promise<AssetValue[]>;
    getMaxTransferValue(userId: GrumpkinAddress, assetId: number, options?: GetMaxTxValueOptions): Promise<{
        assetId: number;
        value: bigint;
        fee: {
            assetId: number;
            value: bigint;
        };
    }>;
    createTransferController(userId: GrumpkinAddress, userSigner: Signer, assetValue: AssetValue, fee: AssetValue, recipient: GrumpkinAddress, recipientSpendingKeyRequired?: boolean): TransferController;
    getDefiFees(bridgeCallData: BridgeCallData, options?: GetFeesOptions & {
        assetValue?: AssetValue;
    }): Promise<AssetValue[]>;
    getMaxDefiValue(userId: GrumpkinAddress, bridgeCallData: BridgeCallData, options?: Omit<GetMaxTxValueOptions, 'txSettlementTime'> & {
        txSettlementTime?: DefiSettlementTime;
    }): Promise<{
        assetId: number;
        value: bigint;
        fee: {
            assetId: number;
            value: bigint;
        };
    }>;
    createDefiController(userId: GrumpkinAddress, userSigner: Signer, bridgeCallData: BridgeCallData, assetValue: AssetValue, fee: AssetValue): DefiController;
    generateAccountRecoveryData(accountPublicKey: GrumpkinAddress, alias: string, trustedThirdPartyPublicKeys: GrumpkinAddress[]): Promise<RecoveryPayload[]>;
    getRegisterFees(assetId: number, options?: {
        feeSignificantFigures?: number;
    }): Promise<AssetValue[]>;
    createRegisterController(userId: GrumpkinAddress, alias: string, accountPrivateKey: Buffer, spendingPublicKey: GrumpkinAddress, recoveryPublicKey: GrumpkinAddress | undefined, deposit: AssetValue, fee: AssetValue, depositor?: EthAddress, provider?: EthereumProvider): RegisterController;
    getRecoverAccountFees(assetId: number, options?: {
        feeSignificantFigures?: number;
    }): Promise<AssetValue[]>;
    createRecoverAccountController(recoveryPayload: RecoveryPayload, deposit: AssetValue, fee: AssetValue, depositor?: EthAddress, provider?: EthereumProvider): RecoverAccountController;
    getAddSpendingKeyFees(assetId: number, options?: {
        feeSignificantFigures?: number;
    }): Promise<{
        value: bigint;
        assetId: number;
    }[]>;
    createAddSpendingKeyController(userId: GrumpkinAddress, userSigner: Signer, spendingPublicKey1: GrumpkinAddress, spendingPublicKey2: GrumpkinAddress | undefined, fee: AssetValue): AddSpendingKeyController;
    getMigrateAccountFees(assetId: number, options?: {
        feeSignificantFigures?: number;
    }): Promise<{
        value: bigint;
        assetId: number;
    }[]>;
    createMigrateAccountController(userId: GrumpkinAddress, userSigner: Signer, newAccountPrivateKey: Buffer, newSpendingPublicKey: GrumpkinAddress, recoveryPublicKey: GrumpkinAddress | undefined, deposit: AssetValue, fee: AssetValue, depositor?: EthAddress, provider?: EthereumProvider): MigrateAccountController;
    getProofTxsFees(assetId: number, proofTxs: Tx[], options?: GetFeesOptions): Promise<{
        value: bigint;
        assetId: number;
    }[]>;
    createFeeController(userId: GrumpkinAddress, userSigner: Signer, proofTxs: Tx[], fee: AssetValue): FeeController;
    depositFundsToContract({ assetId, value }: AssetValue, from: EthAddress, provider?: EthereumProvider): Promise<TxHash>;
    getUserPendingDeposit(assetId: number, account: EthAddress): Promise<bigint>;
    getUserPendingFunds(assetId: number, account: EthAddress): Promise<bigint>;
    isContract(address: EthAddress): Promise<boolean>;
    validateSignature(publicOwner: EthAddress, signature: Buffer, signingData: Buffer): boolean;
    getTransactionReceipt(txHash: TxHash, timeout?: number, interval?: number): Promise<Receipt>;
    flushRollup(userId: GrumpkinAddress, userSigner: Signer): Promise<void>;
    getSpendingKeys(userId: GrumpkinAddress): Promise<Buffer[]>;
    getPublicBalance(ethAddress: EthAddress, assetId: number): Promise<{
        assetId: number;
        value: bigint;
    }>;
    getBalances(userId: GrumpkinAddress): Promise<{
        assetId: number;
        value: bigint;
    }[]>;
    getBalance(userId: GrumpkinAddress, assetId: number): Promise<{
        assetId: number;
        value: bigint;
    }>;
    getFormattedBalance(userId: GrumpkinAddress, assetId: number, symbol?: boolean, precision?: number): Promise<string>;
    getSpendableSum(userId: GrumpkinAddress, assetId: number, spendingKeyRequired?: boolean, excludePendingNotes?: boolean): Promise<bigint>;
    getSpendableSums(userId: GrumpkinAddress, spendingKeyRequired?: boolean, excludePendingNotes?: boolean): Promise<{
        assetId: number;
        value: bigint;
    }[]>;
    getMaxSpendableValue(userId: GrumpkinAddress, assetId: number, spendingKeyRequired?: boolean, excludePendingNotes?: boolean, numNotes?: number): Promise<bigint>;
    getUserTxs(userId: GrumpkinAddress): Promise<(UserPaymentTx | UserAccountTx | UserDefiTx | import("../user_tx/user_defi_claim_tx.js").UserDefiClaimTx)[]>;
    getPaymentTxs(userId: GrumpkinAddress): Promise<UserPaymentTx[]>;
    getAccountTxs(userId: GrumpkinAddress): Promise<UserAccountTx[]>;
    getDefiTxs(userId: GrumpkinAddress): Promise<UserDefiTx[]>;
    getBlocks(from: number, take?: number): Promise<DecodedBlock[]>;
    getCoreSdk(): CoreSdk;
}
//# sourceMappingURL=aztec_sdk.d.ts.map
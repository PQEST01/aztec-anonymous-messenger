/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EthAddress, GrumpkinAddress } from '@aztec/barretenberg/address';
import { DecodedBlock } from '@aztec/barretenberg/block_source';
import { BridgeCallData } from '@aztec/barretenberg/bridge_call_data';
import { Pedersen } from '@aztec/barretenberg/crypto';
import { FftFactory } from '@aztec/barretenberg/fft';
import { NoteDecryptor } from '@aztec/barretenberg/note_algorithms';
import { Pippenger } from '@aztec/barretenberg/pippenger';
import { BridgePublishQuery, BridgePublishQueryResult, RollupProvider, Tx } from '@aztec/barretenberg/rollup_provider';
import { TxId } from '@aztec/barretenberg/tx_id';
import { BarretenbergWasm, WorkerPool } from '@aztec/barretenberg/wasm';
import { EventEmitter } from 'events';
import { LevelUp } from 'levelup';
import { CorePaymentTx } from '../core_tx/index.js';
import { Database } from '../database/index.js';
import { AccountProofInput, JoinSplitProofInput, ProofOutput } from '../proofs/index.js';
import { CoreSdkOptions } from './core_sdk_options.js';
/**
 * CoreSdk is responsible for keeping everything in sync and proof construction.
 * init() should be called before making any other calls to construct the basic components.
 * run() should be called once a client wants to start synching, or requesting proof construction.
 * Takes ownership of injected components (should destroy them etc).
 * A serial queue ensures that all calls that modify internal state happen in sequence.
 * By default, the serial queue is protected with a cross-process mutex, ensuring that if multiple instances
 * of the CoreSdk exist in different processes, that they will not modify state at the same time.
 */
export declare class CoreSdk extends EventEmitter {
    private leveldb;
    private db;
    private rollupProvider;
    private barretenberg;
    private noteDecryptor;
    private pedersen;
    private pippenger;
    private fftFactory;
    private workerPool?;
    private dataVersion;
    private worldState;
    private userStates;
    private proofRequestDataFactory;
    private proofInputFactory;
    private proofOutputFactory;
    private serialQueue;
    private broadcastChannel;
    private userStateFactory;
    private sdkStatus;
    private initState;
    private noteAlgos;
    private blake2s;
    private grumpkin;
    private schnorr;
    private debug;
    private synchroniser;
    constructor(leveldb: LevelUp, db: Database, rollupProvider: RollupProvider, barretenberg: BarretenbergWasm, noteDecryptor: NoteDecryptor, pedersen: Pedersen, pippenger: Pippenger, fftFactory: FftFactory, workerPool?: WorkerPool | undefined);
    /**
     * Constructs internal components.
     * Erases dbs if rollup contract address changed.
     * Loads and initializes known user accounts.
     * Destroys injected components on failure.
     */
    init(options: CoreSdkOptions): Promise<void>;
    destroy(error?: string): Promise<void>;
    getLocalStatus(): Promise<{
        serverUrl: string;
        chainId: number;
        rollupContractAddress: EthAddress;
        permitHelperContractAddress: EthAddress;
        verifierContractAddress: EthAddress;
        feePayingAssetIds: number[];
        rollupSize: number;
        syncedToRollup: number;
        latestRollupId: number;
        dataSize: number;
        dataRoot: Buffer;
        useKeyCache: boolean;
        proverless: boolean;
        version: string;
    }>;
    getRemoteStatus(): Promise<import("@aztec/barretenberg/rollup_provider").RollupProviderStatus>;
    sendConsoleLog(clientData?: string[], preserveLog?: boolean): Promise<void>;
    isAccountRegistered(accountPublicKey: GrumpkinAddress, includePending: boolean): Promise<boolean>;
    isAliasRegistered(alias: string, includePending: boolean): Promise<boolean>;
    isAliasRegisteredToAccount(accountPublicKey: GrumpkinAddress, alias: string, includePending: boolean): Promise<boolean>;
    getAccountPublicKey(alias: string): Promise<GrumpkinAddress | undefined>;
    getAccountIndex(alias: string): Promise<number | undefined>;
    getTxFees(assetId: number): Promise<import("@aztec/barretenberg/asset").AssetValue[][]>;
    getDefiFees(bridgeCallData: BridgeCallData): Promise<import("@aztec/barretenberg/asset").AssetValue[]>;
    getPendingDepositTxs(): Promise<import("@aztec/barretenberg/rollup_provider").DepositTx[]>;
    getDefiInteractionNonce(txId: TxId): Promise<number | undefined>;
    userExists(userId: GrumpkinAddress): Promise<boolean>;
    getUsers(): Promise<GrumpkinAddress[]>;
    derivePublicKey(privateKey: Buffer): Promise<GrumpkinAddress>;
    deriveLegacySigningMessageHash(address: EthAddress): Promise<Buffer>;
    constructSignature(message: Buffer, privateKey: Buffer): Promise<import("@aztec/barretenberg/crypto").SchnorrSignature>;
    addUser(accountPrivateKey: Buffer, registrationSync?: boolean, registrationSyncMarginBlocks?: number): Promise<GrumpkinAddress>;
    removeUser(userId: GrumpkinAddress): Promise<void>;
    getUserSyncedToRollup(userId: GrumpkinAddress): Promise<number>;
    getSpendingKeys(userId: GrumpkinAddress): Promise<Buffer[]>;
    getBalances(userId: GrumpkinAddress): Promise<{
        assetId: number;
        value: bigint;
    }[]>;
    getBalance(userId: GrumpkinAddress, assetId: number): Promise<bigint>;
    getSpendableNoteValues(userId: GrumpkinAddress, assetId: number, spendingKeyRequired?: boolean, excludePendingNotes?: boolean): Promise<bigint[]>;
    getSpendableSum(userId: GrumpkinAddress, assetId: number, spendingKeyRequired?: boolean, excludePendingNotes?: boolean): Promise<bigint>;
    getSpendableSums(userId: GrumpkinAddress, spendingKeyRequired?: boolean, excludePendingNotes?: boolean): Promise<{
        assetId: number;
        value: bigint;
    }[]>;
    getMaxSpendableNoteValues(userId: GrumpkinAddress, assetId: number, spendingKeyRequired?: boolean, excludePendingNotes?: boolean, numNotes?: number): Promise<bigint[]>;
    pickNotes(userId: GrumpkinAddress, assetId: number, value: bigint, spendingKeyRequired?: boolean, excludePendingNotes?: boolean): Promise<import("../index.js").Note[]>;
    pickNote(userId: GrumpkinAddress, assetId: number, value: bigint, spendingKeyRequired?: boolean, excludePendingNotes?: boolean): Promise<import("../index.js").Note | undefined>;
    getUserTxs(userId: GrumpkinAddress): Promise<import("../core_tx/index.js").CoreUserTx[]>;
    /**
     * Moves the sdk into RUNNING state.
     * Kicks off data tree updates, user note decryptions, alias table updates, proving key construction.
     */
    run(): Promise<void>;
    createDepositProof(assetId: number, publicInput: bigint, privateOutput: bigint, depositor: EthAddress, recipient: GrumpkinAddress, recipientSpendingKeyRequired: boolean, txRefNo: number, timeout?: number): Promise<{
        outputNotes: import("../index.js").Note[];
        tx: CorePaymentTx;
        proofData: import("@aztec/barretenberg/client_proofs").ProofData;
        offchainTxData: import("@aztec/barretenberg/offchain_tx_data").OffchainJoinSplitData;
    }>;
    createPaymentProofInputs(userId: GrumpkinAddress, assetId: number, publicInput: bigint, publicOutput: bigint, privateInput: bigint, recipientPrivateOutput: bigint, senderPrivateOutput: bigint, noteRecipient: GrumpkinAddress | undefined, recipientSpendingKeyRequired: boolean, publicOwner: EthAddress | undefined, spendingPublicKey: GrumpkinAddress, allowChain: number): Promise<JoinSplitProofInput[]>;
    createPaymentProof(input: JoinSplitProofInput, txRefNo: number, timeout?: number): Promise<ProofOutput>;
    createAccountProofSigningData(accountPublicKey: GrumpkinAddress, alias: string, migrate: boolean, spendingPublicKey: GrumpkinAddress, newAccountPublicKey?: GrumpkinAddress, newSpendingPublicKey1?: GrumpkinAddress, newSpendingPublicKey2?: GrumpkinAddress): Promise<Buffer>;
    createAccountProofInput(userId: GrumpkinAddress, spendingPublicKey: GrumpkinAddress, migrate: boolean, alias?: string, newSpendingPublicKey1?: GrumpkinAddress, newSpendingPublicKey2?: GrumpkinAddress, newAccountPrivateKey?: Buffer): Promise<AccountProofInput>;
    createAccountProof(input: AccountProofInput, txRefNo: number, timeout?: number): Promise<{
        outputNotes: never[];
        tx: import("../core_tx/core_account_tx.js").CoreAccountTx;
        proofData: import("@aztec/barretenberg/client_proofs").ProofData;
        offchainTxData: import("@aztec/barretenberg/offchain_tx_data").OffchainAccountData;
    }>;
    createDefiProofInput(userId: GrumpkinAddress, bridgeCallData: BridgeCallData, depositValue: bigint, fee: bigint, spendingPublicKey: GrumpkinAddress): Promise<JoinSplitProofInput[]>;
    createDefiProof(input: JoinSplitProofInput, txRefNo: number, timeout?: number): Promise<{
        outputNotes: import("../index.js").Note[];
        tx: import("../core_tx/core_defi_tx.js").CoreDefiTx;
        proofData: import("@aztec/barretenberg/client_proofs").ProofData;
        offchainTxData: import("@aztec/barretenberg/offchain_tx_data").OffchainDefiDepositData;
    }>;
    sendProofs(proofs: ProofOutput[], proofTxs?: Tx[]): Promise<TxId[]>;
    awaitSynchronised(timeout?: number): Promise<void>;
    isUserSynching(userId: GrumpkinAddress): Promise<boolean>;
    awaitUserSynchronised(userId: GrumpkinAddress, timeout?: number): Promise<void>;
    awaitSettlement(txId: TxId, timeout?: number): Promise<void>;
    awaitDefiDepositCompletion(txId: TxId, timeout?: number): Promise<void>;
    awaitDefiFinalisation(txId: TxId, timeout?: number): Promise<void>;
    awaitDefiSettlement(txId: TxId, timeout?: number): Promise<void>;
    private getUserState;
    private getUserStateUndef;
    private isSynchronised;
    private assertInitState;
    private setLocalDataVersion;
    private getLocalDataVersion;
    private getLocalRollupContractAddress;
    private getCrsData;
    /**
     * Loads known accounts from db.
     * Registers to forward any notifications of account state updates.
     */
    private initUserStates;
    private addInitialUserSpendingKeys;
    private computeAliasHash;
    private runOrClientLog;
    queryDefiPublishStats(query: BridgePublishQuery): Promise<BridgePublishQueryResult>;
    getBlocks(from: number, take?: number): Promise<DecodedBlock[]>;
}
//# sourceMappingURL=core_sdk.d.ts.map
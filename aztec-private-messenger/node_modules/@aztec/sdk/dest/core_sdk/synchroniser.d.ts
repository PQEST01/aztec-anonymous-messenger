/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { InitialWorldState, RollupProvider } from '@aztec/barretenberg/rollup_provider';
import { WorldState } from '@aztec/barretenberg/world_state';
import { LevelUp } from 'levelup';
import { Database } from '../database/index.js';
import { Pedersen } from '../index.js';
import { UserState } from '../user_state/index.js';
import { EventEmitter } from 'events';
import { SerialQueue } from '../serial_queue/index.js';
export interface SyncStatus {
    syncedToRollup: number;
    latestRollupId: number;
    dataRoot: Buffer;
    dataSize: number;
}
/**
 * For serial debugging logs and accurate timings, set `serialize` to true.
 * This prevents buffering and concurrent processing of the data pipeline.
 */
export declare class Synchroniser extends EventEmitter {
    private rollupProvider;
    private worldState;
    private leveldb;
    private db;
    private pedersen;
    private serialQueue;
    private serialize;
    private mutexTimeout;
    private debug;
    private running;
    private genesisSyncMutex;
    private syncMutex;
    private synchingPromise;
    private blockDownloader?;
    private syncStatus;
    private userStates;
    private onAbortCallbacks;
    constructor(rollupProvider: RollupProvider, worldState: WorldState, leveldb: LevelUp, db: Database, pedersen: Pedersen, serialQueue: SerialQueue, serialize?: boolean, mutexTimeout?: number);
    init(): Promise<void>;
    getSyncStatus(): SyncStatus;
    setUserStates(userStates: UserState[]): void;
    start(): Promise<void>;
    stop(): Promise<void>;
    onAbort(cb: (err: Error) => any): void;
    retrieveGenesisData(): Promise<InitialWorldState>;
    /**
     * If the world state has no data, download the initial world state data and process it.
     * Returns the initial tree size (e.g. 73 for aztec-connect production).
     */
    private genesisSync;
    private startSync;
    /**
     * @notice Fetches blocks and applies them to both core and user states
     * @from Number of a block from which to sync
     */
    private handleBlockContexts;
    /**
     * Brings this.syncStatus, and user states in line with what's persisted.
     */
    private readSyncInfo;
    /**
     * Persist new syncedToRollup and update this.sdkStatus.
     */
    private writeSyncInfo;
    private processAliases;
    private getSyncedToRollup;
    private abortSync;
}
//# sourceMappingURL=synchroniser.d.ts.map
import { InitHelpers } from '@aztec/barretenberg/environment';
import { createDebugLogger } from '@aztec/barretenberg/log';
import { Mutex } from '@aztec/barretenberg/mutex';
import { retry } from '@aztec/barretenberg/retry';
import { initialWorldStateFromBuffer, initialWorldStateToBuffer, } from '@aztec/barretenberg/rollup_provider';
import { Timer } from '@aztec/barretenberg/timer';
import { BlockContext } from '../block_context/block_context.js';
import { parseGenesisAliasesAndKeys } from '../genesis_state/index.js';
import { BlockDownloader } from './block_downloader.js';
import { OffchainAccountData } from '@aztec/barretenberg/offchain_tx_data';
import { toBigIntBE } from '@aztec/barretenberg/bigint_buffer';
import { ProofId } from '@aztec/barretenberg/client_proofs';
import { BoundedSerialQueue } from '@aztec/barretenberg/fifo';
import { SdkEvent } from './sdk_status.js';
import { EventEmitter } from 'events';
import { sendClientLog } from '../client_log/client_log.js';
/**
 * For serial debugging logs and accurate timings, set `serialize` to true.
 * This prevents buffering and concurrent processing of the data pipeline.
 */
export class Synchroniser extends EventEmitter {
    constructor(rollupProvider, worldState, leveldb, db, pedersen, serialQueue, serialize = false, mutexTimeout = 30000) {
        super();
        this.rollupProvider = rollupProvider;
        this.worldState = worldState;
        this.leveldb = leveldb;
        this.db = db;
        this.pedersen = pedersen;
        this.serialQueue = serialQueue;
        this.serialize = serialize;
        this.mutexTimeout = mutexTimeout;
        this.debug = createDebugLogger('bb:synchroniser');
        this.running = false;
        this.userStates = [];
        this.onAbortCallbacks = [];
        this.genesisSyncMutex = new Mutex(this.db, 'aztec_core_sdk_genesis_sync', this.mutexTimeout);
        this.syncMutex = new Mutex(this.db, 'aztec_core_sdk_sync', this.mutexTimeout);
        this.syncStatus = {
            syncedToRollup: -1,
            latestRollupId: -1,
            dataSize: 0,
            dataRoot: Buffer.alloc(0),
        };
    }
    async init() {
        this.syncStatus = {
            syncedToRollup: await this.getSyncedToRollup(),
            latestRollupId: await this.rollupProvider.getLatestRollupId(),
            dataSize: this.worldState.getSize(),
            dataRoot: this.worldState.getRoot(),
        };
    }
    getSyncStatus() {
        return this.syncStatus;
    }
    setUserStates(userStates) {
        this.userStates = userStates;
    }
    async start() {
        this.running = true;
        // Only one tab to do genesis sync at a time.
        await this.genesisSyncMutex.lock();
        const initialState = await this.retrieveGenesisData();
        // Start the block downloader syncing from lowest sync point of data tree and user states.
        // Each request returns 128 blocks, so 10 queue items is 1280 blocks total.
        await this.readSyncInfo();
        const { syncedToRollup } = this.syncStatus;
        const from = Math.min(syncedToRollup, ...this.userStates.map(us => us.getUserData().syncedToRollup)) + 1;
        this.blockDownloader = new BlockDownloader(this.rollupProvider, 10, initialState.initialSubtreeRoots.length);
        this.blockDownloader.start(from);
        await this.genesisSync(initialState);
        await this.genesisSyncMutex.unlock();
        this.synchingPromise = this.startSync();
    }
    async stop() {
        this.running = false;
        await this.blockDownloader?.stop();
        await this.synchingPromise;
    }
    onAbort(cb) {
        this.onAbortCallbacks.push(cb);
    }
    async retrieveGenesisData() {
        const stored = await this.db.getKey('genesisData');
        if (stored) {
            return initialWorldStateFromBuffer(stored);
        }
        this.debug('genesis data not found locally, retrieving from server...');
        const initialWorldState = await retry(() => this.rollupProvider.getInitialWorldState(), 'get initial world state');
        const { initialAccounts, initialSubtreeRoots } = initialWorldState;
        this.debug(`genesis state ${initialAccounts.length} bytes, ${initialSubtreeRoots.length} sub-tree roots.`);
        await this.db.addKey('genesisData', initialWorldStateToBuffer(initialWorldState));
        return initialWorldState;
    }
    // PRIVATE FUNCTIONS
    /**
     * If the world state has no data, download the initial world state data and process it.
     * Returns the initial tree size (e.g. 73 for aztec-connect production).
     */
    async genesisSync(initialState, commitmentsOnly = false) {
        if (this.worldState.getSize() === 0) {
            const genesisTimer = new Timer();
            if (!commitmentsOnly) {
                const accounts = InitHelpers.parseAccountTreeData(initialState.initialAccounts);
                const genesisData = parseGenesisAliasesAndKeys(accounts);
                this.debug(`storing aliases to db...`);
                await this.db.addAliases(genesisData.aliases);
            }
            await this.worldState.insertElements(0, initialState.initialSubtreeRoots);
            this.debug(`genesis sync complete in ${genesisTimer.s()}s`);
        }
    }
    async startSync() {
        const serialQueue = new BoundedSerialQueue(10);
        try {
            this.debug('starting sync task, acquiring mutex...');
            // Only one tab to synchronise at a time.
            while (this.running) {
                const acquired = await this.syncMutex.lock(false);
                // Wether we acquire the lock or not, read the latest persisted state.
                await this.readSyncInfo();
                if (acquired) {
                    this.debug('sync mutex acquired.');
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
            serialQueue.start();
            while (this.running) {
                const blocks = await this.blockDownloader.getBlocks();
                if (!blocks.length) {
                    continue;
                }
                const from = blocks[0].rollupId;
                this.debug(`creating block contexts for ${blocks.length} blocks: ${from} to ${from + blocks.length - 1}...`);
                const blockContexts = blocks.map(b => BlockContext.fromBlock(b, this.pedersen));
                // Push block context on bounded queue. Will block to ensure there are no more than 10 on the queue.
                await serialQueue.put(async () => {
                    await this.handleBlockContexts(blockContexts).catch(async (error) => {
                        await this.abortSync('handleBlockContexts failed', error);
                    });
                    // Forward blocks to user states. This must happen after world state has been updated with those blocks so
                    // that we can get the correct hash paths for the decrypted notes or spending keys added in user states.
                    this.debug(`forwarding ${blocks.length} blocks to ${this.userStates.length} user states...`);
                    if (this.serialize) {
                        for (const userState of this.userStates) {
                            await userState.processBlocks(blockContexts);
                            await userState.flush();
                        }
                    }
                    else {
                        // Push block context to each user states queue. The queues are bounded, this blocks to ensure there are
                        // no more than 10 block contexts on each queue.
                        await Promise.all(this.userStates.map(us => us.processBlocks(blockContexts)));
                    }
                });
                if (this.serialize) {
                    await serialQueue.syncPoint();
                }
            }
        }
        catch (error) {
            // We should never fail. All network io is in the block downloader and it handles it.
            await this.abortSync('startSync() failed', error);
        }
        finally {
            await serialQueue.cancel();
            await this.blockDownloader?.stop();
            await this.syncMutex.unlock();
            this.debug('stopped sync task.');
        }
    }
    /**
     * @notice Fetches blocks and applies them to both core and user states
     * @from Number of a block from which to sync
     */
    async handleBlockContexts(blockContexts) {
        const coreBlockContexts = blockContexts.filter(b => b.rollup.rollupId > this.syncStatus.syncedToRollup);
        if (!coreBlockContexts.length) {
            return;
        }
        // For debugging corrupted data root.
        const oldRoot = this.worldState.getRoot();
        const oldSize = this.worldState.getSize();
        const from = blockContexts[0].block.rollupId;
        const to = blockContexts[blockContexts.length - 1].block.rollupId;
        this.debug(`updating data tree and aliases for ${blockContexts.length} blocks: ${from} to ${to}...`);
        const timer = new Timer();
        // First bring the core in sync (mutable data tree layers and accounts).
        const rollups = coreBlockContexts.map(bc => bc.rollup);
        const offchainTxData = coreBlockContexts.map(bc => bc.block.offchainTxData);
        const subtreeRoots = coreBlockContexts.map(bc => bc.block.subtreeRoot);
        if (this.serialize) {
            await this.serialQueue.push(() => this.worldState.insertElements(rollups[0].dataStartIndex, subtreeRoots));
            await this.processAliases(rollups, offchainTxData);
        }
        else {
            await Promise.all([
                this.serialQueue.push(() => this.worldState.insertElements(rollups[0].dataStartIndex, subtreeRoots)),
                this.processAliases(rollups, offchainTxData),
            ]);
        }
        await this.writeSyncInfo(rollups[rollups.length - 1].rollupId);
        this.debug(`updating data tree and aliases done in ${timer.ms()}ms.`);
        // TODO: Ugly hotfix. Find root cause.
        // We expect our data root to be equal to the new data root in the last block we processed.
        // UPDATE: Possibly solved. But leaving in for now. Can monitor for clientLogs.
        const expectedDataRoot = rollups[rollups.length - 1].newDataRoot;
        const newRoot = this.worldState.getRoot();
        if (!newRoot.equals(expectedDataRoot)) {
            const newSize = this.worldState.getSize();
            // Erase the db so that we can rebuild the merkle tree.
            this.debug('erasing data tree...');
            await this.leveldb.clear();
            await this.writeSyncInfo(-1);
            // Build the merkle tree with genesis data, but skip the aliases because we didn't erase them.
            const initialState = await this.retrieveGenesisData();
            await this.genesisSync(initialState, false);
            await this.abortSync('Invalid dataRoot.', undefined, {
                synchingFromRollup: from,
                blocksReceived: coreBlockContexts.length,
                oldRoot: oldRoot.toString('hex'),
                newRoot: newRoot.toString('hex'),
                newSize,
                oldSize,
                expectedDataRoot: expectedDataRoot.toString('hex'),
            });
        }
    }
    /**
     * Brings this.syncStatus, and user states in line with what's persisted.
     */
    async readSyncInfo() {
        const syncedToRollup = await this.getSyncedToRollup();
        const latestRollupId = await this.rollupProvider.getLatestRollupId();
        this.syncStatus.latestRollupId = latestRollupId;
        if (this.syncStatus.syncedToRollup < syncedToRollup) {
            await this.worldState.syncFromDb();
            this.syncStatus.syncedToRollup = syncedToRollup;
            this.syncStatus.dataRoot = this.worldState.getRoot();
            this.syncStatus.dataSize = this.worldState.getSize();
            this.emit(SdkEvent.UPDATED_WORLD_STATE, this.syncStatus);
        }
        await Promise.all(this.userStates.map(us => us.syncFromDb()));
    }
    /**
     * Persist new syncedToRollup and update this.sdkStatus.
     */
    async writeSyncInfo(syncedToRollup) {
        // This is the "source-of-truth" r.e. what rollup we're synced to.
        await this.leveldb.put('syncedToRollup', syncedToRollup.toString());
        this.syncStatus.syncedToRollup = syncedToRollup;
        this.syncStatus.dataRoot = this.worldState.getRoot();
        this.syncStatus.dataSize = this.worldState.getSize();
        // Keep latestRollupId up-to-date, but only once we know it's lagging.
        // Prevents stalling the compute pipeline on network io.
        if (this.syncStatus.syncedToRollup > this.syncStatus.latestRollupId) {
            this.debug('refreshing latest rollup id...');
            await retry(async () => (this.syncStatus.latestRollupId = await this.rollupProvider.getLatestRollupId()), 'get latest rollup id');
        }
        this.emit(SdkEvent.UPDATED_WORLD_STATE, this.syncStatus);
    }
    async processAliases(rollups, offchainTxData) {
        const processRollup = (rollup, offchainData) => {
            const aliasMap = {};
            let offchainIndex = -1;
            for (let i = 0; i < rollup.innerProofData.length; ++i) {
                const proof = rollup.innerProofData[i];
                if (proof.isPadding()) {
                    continue;
                }
                offchainIndex++;
                if (proof.proofId !== ProofId.ACCOUNT) {
                    continue;
                }
                const createOrMigrate = !!toBigIntBE(proof.nullifier2);
                if (createOrMigrate) {
                    const ocd = OffchainAccountData.fromBuffer(offchainData[offchainIndex]);
                    const { accountPublicKey, aliasHash, spendingPublicKey1 } = ocd;
                    const { noteCommitment1 } = proof;
                    aliasMap[aliasHash.toString()] = {
                        accountPublicKey,
                        aliasHash,
                        index: rollup.dataStartIndex + i * 2,
                        noteCommitment1,
                        spendingPublicKeyX: spendingPublicKey1.subarray(0, 32),
                    };
                }
            }
            return Object.values(aliasMap);
        };
        const aliases = rollups.map((rollup, i) => processRollup(rollup, offchainTxData[i])).flat();
        const upsertTimer = new Timer();
        this.debug(`upserting ${aliases.length} accounts...`);
        await this.db.addAliases(aliases);
        this.debug(`upsert done in ${upsertTimer.ms()}ms...`);
    }
    async getSyncedToRollup() {
        return +(await this.leveldb.get('syncedToRollup').catch(() => -1));
    }
    async abortSync(message, error = new Error(message), log = {}) {
        if (this.running) {
            this.debug(message, error);
            await sendClientLog(this.rollupProvider, {
                ...log,
                message,
                error,
            }, this.debug);
            void this.stop();
            this.onAbortCallbacks.forEach(cb => cb(error));
        }
        throw error;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3luY2hyb25pc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvcmVfc2RrL3N5bmNocm9uaXNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDOUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDNUQsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUNsRCxPQUFPLEVBRUwsMkJBQTJCLEVBQzNCLHlCQUF5QixHQUUxQixNQUFNLHFDQUFxQyxDQUFDO0FBQzdDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUdsRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFFakUsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFHdkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBRTNFLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUMvRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDNUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFdEMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBUzVEOzs7R0FHRztBQUNILE1BQU0sT0FBTyxZQUFhLFNBQVEsWUFBWTtJQVc1QyxZQUNVLGNBQThCLEVBQzlC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
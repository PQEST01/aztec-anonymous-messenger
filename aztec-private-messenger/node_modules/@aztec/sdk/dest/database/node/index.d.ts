/// <reference types="node" resolution-mode="require"/>
import { AliasHash } from '@aztec/barretenberg/account_id';
import { GrumpkinAddress } from '@aztec/barretenberg/address';
import { TxId } from '@aztec/barretenberg/tx_id';
import { ConnectionOptions, DataSource } from 'typeorm';
import { CoreAccountTx, CoreDefiTx, CorePaymentTx } from '../../core_tx/index.js';
import { Note } from '../../note/index.js';
import { UserData } from '../../user/index.js';
import { Alias, BulkUserStateUpdateData, Database, SpendingKey } from '../database.js';
import { SyncDatabase } from '../sync_database.js';
import { AliasDao } from './alias_dao.js';
import { SpendingKeyDao } from './spending_key_dao.js';
import { UserDataDao } from './user_data_dao.js';
export declare const getOrmConfig: (memoryDb?: boolean, identifier?: string) => ConnectionOptions;
export declare class SQLDatabase implements Database {
    private connection;
    private accountTxRep;
    private aliasRep;
    private defiTxRep;
    private keyRep;
    private noteRep;
    private paymentTxRep;
    private userDataRep;
    private spendingKeyRep;
    private mutex;
    constructor(connection: DataSource);
    static getDb(memoryDb?: boolean, identifier?: string): Promise<SQLDatabase | SyncDatabase>;
    close(): Promise<void>;
    clear(): Promise<void>;
    addNote(note: Note, manager?: import("typeorm").EntityManager): Promise<void>;
    getNote(commitment: Buffer): Promise<Note | undefined>;
    getNoteByNullifier(nullifier: Buffer): Promise<Note | undefined>;
    nullifyNote(nullifier: Buffer, manager?: import("typeorm").EntityManager): Promise<void>;
    getNotes(userId: GrumpkinAddress): Promise<Note[]>;
    getPendingNotes(userId: GrumpkinAddress): Promise<Note[]>;
    removeNote(nullifier: Buffer): Promise<void>;
    getUser(accountPublicKey: GrumpkinAddress): Promise<UserDataDao | undefined>;
    addUser(user: UserData): Promise<void>;
    getUsers(): Promise<UserDataDao[]>;
    updateUser(user: UserData, manager?: import("typeorm").EntityManager): Promise<void>;
    removeUser(accountPublicKey: GrumpkinAddress): Promise<void>;
    resetUsers(): Promise<void>;
    upsertPaymentTx(tx: CorePaymentTx, manager?: import("typeorm").EntityManager): Promise<void>;
    getPaymentTx(userId: GrumpkinAddress, txId: TxId): Promise<CorePaymentTx | undefined>;
    getPaymentTxs(userId: any): Promise<CorePaymentTx[]>;
    upsertAccountTx(tx: CoreAccountTx, manager?: import("typeorm").EntityManager): Promise<void>;
    getAccountTx(txId: TxId): Promise<CoreAccountTx | undefined>;
    getAccountTxs(userId: GrumpkinAddress): Promise<CoreAccountTx[]>;
    upsertDefiTx(tx: CoreDefiTx, manager?: import("typeorm").EntityManager): Promise<void>;
    getDefiTx(txId: TxId): Promise<CoreDefiTx | undefined>;
    getDefiTxs(userId: GrumpkinAddress): Promise<CoreDefiTx[]>;
    getUnclaimedDefiTxs(userId: GrumpkinAddress): Promise<CoreDefiTx[]>;
    getUserTxs(userId: GrumpkinAddress): Promise<(CoreAccountTx | CorePaymentTx | CoreDefiTx)[]>;
    isUserTxSettled(txId: TxId): Promise<boolean>;
    getPendingUserTxs(userId: GrumpkinAddress): Promise<(CoreAccountTx | CorePaymentTx | CoreDefiTx)[]>;
    removeUserTx(userId: GrumpkinAddress, txId: TxId): Promise<void>;
    addSpendingKey(spendingKey: SpendingKey, manager?: import("typeorm").EntityManager): Promise<void>;
    private addBulkItems;
    addSpendingKeys(spendingKeys: SpendingKey[]): Promise<void>;
    getSpendingKey(userId: GrumpkinAddress, key: GrumpkinAddress): Promise<SpendingKeyDao | undefined>;
    getSpendingKeys(userId: GrumpkinAddress): Promise<SpendingKeyDao[]>;
    removeSpendingKeys(userId: GrumpkinAddress): Promise<void>;
    addAlias(alias: Alias): Promise<void>;
    addAliases(aliases: Alias[]): Promise<void>;
    getAlias(accountPublicKey: GrumpkinAddress): Promise<AliasDao | undefined>;
    getAliasByAliasHash(aliasHash: AliasHash): Promise<AliasDao | undefined>;
    addKey(name: string, value: Buffer): Promise<void>;
    getKey(name: string): Promise<Buffer | undefined>;
    deleteKey(name: string): Promise<void>;
    acquireLock(name: string, timeout: number): Promise<boolean>;
    extendLock(name: string, timeout: number): Promise<void>;
    releaseLock(name: string): Promise<void>;
    bulkUserStateUpdate(data: BulkUserStateUpdateData): Promise<void>;
}
//# sourceMappingURL=index.d.ts.map
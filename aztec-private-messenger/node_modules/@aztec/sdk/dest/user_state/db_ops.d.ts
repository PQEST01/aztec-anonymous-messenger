import { Grumpkin } from '@aztec/barretenberg/ecc';
import { NoteAlgorithms, TreeNote } from '@aztec/barretenberg/note_algorithms';
import { OffchainAccountData, OffchainDefiDepositData, OffchainJoinSplitData } from '@aztec/barretenberg/offchain_tx_data';
import { RollupProofData } from '@aztec/barretenberg/rollup_proof';
import { BlockContext } from '../block_context/block_context.js';
import { Database } from '../database/index.js';
import { UserData } from '../user/index.js';
interface Input {
    blockContexts: BlockContext[];
    rollupProofData: RollupProofData[];
    offchainJoinSplitData: OffchainJoinSplitData[];
    offchainAccountData: OffchainAccountData[];
    offchainDefiDepositData: OffchainDefiDepositData[];
    treeNotes: (TreeNote | undefined)[];
}
/**
 * This class computes the various db updates that need to occur as an effect of processing a batch of rollups.
 * The write operations are collected together in a single bulk update structure, that is then passed to the database
 * to process within a single transaction. This means either the full update occurs or not at all. The atomicity here
 * is probably not hugely important as the db updates are idempotent, however the performance gained by doing a single
 * operation is desirable, especially with indexeddb.
 * This approach encourages a design whereby we minimise reads from the database in order to perform the writes.
 * The bulk update will always perform all insertion operations first, followed by any update operations. This
 * guarantees that updates that need to key on an entity that's expected to exist, will succeed.
 *
 * PaymentTx:
 *   Adds up to two new notes and nullifies up to two notes. Upserts a settled payment tx.
 *   The payment tx records the privateInput, which requires knowledge of the input notes.
 *
 * AccountTx:
 *   Adds up to two spending keys. Upserts a settled account tx.
 *
 * DefiTx:
 *   Adds a single change note and nullifies up to two notes. Upserts a settled defi tx.
 *   At this point we learn the interaction nonce, claim note nullifier, and if async.
 *
 * DefiInteractionResult:
 *   Updates a DefiTx with the output values, depends on access to the DefiTx state.
 *
 * ClaimTx:
 *   Adds up to two notes that depend on access to the DefiTx state. Updates a DefiTx to mark it as claimed.
 *
 * In order to support the processing of DefiInteractionResults and ClaimTxs that require access to the prior DefiTx
 * state, we preload all unclaimed DefiTxs in `unclaimedDefiTxs`.
 * As we process blocks we maintain these unclaimed DefiTxs accordingly so we can produce the appropriate db writes.
 *
 * In order to support the processing of PaymentTxs that record the privateInput, we track new Notes in `unspentNotes`,
 * and when nullifying Notes as part of a PaymentTx we look there first, and if not found perform a db read to load
 * the note.
 */
export declare class DbOps {
    private userData;
    private noteAlgos;
    private db;
    private grumpkin;
    private writeData;
    private unspentNotes;
    private pendingUserTxs;
    private unclaimedDefiTxs;
    constructor(userData: UserData, noteAlgos: NoteAlgorithms, db: Database, grumpkin: Grumpkin);
    handleTxs({ blockContexts, rollupProofData, offchainJoinSplitData, offchainAccountData, offchainDefiDepositData, treeNotes, }: Input): Promise<void>;
    private handleAccountTx;
    private createAccountTx;
    private handlePaymentTx;
    private createPaymentTx;
    private handleDefiDepositTx;
    private processDefiInteractionResults;
    private handleClaimTx;
    private addNote;
    private nullifyNote;
    /**
     * We only need to upsert a modified DefiTx once. Also if we want to perform upserts concurrently, we don't want
     * duplicates. Keeps only the last recorded upsert for DefiTxs.
     */
    private deDupeWriteDataUpserts;
    private debug;
}
export {};
//# sourceMappingURL=db_ops.d.ts.map
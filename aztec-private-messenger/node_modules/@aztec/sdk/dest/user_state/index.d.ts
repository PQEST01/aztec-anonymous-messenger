/// <reference types="node" resolution-mode="require"/>
import { Grumpkin } from '@aztec/barretenberg/ecc';
import { NoteAlgorithms, NoteDecryptor } from '@aztec/barretenberg/note_algorithms';
import { RollupProvider } from '@aztec/barretenberg/rollup_provider';
import { EventEmitter } from 'events';
import { BlockContext } from '../block_context/block_context.js';
import { Database } from '../database/index.js';
import { Note } from '../note/index.js';
import { NotePickerOptions } from '../note_picker/index.js';
import { ProofOutput } from '../proofs/index.js';
import { UserData } from '../user/index.js';
export declare enum UserStateEvent {
    UPDATED_USER_STATE = "UPDATED_USER_STATE"
}
export declare class UserState extends EventEmitter {
    private userData;
    private grumpkin;
    private noteAlgos;
    private noteDecryptor;
    private db;
    private rollupProvider;
    private pendingNoteNullifiersRequest;
    private notePickersRequest;
    private decryptQueue;
    private dbOpsQueue;
    private latestQueuedRollup;
    constructor(userData: UserData, grumpkin: Grumpkin, noteAlgos: NoteAlgorithms, noteDecryptor: NoteDecryptor, db: Database, rollupProvider: RollupProvider);
    init(): Promise<void>;
    shutdown(flush?: boolean): Promise<void>;
    flush(): Promise<void>;
    /**
     * Should be called before reading any state that has persistent storage that may have changed underfoot.
     * If the user has synched further underfoot, we refresh our notepicker and emit an update event.
     */
    syncFromDb(): Promise<void>;
    isSynchronised(latestRollupId: number): boolean;
    awaitSynchronised(latestRollupId: number, timeout?: number): Promise<void>;
    getUserData(): UserData;
    processBlocks(blockContexts: BlockContext[]): Promise<void>;
    handleBlocks(blockContexts: BlockContext[]): Promise<void>;
    pickNotes(assetId: number, value: bigint, options?: NotePickerOptions): Promise<Note[]>;
    pickNote(assetId: number, value: bigint, options?: NotePickerOptions): Promise<Note | undefined>;
    getSpendableNoteValues(assetId: number, options?: NotePickerOptions): Promise<bigint[]>;
    getSpendableSum(assetId: number, options?: NotePickerOptions): Promise<bigint>;
    getSpendableSums(options?: NotePickerOptions): Promise<{
        assetId: number;
        value: bigint;
    }[]>;
    getMaxSpendableNoteValues(assetId: number, options?: NotePickerOptions & {
        numNotes?: number;
    }): Promise<bigint[]>;
    getBalance(assetId: number): Promise<bigint>;
    getBalances(): Promise<{
        assetId: number;
        value: bigint;
    }[]>;
    addProof({ tx, outputNotes }: ProofOutput): Promise<void>;
    /**
     * Purge pending txs no longer on server.
     */
    private resetData;
    private getNotePickers;
    private processPendingNote;
    private debug;
    private debugDecrypt;
}
export declare class UserStateFactory {
    private grumpkin;
    private noteAlgos;
    private noteDecryptor;
    private db;
    private rollupProvider;
    constructor(grumpkin: Grumpkin, noteAlgos: NoteAlgorithms, noteDecryptor: NoteDecryptor, db: Database, rollupProvider: RollupProvider);
    createUserState(user: UserData): Promise<UserState>;
}
//# sourceMappingURL=index.d.ts.map
import { sha256 } from '../crypto/index.js';
import { numToUInt8 } from '../serialize/index.js';
export function deriveNoteSecret(ecdhPubKey, ecdhPrivKey, grumpkin) {
    const sharedSecret = grumpkin.mul(ecdhPubKey.toBuffer(), ecdhPrivKey);
    const secretBufferA = Buffer.concat([sharedSecret, numToUInt8(2)]);
    const secretBufferB = Buffer.concat([sharedSecret, numToUInt8(3)]);
    const hashA = sha256(secretBufferA);
    const hashB = sha256(secretBufferB);
    const hash = Buffer.concat([hashA, hashB]);
    // Note: to get close to uniformly-distributed field elements, we need to start with 512-bits before modulo
    // reduction (not 256) - hence why we hash _twice_ and concatenate above.
    return grumpkin.reduce512BufferToFr(hash);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVyaXZlX25vdGVfc2VjcmV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL25vdGVfYWxnb3JpdGhtcy9kZXJpdmVfbm90ZV9zZWNyZXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRzVDLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUVuRCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsVUFBMkIsRUFBRSxXQUFtQixFQUFFLFFBQWtCO0lBQ25HLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3RFLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRSxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsWUFBWSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkUsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0lBQ3BDLE1BQU0sS0FBSyxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUNwQyxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDM0MsMkdBQTJHO0lBQzNHLHlFQUF5RTtJQUN6RSxPQUFPLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QyxDQUFDIn0=
import { MerkleTree, MemoryMerkleTree, HashPath } from '../merkle_tree/index.js';
import { WorldStateConstants } from './world_state_constants.js';
import { createDebugLogger } from '../log/index.js';
const debug = createDebugLogger('bb:world_state');
/**
 * Wraps the merkle tree that represents the "mutable" part of the data tree. That is the tree where each leaf
 * is the root of rollups data subtree. Provides ability to compute a complete hash path when given a rollups
 * "immutable" data tree.
 *
 * It is *NOT* safe to concurrently perform reads and writes, due the underlying merkle tree implementation.
 * Even though it does its updates in a batch, the walking of the tree first makes it unsafe.
 * There is no point protecting the merkle tree with a mutex here, as in any practical context, there will be
 * several external reads that need to performed atomically. Thus, the caller is responsible for mutexing reads
 * and write appropriately. Another option would be to change the API here to e.g. `getHashPaths([])`, but
 * that maybe restrictive from a client perspective.
 */
export class WorldState {
    constructor(db, pedersen) {
        this.db = db;
        this.pedersen = pedersen;
        this.subTreeDepth = 0;
    }
    async init(subTreeDepth) {
        const subTreeSize = 1 << subTreeDepth;
        this.subTreeDepth = subTreeDepth;
        const zeroNotes = Array(subTreeSize).fill(MemoryMerkleTree.ZERO_ELEMENT);
        const subTree = await MemoryMerkleTree.new(zeroNotes, this.pedersen);
        const treeSize = WorldStateConstants.DATA_TREE_DEPTH - subTreeDepth;
        const subTreeRoot = subTree.getRoot();
        debug(`initialising data tree with depth ${treeSize} and zero element of ${subTreeRoot.toString('hex')}`);
        try {
            this.tree = await MerkleTree.fromName(this.db, this.pedersen, 'data', subTreeRoot);
        }
        catch (e) {
            this.tree = await MerkleTree.new(this.db, this.pedersen, 'data', treeSize, subTreeRoot);
        }
        this.logTreeStats();
    }
    // builds a hash path at index 0 for a 'zero' tree of the given depth
    buildZeroHashPath(depth = WorldStateConstants.DATA_TREE_DEPTH) {
        let current = MemoryMerkleTree.ZERO_ELEMENT;
        const bufs = [];
        for (let i = 0; i < depth; i++) {
            bufs.push([current, current]);
            current = this.pedersen.compress(current, current);
        }
        return new HashPath(bufs);
    }
    convertNoteIndexToSubTreeIndex(noteIndex) {
        return noteIndex >> this.subTreeDepth;
    }
    async buildFullHashPath(noteIndex, immutableHashPath) {
        const noteSubTreeIndex = this.convertNoteIndexToSubTreeIndex(noteIndex);
        const mutablePath = await this.getHashPath(noteSubTreeIndex);
        const fullHashPath = new HashPath(immutableHashPath.data.concat(mutablePath.data));
        return fullHashPath;
    }
    async insertElement(index, element) {
        const subRootIndex = this.convertNoteIndexToSubTreeIndex(index);
        await this.tree.updateElement(subRootIndex, element);
        this.logTreeStats();
    }
    async insertElements(startIndex, elements) {
        const subRootIndex = this.convertNoteIndexToSubTreeIndex(startIndex);
        await this.tree.updateElements(subRootIndex, elements);
        this.logTreeStats();
    }
    logTreeStats() {
        debug(`data size: ${this.tree.getSize()}`);
        debug(`data root: ${this.tree.getRoot().toString('hex')}`);
    }
    async syncFromDb() {
        await this.tree.syncFromDb();
    }
    async getHashPath(index) {
        return await this.tree.getHashPath(index);
    }
    getRoot() {
        return this.tree.getRoot();
    }
    getSize() {
        return this.tree.getSize();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29ybGRfc3RhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvd29ybGRfc3RhdGUvd29ybGRfc3RhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxRQUFRLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNqRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUdqRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUVwRCxNQUFNLEtBQUssR0FBRyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBRWxEOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBTSxPQUFPLFVBQVU7SUFJckIsWUFBb0IsRUFBVyxFQUFVLFFBQWtCO1FBQXZDLE9BQUUsR0FBRixFQUFFLENBQVM7UUFBVSxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBRm5ELGlCQUFZLEdBQUcsQ0FBQyxDQUFDO0lBRXFDLENBQUM7SUFFeEQsS0FBSyxDQUFDLElBQUksQ0FBQyxZQUFvQjtRQUNwQyxNQUFNLFdBQVcsR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDO1FBQ3RDLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDekUsTUFBTSxPQUFPLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNyRSxNQUFNLFFBQVEsR0FBRyxtQkFBbUIsQ0FBQyxlQUFlLEdBQUcsWUFBWSxDQUFDO1FBQ3BFLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUN0QyxLQUFLLENBQUMscUNBQXFDLFFBQVEsd0JBQXdCLFdB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
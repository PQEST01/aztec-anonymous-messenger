import { HashPath } from './hash_path.js';
import { createDebugLogger } from '../log/debug.js';
import { Timer } from '../timer/index.js';
const debug = createDebugLogger('bb:merkle_tree');
const MAX_DEPTH = 32;
function keepNLsb(input, numBits) {
    return numBits >= MAX_DEPTH ? input : input & ((1 << numBits) - 1);
}
export class MerkleTree {
    constructor(db, hasher, name, depth, size = 0, root, initialLeafValue = MerkleTree.ZERO_ELEMENT) {
        this.db = db;
        this.hasher = hasher;
        this.name = name;
        this.depth = depth;
        this.size = size;
        this.initialLeafValue = initialLeafValue;
        this.zeroHashes = [];
        if (!(depth >= 1 && depth <= MAX_DEPTH)) {
            throw Error('Bad depth');
        }
        // Compute the zero values at each layer.
        let current = initialLeafValue;
        for (let i = 0; i < depth; ++i) {
            this.zeroHashes[i] = current;
            current = hasher.compress(current, current);
        }
        this.root = root ? root : current;
    }
    static async new(db, hasher, name, depth, initialLeafValue = MerkleTree.ZERO_ELEMENT) {
        const tree = new MerkleTree(db, hasher, name, depth, 0, undefined, initialLeafValue);
        await tree.writeMeta();
        return tree;
    }
    static async fromName(db, hasher, name, initialLeafValue = MerkleTree.ZERO_ELEMENT) {
        const meta = await db.get(Buffer.from(name));
        const root = meta.slice(0, 32);
        const depth = meta.readUInt32LE(32);
        const size = meta.readUInt32LE(36);
        return new MerkleTree(db, hasher, name, depth, size, root, initialLeafValue);
    }
    async syncFromDb() {
        const meta = await this.db.get(Buffer.from(this.name));
        this.root = meta.slice(0, 32);
        this.depth = meta.readUInt32LE(32);
        this.size = meta.readUInt32LE(36);
    }
    async writeMeta(batch) {
        const data = Buffer.alloc(40);
        this.root.copy(data);
        data.writeUInt32LE(this.depth, 32);
        data.writeUInt32LE(this.size, 36);
        if (batch) {
            batch.put(this.name, data);
        }
        else {
            await this.db.put(this.name, data);
        }
    }
    getRoot() {
        return this.root;
    }
    getSize() {
        return this.size;
    }
    /**
     * Returns a hash path for the element at the given index.
     * The hash path is an array of pairs of hashes, with the lowest pair (leaf hashes) first, and the highest pair last.
     */
    async getHashPath(index) {
        const path = new HashPath();
        let data = await this.dbGet(this.root);
        for (let i = this.depth - 1; i >= 0; --i) {
            if (!data) {
                // This is an empty subtree. Fill in zero value.
                path.data[i] = [this.zeroHashes[i], this.zeroHashes[i]];
                continue;
            }
            if (data.length > 64) {
                // Data is a subtree. Extract hash pair at height i.
                const subtreeDepth = i + 1;
                let layerSize = 2 ** subtreeDepth;
                let offset = 0;
                index = keepNLsb(index, subtreeDepth);
                for (let j = 0; j < subtreeDepth; ++j) {
                    index -= index & 0x1;
                    const lhsOffset = offset + index * 32;
                    path.data[j] = [data.slice(lhsOffset, lhsOffset + 32), data.slice(lhsOffset + 32, lhsOffset + 64)];
                    offset += layerSize * 32;
                    layerSize >>= 1;
                    index >>= 1;
                }
                break;
            }
            const lhs = data.slice(0, 32);
            const rhs = data.slice(32, 64);
            path.data[i] = [lhs, rhs];
            const isRight = (index >> i) & 0x1;
            data = await this.dbGet(isRight ? rhs : lhs);
        }
        return path;
    }
    async updateElement(index, value) {
        return await this.updateLeafHash(index, value.equals(Buffer.alloc(32, 0)) ? this.initialLeafValue : value);
    }
    async updateLeafHash(index, leafHash) {
        const batch = this.db.batch();
        this.root = await this.updateElementInternal(this.root, leafHash, index, this.depth, batch);
        this.size = Math.max(this.size, index + 1);
        await this.writeMeta(batch);
        await batch.write();
    }
    async updateElementInternal(root, value, index, height, batch) {
        if (height === 0) {
            return value;
        }
        const data = await this.dbGet(root);
        const isRight = (index >> (height - 1)) & 0x1;
        let left = data ? data.slice(0, 32) : this.zeroHashes[height - 1];
        let right = data ? data.slice(32, 64) : this.zeroHashes[height - 1];
        const subtreeRoot = isRight ? right : left;
        const newSubtreeRoot = await this.updateElementInternal(subtreeRoot, value, keepNLsb(index, height - 1), height - 1, batch);
        if (isRight) {
            right = newSubtreeRoot;
        }
        else {
            left = newSubtreeRoot;
        }
        const newRoot = this.hasher.compress(left, right);
        batch.put(newRoot, Buffer.concat([left, right]));
        if (!root.equals(newRoot)) {
            batch.del(root);
        }
        return newRoot;
    }
    async updateElements(index, values) {
        const zeroBuf = Buffer.alloc(32, 0);
        return await this.updateLeafHashes(index, values.map(v => (v.equals(zeroBuf) ? this.initialLeafValue : v)));
    }
    /**
     * Updates all the given values, starting at index. This is optimal when inserting multiple values, as it can
     * compute a single subtree and insert it in one go.
     * However it comes with restrictions:
     * - The insertion index must be a multiple of the subtree size, which must be power of 2.
     * - The insertion index must be >= the current size of the tree (inserting into an empty location).
     *
     * We cannot over extend the tree size, as these inserts are bulk inserts, and a subsequent update would involve
     * a lot of complexity adjusting a previously inserted bulk insert. For this reason depending on the number of
     * values to insert, it will be chunked into the fewest number of subtrees required to grow the tree be precisely
     * that size. In normal operation (e.g. continuously inserting 64 values), we will be able to leverage single inserts.
     * Only when synching creates a non power of 2 set of values will the chunking mechanism come into play.
     * e.g. If we need insert 192 values, first a subtree of 128 is inserted, then a subtree of 64.
     */
    async updateLeafHashes(index, leafHashes) {
        while (leafHashes.length) {
            const batch = this.db.batch();
            let subtreeDepth = Math.ceil(Math.log2(leafHashes.length));
            let subtreeSize = 2 ** subtreeDepth;
            // We need to reduce the size of the subtree being inserted until it is:
            // a) Less than or equal in size to the number of values being inserted.
            // b) Fits in a subtree, with a size that is a multiple of the insertion index.
            while (leafHashes.length < subtreeSize || index % subtreeSize !== 0) {
                subtreeSize >>= 1;
                subtreeDepth--;
            }
            const toInsert = leafHashes.slice(0, subtreeSize);
            const hashes = await this.hasher.hashToTree(toInsert);
            debug(`updateLeafHashes calculating batch update to insert ${toInsert.length} leaves at ${index}...`);
            this.root = await this.updateElementsInternal(this.root, hashes, index, this.depth, subtreeDepth, batch);
            // Slice off inserted values and adjust next insertion index.
            leafHashes = leafHashes.slice(subtreeSize);
            index += subtreeSize;
            this.size = index;
            await this.writeMeta(batch);
            const writeTimer = new Timer();
            debug(`updateLeafHashes writing ${toInsert.length} leaves...`);
            await batch.write();
            debug(`updateLeafHashes write complete in ${writeTimer.ms()}ms.`);
        }
    }
    async updateElementsInternal(root, hashes, index, height, subtreeHeight, batch) {
        if (height === subtreeHeight) {
            const root = hashes.pop();
            batch.put(root, Buffer.concat(hashes));
            return root;
        }
        // Do nothing if updating zero values.
        if (hashes[hashes.length - 1].equals(this.zeroHashes[height - 1])) {
            return root;
        }
        const data = await this.dbGet(root);
        const isRight = (index >> (height - 1)) & 0x1;
        if (data && data.length > 64) {
            if (!root.equals(hashes[hashes.length - 1])) {
                throw new Error('Attempting to update pre-existing subtree.');
            }
            return root;
        }
        let left = data ? data.slice(0, 32) : this.zeroHashes[height - 1];
        let right = data ? data.slice(32, 64) : this.zeroHashes[height - 1];
        const subtreeRoot = isRight ? right : left;
        const newSubtreeRoot = await this.updateElementsInternal(subtreeRoot, hashes, keepNLsb(index, height - 1), height - 1, subtreeHeight, batch);
        if (isRight) {
            right = newSubtreeRoot;
        }
        else {
            left = newSubtreeRoot;
        }
        const newRoot = this.hasher.compress(left, right);
        batch.put(newRoot, Buffer.concat([left, right]));
        if (!root.equals(newRoot)) {
            batch.del(root);
        }
        return newRoot;
    }
    async dbGet(key) {
        return await this.db.get(key).catch(() => { });
    }
}
MerkleTree.ZERO_ELEMENT = Buffer.from('0000000000000000000000000000000000000000000000000000000000000000', 'hex');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVya2xlX3RyZWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvbWVya2xlX3RyZWUvbWVya2xlX3RyZWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUUxQyxNQUFNLEtBQUssR0FBRyxpQkFBaUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0FBQ2xELE1BQU0sU0FBUyxHQUFHLEVBQUUsQ0FBQztBQUVyQixTQUFTLFFBQVEsQ0FBQyxLQUFhLEVBQUUsT0FBZTtJQUM5QyxPQUFPLE9BQU8sSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckUsQ0FBQztBQUVELE1BQU0sT0FBTyxVQUFVO0lBS3JCLFlBQ1UsRUFBVyxFQUNYLE1BQWMsRUFDZCxJQUFZLEVBQ1osS0FBYSxFQUNiLE9BQWUsQ0FBQyxFQUN4QixJQUFhLEVBQ0wsbUJBQW1CLFVBQVUsQ0FBQyxZQUFZO1FBTjFDLE9BQUUsR0FBRixFQUFFLENBQVM7UUFDWCxXQUFNLEdBQU4sTUFBTSxDQUFRO1FBQ2QsU0FBSSxHQUFKLElBQUksQ0FBUTtRQUNaLFVBQUssR0FBTCxLQUFLLENBQVE7UUFDYixTQUFJLEdBQUosSUFBSSxDQUFZO1FBRWhCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBMEI7UUFUNUMsZUFBVSxHQUFhLEVBQUUsQ0FBQztRQVdoQyxJQUFJLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxTQUFTLENBQUMsRUFBRTtZQUN2QyxNQUFNLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUMxQjtRQUVELHlDQUF5QztRQUN6QyxJQUFJLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQztRQUMvQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzlCLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDO1lBQzdCLE9BQU8sR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztTQUM3QztRQUVELElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUNwQyxDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQ2QsRUFBVyxFQUNYLE1BQWMsRUFDZCxJQUFZLEVBQ1osS0FBYSxFQUNiLGdCQUFnQixHQUFHLFVBQVUsQ0FBQyxZQUFZO1FBRTFDLE1BQU0sSUFBSSxHQUFHLElBQUksVUFBVSxDQUFDLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixDQUFDLENBQUM7UUFDckYsTUFBTSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7UUFFdkIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsRUFBVyxFQUFFLE1BQWMsRUFBRSxJQUFZLEVBQUUsZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLFlBQVk7UUFDekcsTUFBTSxJQUFJLEdBQVcsTUFBTSxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNyRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUMvQixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFTSxLQUFLLENBQUMsVUFBVTtRQUNyQixNQUFNLElBQUksR0FBVyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUM5QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFTyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQW9DO1FBQzFELE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNsQyxJQUFJLEtBQUssRUFBRTtZQUNULEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUM1QjthQUFNO1lBQ0wsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3BDO0lBQ0gsQ0FBQztJQUVNLE9BQU87UUFDWixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVNLE9BQU87UUFDWixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLEtBQUssQ0FBQyxXQUFXLENBQUMsS0FBYTtRQUNwQyxNQUFNLElBQUksR0FBRyxJQUFJLFFBQVEsRUFBRSxDQUFDO1FBRTVCLElBQUksSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFdkMsS0FBSyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ3hDLElBQUksQ0FBQyxJQUFJLEVBQUU7Z0JBQ1QsZ0RBQWdEO2dCQUNoRCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hELFNBQVM7YUFDVjtZQUVELElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxFQUFFLEVBQUU7Z0JBQ3BCLG9EQUFvRDtnQkFDcEQsTUFBTSxZQUFZLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQkFDM0IsSUFBSSxTQUFTLEdBQUcsQ0FBQyxJQUFJLFlBQVksQ0FBQztnQkFDbEMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO2dCQUNmLEtBQUssR0FBRyxRQUFRLENBQUMsS0FBSyxFQUFFLFlBQVksQ0FBQyxDQUFDO2dCQUN0QyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxFQUFFLEVBQUUsQ0FBQyxFQUFFO29CQUNyQyxLQUFLLElBQUksS0FBSyxHQUFHLEdBQUcsQ0FBQztvQkFDckIsTUFBTSxTQUFTLEdBQUcsTUFBTSxHQUFHLEtBQUssR0FBRyxFQUFFLENBQUM7b0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxTQUFTLEdBQUcsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsRUFBRSxFQUFFLFNBQVMsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUNuRyxNQUFNLElBQUksU0FBUyxHQUFHLEVBQUUsQ0FBQztvQkFDekIsU0FBUyxLQUFLLENBQUMsQ0FBQztvQkFDaEIsS0FBSyxLQUFLLENBQUMsQ0FBQztpQkFDYjtnQkFDRCxNQUFNO2FBQ1A7WUFFRCxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUM5QixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztZQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQzFCLE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztZQUNuQyxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUM5QztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVNLEtBQUssQ0FBQyxhQUFhLENBQUMsS0FBYSxFQUFFLEtBQWE7UUFDckQsT0FBTyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3RyxDQUFDO0lBRU0sS0FBSyxDQUFDLGNBQWMsQ0FBQyxLQUFhLEVBQUUsUUFBZ0I7UUFDekQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUM5QixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRTVGLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQztRQUUzQyxNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUIsTUFBTSxLQUFLLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVPLEtBQUssQ0FBQyxxQkFBcUIsQ0FDakMsSUFBWSxFQUNaLEtBQWEsRUFDYixLQUFhLEVBQ2IsTUFBYyxFQUNkLEtBQW1DO1FBRW5DLElBQUksTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNoQixPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBRTlDLElBQUksSUFBSSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ2xFLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDM0MsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMscUJBQXFCLENBQ3JELFdBQVcsRUFDWCxLQUFLLEVBQ0wsUUFBUSxDQUFDLEtBQUssRUFBRSxNQUFNLEdBQUcsQ0FBQyxDQUFDLEVBQzNCLE1BQU0sR0FBRyxDQUFDLEVBQ1YsS0FBSyxDQUNOLENBQUM7UUFFRixJQUFJLE9BQU8sRUFBRTtZQUNYLEtBQUssR0FBRyxjQUFjLENBQUM7U0FDeEI7YUFBTTtZQUNMLElBQUksR0FBRyxjQUFjLENBQUM7U0FDdkI7UUFDRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDbEQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEVBQUU7WUFDekIsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQjtRQUNELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFTSxLQUFLLENBQUMsY0FBYyxDQUFDLEtBQWEsRUFBRSxNQUFnQjtRQUN6RCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQyxPQUFPLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUNoQyxLQUFLLEVBQ0wsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUNqRSxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsS0FBYSxFQUFFLFVBQW9CO1FBQy9ELE9BQU8sVUFBVSxDQUFDLE1BQU0sRUFBRTtZQUN4QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQzlCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztZQUMzRCxJQUFJLFdBQVcsR0FBRyxDQUFDLElBQUksWUFBWSxDQUFDO1lBRXBDLHdFQUF3RTtZQUN4RSx3RUFBd0U7WUFDeEUsK0VBQStFO1lBQy9FLE9BQU8sVUFBVSxDQUFDLE1BQU0sR0FBRyxXQUFXLElBQUksS0FBSyxHQUFHLFdBQVcsS0FBSyxDQUFDLEVBQUU7Z0JBQ25FLFdBQVcsS0FBSyxDQUFDLENBQUM7Z0JBQ2xCLFlBQVksRUFBRSxDQUFDO2FBQ2hCO1lBRUQsTUFBTSxRQUFRLEdBQUcsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDbEQsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUV0RCxLQUFLLENBQUMsdURBQXVELFFBQVEsQ0FBQyxNQUFNLGNBQWMsS0FBSyxLQUFLLENBQUMsQ0FBQztZQUN0RyxJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxFQUFFLFlBQVksRUFBRSxLQUFLLENBQUMsQ0FBQztZQUV6Ryw2REFBNkQ7WUFDN0QsVUFBVSxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7WUFDM0MsS0FBSyxJQUFJLFdBQVcsQ0FBQztZQUNyQixJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQztZQUVsQixNQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDNUIsTUFBTSxVQUFVLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztZQUMvQixLQUFLLENBQUMsNEJBQTRCLFFBQVEsQ0FBQyxNQUFNLFlBQVksQ0FBQyxDQUFDO1lBQy9ELE1BQU0sS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ3BCLEtBQUssQ0FBQyxzQ0FBc0MsVUFBVSxDQUFDLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUNuRTtJQUNILENBQUM7SUFFTyxLQUFLLENBQUMsc0JBQXNCLENBQ2xDLElBQVksRUFDWixNQUFnQixFQUNoQixLQUFhLEVBQ2IsTUFBYyxFQUNkLGFBQXFCLEVBQ3JCLEtBQW1DO1FBRW5DLElBQUksTUFBTSxLQUFLLGFBQWEsRUFBRTtZQUM1QixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsR0FBRyxFQUFHLENBQUM7WUFDM0IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ3ZDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxzQ0FBc0M7UUFDdEMsSUFBSSxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUNqRSxPQUFPLElBQUksQ0FBQztTQUNiO1FBRUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLE1BQU0sT0FBTyxHQUFHLENBQUMsS0FBSyxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBRTlDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxFQUFFO1lBQzVCLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUU7Z0JBQzNDLE1BQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLENBQUMsQ0FBQzthQUMvRDtZQUNELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxJQUFJLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNsRSxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztRQUNwRSxNQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQzNDLE1BQU0sY0FBYyxHQUFHLE1BQU0sSUFBSSxDQUFDLHNCQUFzQixDQUN0RCxXQUFXLEVBQ1gsTUFBTSxFQUNOLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUMzQixNQUFNLEdBQUcsQ0FBQyxFQUNWLGFBQWEsRUFDYixLQUFLLENBQ04sQ0FBQztRQUVGLElBQUksT0FBTyxFQUFFO1lBQ1gsS0FBSyxHQUFHLGNBQWMsQ0FBQztTQUN4QjthQUFNO1lBQ0wsSUFBSSxHQUFHLGNBQWMsQ0FBQztTQUN2QjtRQUNELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztRQUNsRCxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN6QixLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ2pCO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVPLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBVztRQUM3QixPQUFPLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7O0FBelJhLHVCQUFZLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxrRUFBa0UsRUFBRSxLQUFLLENBQUMsQ0FBQyJ9
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { TxHash } from '../blockchain/index.js';
import { DefiInteractionEvent } from './defi_interaction_event.js';
import { EventEmitter } from 'stream';
export declare class Block {
    txHash: TxHash;
    mined: Date;
    rollupId: number;
    rollupSize: number;
    encodedRollupProofData: Buffer;
    offchainTxData: Buffer[];
    interactionResult: DefiInteractionEvent[];
    gasUsed: number;
    gasPrice: bigint;
    subtreeRoot?: Buffer | undefined;
    constructor(txHash: TxHash, mined: Date, rollupId: number, rollupSize: number, encodedRollupProofData: Buffer, offchainTxData: Buffer[], interactionResult: DefiInteractionEvent[], gasUsed: number, gasPrice: bigint, subtreeRoot?: Buffer | undefined);
    static deserialize(buf: Buffer, offset?: number): {
        elem: Block;
        adv: number;
    };
    static fromBuffer(buf: Buffer): Block;
    toBuffer(): Buffer;
}
export interface BlockSource extends EventEmitter {
    /**
     * Returns up to `take` blocks from rollup id `from`.
     * This does not guarantee all blocks are returned. It may return a subset, and the
     * client should use `getLatestRollupId()` to determine if it needs to make further requests.
     */
    getBlocks(from: number, take?: number): Promise<Block[]>;
    /**
     * Starts emitting rollup blocks.
     * All historical blocks must have been emitted before this function returns.
     */
    start(fromBlock?: number): Promise<void>;
    stop(): Promise<void>;
    on(event: 'block', fn: (block: Block) => void): this;
    on(event: 'versionMismatch', fn: (error: string) => void): this;
    removeAllListeners(): this;
    getLatestRollupId(): Promise<number>;
}
export * from './server_block_source.js';
export * from './defi_interaction_event.js';
export * from './decoded_block.js';
//# sourceMappingURL=index.d.ts.map
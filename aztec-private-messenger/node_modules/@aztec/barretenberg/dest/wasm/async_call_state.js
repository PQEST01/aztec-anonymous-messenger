/**
 * To enable asynchronous callbacks from wasm to js, we leverage asyncify.
 * https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html
 *
 * This class holds state and logic specific to handling async calls from wasm to js.
 * A single instance of this class is instantiated as part of BarretenbergWasm.
 * It allocates some memory for the asyncify stack data and initialises it.
 *
 * To make an async call into the wasm, just call `call` the same as in BarretenbergWasm, only it returns a promise.
 *
 * To make an async import that will be called from the wasm, wrap a function with the signature:
 *   my_func(state: AsyncFnState, ...args)
 * with a call to `wrapImportFn`.
 * The arguments are whatever the original call arguments were. The addition of AsyncFnState as the first argument
 * allows for the detection of wether the function is continuing after the the async call has completed.
 * If `state.continuation` is false, the function should start its async operation and return the promise.
 * If `state.continuation` is true, the function can get the result from `state.result` perform any finalisation,
 * and return an (optional) value to the wasm.
 */
export class AsyncCallState {
    constructor() {
        this.ASYNCIFY_DATA_SIZE = 16 * 1024;
        this.debug = console.log;
    }
    init(memory, callExport, debug = console.log) {
        this.memory = memory;
        this.debug = debug;
        this.callExport = callExport;
        // Allocate memory for asyncify stack data.
        this.asyncifyDataAddr = this.callExport('bbmalloc', this.ASYNCIFY_DATA_SIZE);
        const view = new Uint32Array(this.memory.buffer);
        // First two integers of asyncify data, are the start and end of the stack region.
        view[this.asyncifyDataAddr >> 2] = this.asyncifyDataAddr + 8;
        view[(this.asyncifyDataAddr + 4) >> 2] = this.asyncifyDataAddr + this.ASYNCIFY_DATA_SIZE;
    }
    destroy() {
        // Free call stack data.
        this.callExport('bbfree', this.asyncifyDataAddr);
    }
    /**
     * We call the wasm function, that will in turn call back into js via callImport and set this.asyncPromise and
     * enable the instrumented "record stack unwinding" code path.
     * Once the stack has unwound out of the wasm call, we enter into a loop of resolving the promise set in the call
     * to callImport, and calling back into the wasm to rewind the stack and continue execution.
     */
    async call(name, ...args) {
        this.state = { continuation: false };
        let result = this.callExport(name, ...args);
        while (this.asyncPromise) {
            // Disable the instrumented "record stack unwinding" code path.
            this.callExport('asyncify_stop_unwind');
            this.debug('stack unwound.');
            // Wait for the async work to complete.
            this.state.result = await this.asyncPromise;
            this.state.continuation = true;
            this.debug('result set starting rewind.');
            // Enable "stack rewinding" code path.
            this.callExport('asyncify_start_rewind', this.asyncifyDataAddr);
            // Call function again to rebuild the stack, and continue where we left off.
            result = this.callExport(name, ...args);
        }
        // Cleanup
        this.state = undefined;
        return result;
    }
    wrapImportFn(fn) {
        return (...args) => {
            if (!this.asyncPromise) {
                // We are in the normal code path. Start the async fetch of data.
                this.asyncPromise = fn(this.state, ...args);
                // Enable "record stack unwinding" code path and return.
                this.callExport('asyncify_start_unwind', this.asyncifyDataAddr);
            }
            else {
                // We are in the stack rewind code path, called once the promise is resolved.
                // Save the result data back to the wasm, disable stack rewind code paths, and return.
                this.callExport('asyncify_stop_rewind');
                const result = fn(this.state, ...args);
                // Cleanup.
                this.asyncPromise = undefined;
                this.state = { continuation: false };
                return result;
            }
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXN5bmNfY2FsbF9zdGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy93YXNtL2FzeW5jX2NhbGxfc3RhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWtCRztBQUNILE1BQU0sT0FBTyxjQUFjO0lBQTNCO1FBQ1UsdUJBQWtCLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQztRQU0vQixVQUFLLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztJQW9FOUIsQ0FBQztJQWxFUSxJQUFJLENBQUMsTUFBMEIsRUFBRSxVQUFzQyxFQUFFLEtBQUssR0FBRyxPQUFPLENBQUMsR0FBRztRQUNqRyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztRQUM3QiwyQ0FBMkM7UUFDM0MsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQzdFLE1BQU0sSUFBSSxHQUFHLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDakQsa0ZBQWtGO1FBQ2xGLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixHQUFHLENBQUMsQ0FBQztRQUM3RCxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQztJQUMzRixDQUFDO0lBRU0sT0FBTztRQUNaLHdCQUF3QjtRQUN4QixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUNuRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVksRUFBRSxHQUFHLElBQVM7UUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsQ0FBQztRQUNyQyxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO1FBRTVDLE9BQU8sSUFBSSxDQUFDLFlBQVksRUFBRTtZQUN4QiwrREFBK0Q7WUFDL0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1lBQ3hDLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztZQUM3Qix1Q0FBdUM7WUFDdkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxDQUFDO1lBQzVDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUMvQixJQUFJLENBQUMsS0FBSyxDQUFDLDZCQUE2QixDQUFDLENBQUM7WUFDMUMsc0NBQXNDO1lBQ3RDLElBQUksQ0FBQyxVQUFVLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDaEUsNEVBQTRFO1lBQzVFLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO1NBQ3pDO1FBRUQsVUFBVTtRQUNWLElBQUksQ0FBQyxLQUFLLEdBQUcsU0FBUyxDQUFDO1FBRXZCLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxZQUFZLENBQUMsRUFBZ0Q7UUFDbEUsT0FBTyxDQUFDLEdBQUcsSUFBVyxFQUFFLEVBQUU7WUFDeEIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQ3RCLGlFQUFpRTtnQkFDakUsSUFBSSxDQUFDLFlBQVksR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDO2dCQUM3Qyx3REFBd0Q7Z0JBQ3hELElBQUksQ0FBQyxVQUFVLENBQUMsdUJBQXVCLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDakU7aUJBQU07Z0JBQ0wsNkVBQTZFO2dCQUM3RSxzRkFBc0Y7Z0JBQ3RGLElBQUksQ0FBQyxVQUFVLENBQUMsc0JBQXNCLENBQUMsQ0FBQztnQkFDeEMsTUFBTSxNQUFNLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztnQkFDeEMsV0FBVztnQkFDWCxJQUFJLENBQUMsWUFBWSxHQUFHLFNBQVMsQ0FBQztnQkFDOUIsSUFBSSxDQUFDLEtBQUssR0FBRyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsQ0FBQztnQkFDckMsT0FBTyxNQUFNLENBQUM7YUFDZjtRQUNILENBQUMsQ0FBQztJQUNKLENBQUM7Q0FDRiJ9
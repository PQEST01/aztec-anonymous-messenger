/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import { EventEmitter } from 'events';
export declare function fetchCode(): Promise<Buffer>;
export declare class BarretenbergWasm extends EventEmitter {
    private store;
    private memory;
    private heap;
    private instance;
    private mutexQ;
    private asyncCallState;
    module: WebAssembly.Module;
    static new(name?: string, initial?: number): Promise<BarretenbergWasm>;
    constructor();
    /**
     * 20 pages by default. 20*2**16 > 1mb stack size plus other overheads.
     * 8192 maximum by default. 512mb.
     */
    init(module?: WebAssembly.Module, initial?: number, maximum?: number): Promise<void>;
    exports(): any;
    /**
     * When returning values from the WASM, use >>> operator to convert signed representation to unsigned representation.
     */
    call(name: string, ...args: any): number;
    /**
     * Uses asyncify to enable async callbacks into js.
     * https://kripken.github.io/blog/wasm/2019/07/16/asyncify.html
     */
    asyncCall(name: string, ...args: any): Promise<number>;
    private getMemory;
    memSize(): number;
    sliceMemory(start: number, end: number): Uint8Array;
    transferToHeap(arr: Uint8Array, offset: number): void;
    /**
     * When calling the wasm, sometimes a caller will require exclusive access over a series of calls.
     * e.g. When a result is written to address 0, one cannot have another caller writing to the same address via
     * transferToHeap before the result is read via sliceMemory.
     * acquire() gets a single token from a fifo. The caller must call release() to add the token back.
     */
    acquire(): Promise<void>;
    release(): void;
    private stringFromAddress;
    private debug;
}
//# sourceMappingURL=barretenberg_wasm.d.ts.map
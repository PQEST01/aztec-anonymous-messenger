/// <reference types="node" resolution-mode="require"/>
import { EthAddress } from '@aztec/barretenberg/address';
import { EthereumProvider, EthereumSignature, SendTxOptions, TxHash, RollupTxs } from '@aztec/barretenberg/blockchain';
import { Block } from '@aztec/barretenberg/block_source';
import { BytesLike, Contract } from 'ethers';
/**
 * Thin wrapper around the rollup processor contract. Provides a direct 1 to 1 interface for
 * querying contract state, creating and sending transactions, and querying for rollup blocks.
 */
export declare class RollupProcessor {
    protected rollupContractAddress: EthAddress;
    private ethereumProvider;
    protected permitHelperAddress: EthAddress;
    static readonly DEFAULT_BRIDGE_GAS_LIMIT = 300000;
    static readonly DEFAULT_ERC20_GAS_LIMIT = 55000;
    private static DEPOSIT_GAS_LIMIT_MULTIPLIER;
    rollupProcessor: Contract;
    permitHelper: Contract;
    private provider;
    private debug;
    constructor(rollupContractAddress: EthAddress, ethereumProvider: EthereumProvider, permitHelperAddress?: EthAddress);
    get address(): EthAddress;
    get contract(): Contract;
    getImplementationVersion(): Promise<any>;
    getDataSize(): Promise<any>;
    escapeBlockLowerBound(): Promise<any>;
    escapeBlockUpperBound(): Promise<any>;
    hasRole(role: BytesLike, address: EthAddress): Promise<any>;
    rollupProviders(providerAddress: EthAddress): Promise<any>;
    paused(): Promise<any>;
    verifier(): Promise<EthAddress>;
    defiBridgeProxy(): Promise<EthAddress>;
    dataSize(): Promise<number>;
    getPendingDefiInteractionHashesLength(): Promise<number>;
    getDefiInteractionHashesLength(): Promise<number>;
    defiInteractionHashes(): Promise<Buffer[]>;
    getAsyncDefiInteractionHashesLength(): Promise<number>;
    asyncDefiInteractionHashes(): Promise<Buffer[]>;
    prevDefiInteractionsHash(): Promise<Buffer>;
    stateHash(): Promise<Buffer>;
    getSupportedBridge(bridgeAddressId: number): Promise<EthAddress>;
    getSupportedBridgesLength(): Promise<any>;
    getSupportedBridges(): Promise<any[]>;
    getBridgeGasLimit(bridgeAddressId: number): Promise<number>;
    getSupportedAsset(assetId: number): Promise<EthAddress>;
    getSupportedAssetsLength(): Promise<any>;
    getAssetGasLimit(assetId: number): Promise<number>;
    getSupportedAssets(): Promise<any[]>;
    pause(options?: SendTxOptions): Promise<TxHash>;
    unpause(options?: SendTxOptions): Promise<TxHash>;
    grantRole(role: BytesLike, address: EthAddress, options?: SendTxOptions): Promise<TxHash>;
    revokeRole(role: BytesLike, address: EthAddress, options?: SendTxOptions): Promise<TxHash>;
    setRollupProvider(providerAddress: EthAddress, valid: boolean, options?: SendTxOptions): Promise<TxHash>;
    setDefiBridgeProxy(providerAddress: EthAddress, options?: SendTxOptions): Promise<TxHash>;
    offchainData(rollupId: bigint, chunk: bigint, totalChunks: bigint, offchainTxData: BytesLike, options?: SendTxOptions): Promise<TxHash>;
    processRollup(encodedProofData: BytesLike, signatures: BytesLike, options?: SendTxOptions): Promise<TxHash>;
    setVerifier(address: EthAddress, options?: SendTxOptions): Promise<TxHash>;
    setThirdPartyContractStatus(flag: boolean, options?: SendTxOptions): Promise<TxHash>;
    setSupportedBridge(bridgeAddress: EthAddress, bridgeGasLimit?: number, options?: SendTxOptions): Promise<TxHash>;
    setSupportedAsset(assetAddress: EthAddress, assetGasLimit?: number, options?: SendTxOptions): Promise<TxHash>;
    processAsyncDefiInteraction(interactionNonce: number, options?: SendTxOptions): Promise<TxHash>;
    getEscapeHatchStatus(): Promise<{
        escapeOpen: boolean;
        blocksRemaining: number;
    }>;
    createRollupProofTx(dataBuf: Buffer, signatures: Buffer[], offchainTxData: Buffer[]): Promise<Buffer>;
    /**
     * The dataBuf argument should be formatted as the rollup broadcast data in encoded form
     * concatenated with the proof data as provided by the root verifier
     * The given offchainTxData is chunked into multiple offchainData txs.
     * Returns the txs to be published.
     */
    createRollupTxs(dataBuf: Buffer, signatures: Buffer[], offchainTxData: Buffer[], txDataLimit: number): Promise<RollupTxs>;
    sendRollupTxs({ rollupProofTx, offchainDataTxs }: {
        rollupProofTx: Buffer;
        offchainDataTxs: Buffer[];
    }, options?: SendTxOptions): Promise<TxHash>;
    sendTx(data: Buffer, options?: SendTxOptions): Promise<TxHash>;
    getTxReceipt(txHash: TxHash): Promise<import("@ethersproject/abstract-provider").TransactionReceipt>;
    depositPendingFunds(assetId: number, amount: bigint, proofHash?: Buffer, options?: SendTxOptions): Promise<TxHash>;
    depositPendingFundsPermit(assetId: number, amount: bigint, deadline: bigint, signature: EthereumSignature, options?: SendTxOptions): Promise<TxHash>;
    depositPendingFundsPermitNonStandard(assetId: number, amount: bigint, nonce: bigint, deadline: bigint, signature: EthereumSignature, options?: SendTxOptions): Promise<TxHash>;
    approveProof(proofHash: Buffer, options?: SendTxOptions): Promise<TxHash>;
    getProofApprovalStatus(address: EthAddress, txId: Buffer): Promise<boolean>;
    getUserPendingDeposit(assetId: number, account: EthAddress): Promise<bigint>;
    getThirdPartyContractStatus(options?: SendTxOptions): Promise<any>;
    private getEarliestBlock;
    private rollupRetrievalChunkSize;
    getRollupBlocksFrom(rollupId: number, minConfirmations: number): Promise<Block[]>;
    /**
     * Emits on the callback, all rollup blocks from (and including) the given rollupId, with >= minConfirmations.
     * This guarantees that all requested rollups have been sent to the callback before it returns.
     *
     * First we locate the desired eth block by querying for the specific given rollupId.
     * It assumes it's querying an eth node that handles queries efficiently (e.g. infura or kebab).
     * Second it queries for all rollups from that block onwards. It chunks requests so that it can start processing
     * rollup events ASAP, and to protect memory usage, but as the node is assumed to be indexed, these chunks can be very
     * large.
     *
     * Processes results on queues. Pipeline is:
     *   eth node rollup event -> event Q -> get rollup metadata from eth node -> metadata Q -> decode data and callback
     *
     * TODO: Introduce chunking and add event Q!
     */
    callbackRollupBlocksFrom(rollupId: number, minConfirmations: number, cb: (block: Block) => Promise<void>): Promise<number | undefined>;
    /**
     * The same as getRollupBlocksFrom, but just search for a specific rollup.
     * If `rollupId == -1` return the latest rollup.
     */
    getRollupBlock(rollupId: number, minConfirmations: number): Promise<Block | undefined>;
    /**
     * Given an array of rollup events, fetches all the necessary data for each event in order to return a Block.
     */
    private getRollupBlocksFromEvents;
    private defiNotesForBlock;
    private rollupMetadataToBlock;
    private extractDefiHashesFromRollupEvent;
    private getDefiBridgeEventsForRollupEvents;
    private getOffchainDataEvents;
    private decodeBlock;
    getContractWithSigner(options: SendTxOptions): Contract;
    getHelperContractWithSigner(options: SendTxOptions): Contract;
    estimateGas(data: Buffer): Promise<number>;
    getRevertError(txHash: TxHash): Promise<import("@aztec/barretenberg/blockchain").RevertError | undefined>;
}
//# sourceMappingURL=rollup_processor.d.ts.map
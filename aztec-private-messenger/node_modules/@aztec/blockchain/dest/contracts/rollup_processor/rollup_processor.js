import { EthAddress } from '@aztec/barretenberg/address';
import { TxHash, EthereumRpc, } from '@aztec/barretenberg/blockchain';
import { Block } from '@aztec/barretenberg/block_source';
import { BridgeCallData } from '@aztec/barretenberg/bridge_call_data';
import { computeInteractionHashes } from '@aztec/barretenberg/note_algorithms';
import { Timer } from '@aztec/barretenberg/timer';
import { sliceOffchainTxData } from '@aztec/barretenberg/offchain_tx_data';
import { RollupProofData } from '@aztec/barretenberg/rollup_proof';
import { Web3Provider } from '@ethersproject/providers';
import createDebug from 'debug';
import { Contract, utils } from 'ethers';
import { RollupProcessorV2 as RollupProcessorAbi, PermitHelper } from '../../abis.js';
import { decodeErrorFromContract, decodeErrorFromContractByTxHash } from '../decode_error.js';
import { DefiInteractionEvent } from '@aztec/barretenberg/block_source';
import { solidityFormatSignatures } from './solidity_format_signatures.js';
import { getEarliestBlock } from '../../earliest_block/index.js';
import { MemoryFifo, Semaphore } from '@aztec/barretenberg/fifo';
const fixEthersStackTrace = (err) => {
    err.stack += new Error().stack;
    throw err;
};
/**
 * Thin wrapper around the rollup processor contract. Provides a direct 1 to 1 interface for
 * querying contract state, creating and sending transactions, and querying for rollup blocks.
 */
export class RollupProcessor {
    constructor(rollupContractAddress, ethereumProvider, permitHelperAddress = EthAddress.ZERO) {
        this.rollupContractAddress = rollupContractAddress;
        this.ethereumProvider = ethereumProvider;
        this.permitHelperAddress = permitHelperAddress;
        this.debug = createDebug('bb:rollup_processor');
        this.rollupRetrievalChunkSize = () => 100000;
        this.provider = new Web3Provider(ethereumProvider);
        this.rollupProcessor = new Contract(rollupContractAddress.toString(), RollupProcessorAbi.abi, this.provider);
        this.permitHelper = new Contract(permitHelperAddress.toString(), PermitHelper.abi, this.provider);
    }
    get address() {
        return this.rollupContractAddress;
    }
    get contract() {
        return this.rollupProcessor;
    }
    async getImplementationVersion() {
        return await this.rollupProcessor.getImplementationVersion();
    }
    async getDataSize() {
        return (await this.rollupProcessor.getDataSize()).toNumber();
    }
    async escapeBlockLowerBound() {
        return (await this.rollupProcessor.escapeBlockLowerBound()).toBigInt();
    }
    async escapeBlockUpperBound() {
        return (await this.rollupProcessor.escapeBlockUpperBound()).toBigInt();
    }
    async hasRole(role, address) {
        return await this.rollupProcessor.hasRole(role, address.toString());
    }
    async rollupProviders(providerAddress) {
        return await this.rollupProcessor.rollupProviders(providerAddress.toString());
    }
    async paused() {
        return await this.rollupProcessor.paused();
    }
    async verifier() {
        return EthAddress.fromString(await this.rollupProcessor.verifier());
    }
    async defiBridgeProxy() {
        return EthAddress.fromString(await this.rollupProcessor.defiBridgeProxy());
    }
    async dataSize() {
        return +(await this.rollupProcessor.getDataSize());
    }
    async getPendingDefiInteractionHashesLength() {
        return +(await this.rollupProcessor.getPendingDefiInteractionHashesLength());
    }
    async getDefiInteractionHashesLength() {
        return +(await this.rollupProcessor.getDefiInteractionHashesLength());
    }
    async defiInteractionHashes() {
        const length = await this.getDefiInteractionHashesLength();
        const res = [];
        for (let i = 0; i < length; i++) {
            res.push((await this.rollupProcessor.defiInteractionHashes(i)));
        }
        return res.map(v => Buffer.from(v.slice(2), 'hex'));
    }
    async getAsyncDefiInteractionHashesLength() {
        return +(await this.rollupProcessor.getAsyncDefiInteractionHashesLength());
    }
    async asyncDefiInteractionHashes() {
        const length = await this.getAsyncDefiInteractionHashesLength();
        const res = [];
        for (let i = 0; i < length; i++) {
            res.push((await this.rollupProcessor.asyncDefiInteractionHashes(i)));
        }
        return res.map(v => Buffer.from(v.slice(2), 'hex'));
    }
    async prevDefiInteractionsHash() {
        return Buffer.from((await this.rollupProcessor.prevDefiInteractionsHash()).slice(2), 'hex');
    }
    async stateHash() {
        return Buffer.from((await this.rollupProcessor.rollupStateHash()).slice(2), 'hex');
    }
    async getSupportedBridge(bridgeAddressId) {
        return EthAddress.fromString(await this.rollupProcessor.getSupportedBridge(bridgeAddressId));
    }
    async getSupportedBridgesLength() {
        return (await this.rollupProcessor.getSupportedBridgesLength()).toNumber();
    }
    async getSupportedBridges() {
        const length = await this.getSupportedBridgesLength();
        const bridges = [];
        for (let i = 1; i <= length; i++) {
            bridges.push({
                id: i,
                address: await this.getSupportedBridge(i),
                gasLimit: await this.getBridgeGasLimit(i),
            });
        }
        return bridges;
    }
    async getBridgeGasLimit(bridgeAddressId) {
        return +(await this.rollupProcessor.bridgeGasLimits(bridgeAddressId));
    }
    async getSupportedAsset(assetId) {
        return EthAddress.fromString(await this.rollupProcessor.getSupportedAsset(assetId));
    }
    async getSupportedAssetsLength() {
        return (await this.rollupProcessor.getSupportedAssetsLength()).toNumber();
    }
    async getAssetGasLimit(assetId) {
        return +(await this.rollupProcessor.assetGasLimits(assetId));
    }
    async getSupportedAssets() {
        const length = await this.getSupportedAssetsLength();
        const assets = [];
        for (let i = 1; i <= length; i++) {
            assets.push({
                address: await this.getSupportedAsset(i),
                gasLimit: await this.getAssetGasLimit(i),
            });
        }
        return assets;
    }
    async pause(options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.pause({ gasLimit }).catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async unpause(options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.unpause({ gasLimit }).catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async grantRole(role, address, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.grantRole(role, address.toString(), { gasLimit });
        return TxHash.fromString(tx.hash);
    }
    async revokeRole(role, address, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.revokeRole(role, address.toString(), { gasLimit });
        return TxHash.fromString(tx.hash);
    }
    async setRollupProvider(providerAddress, valid, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor
            .setRollupProvider(providerAddress.toString(), valid, { gasLimit })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async setDefiBridgeProxy(providerAddress, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor
            .setDefiBridgeProxy(providerAddress.toString(), { gasLimit })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async offchainData(rollupId, chunk, totalChunks, offchainTxData, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor
            .offchainData(rollupId, chunk, totalChunks, offchainTxData, { gasLimit })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async processRollup(encodedProofData, signatures, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor
            .processRollup(encodedProofData, signatures, { gasLimit })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async setVerifier(address, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.setVerifier(address.toString(), { gasLimit }).catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async setThirdPartyContractStatus(flag, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.setAllowThirdPartyContracts(flag, { gasLimit });
        return TxHash.fromString(tx.hash);
    }
    async setSupportedBridge(bridgeAddress, bridgeGasLimit = 0, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.setSupportedBridge(bridgeAddress.toString(), bridgeGasLimit, { gasLimit });
        return TxHash.fromString(tx.hash);
    }
    async setSupportedAsset(assetAddress, assetGasLimit = 0, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.setSupportedAsset(assetAddress.toString(), assetGasLimit, {
            gasLimit,
        });
        return TxHash.fromString(tx.hash);
    }
    async processAsyncDefiInteraction(interactionNonce, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor
            .processAsyncDefiInteraction(interactionNonce, { gasLimit })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async getEscapeHatchStatus() {
        const [escapeOpen, blocksRemaining] = await this.rollupProcessor.getEscapeHatchStatus();
        return { escapeOpen, blocksRemaining: +blocksRemaining };
    }
    // Deprecated: Used by lots of tests. We now use createRollupTxs() to produce two txs, one with broadcast data,
    // the other with the actual rollup proof.
    async createRollupProofTx(dataBuf, signatures, offchainTxData) {
        // setting the tx call data limit to 120kb as this function is only used by tests
        return (await this.createRollupTxs(dataBuf, signatures, offchainTxData, 120 * 1024)).rollupProofTx;
    }
    /**
     * The dataBuf argument should be formatted as the rollup broadcast data in encoded form
     * concatenated with the proof data as provided by the root verifier
     * The given offchainTxData is chunked into multiple offchainData txs.
     * Returns the txs to be published.
     */
    async createRollupTxs(dataBuf, signatures, offchainTxData, txDataLimit) {
        const broadcastData = RollupProofData.decode(dataBuf);
        const formattedSignatures = solidityFormatSignatures(signatures);
        const rollupProofTxRaw = await this.rollupProcessor.populateTransaction
            .processRollup(dataBuf, formattedSignatures)
            .catch(fixEthersStackTrace);
        const rollupProofTx = Buffer.from(rollupProofTxRaw.data.slice(2), 'hex');
        const ocData = Buffer.concat(offchainTxData);
        const chunks = Math.ceil(ocData.length / txDataLimit);
        // We should always publish at least 1 chunk, even if it's 0 length.
        // We want the log event to be emitted so we can can be sure things are working as intended.
        const ocdChunks = chunks
            ? Array.from({ length: chunks }).map((_, i) => ocData.slice(i * txDataLimit, (i + 1) * txDataLimit))
            : [Buffer.alloc(0)];
        const offchainDataTxsRaw = await Promise.all(ocdChunks.map((c, i) => this.rollupProcessor.populateTransaction.offchainData(broadcastData.rollupId, i, ocdChunks.length, c))).catch(fixEthersStackTrace);
        const offchainDataTxs = offchainDataTxsRaw.map(tx => Buffer.from(tx.data.slice(2), 'hex'));
        const result = {
            rollupProofTx,
            offchainDataTxs,
        };
        return result;
    }
    async sendRollupTxs({ rollupProofTx, offchainDataTxs }, options = {}) {
        for (const tx of offchainDataTxs) {
            await this.sendTx(tx);
        }
        return await this.sendTx(rollupProofTx, options);
    }
    async sendTx(data, options = {}) {
        const { signingAddress, gasLimit, nonce, maxFeePerGas, maxPriorityFeePerGas } = options;
        const signer = signingAddress ? this.provider.getSigner(signingAddress.toString()) : this.provider.getSigner(0);
        const from = await signer.getAddress();
        const txRequest = {
            to: this.rollupContractAddress.toString(),
            from,
            gasLimit,
            data,
            nonce,
            maxFeePerGas,
            maxPriorityFeePerGas,
        };
        const txResponse = await signer.sendTransaction(txRequest).catch(fixEthersStackTrace);
        return TxHash.fromString(txResponse.hash);
    }
    async getTxReceipt(txHash) {
        const txReceipt = await this.provider.waitForTransaction(txHash.toString());
        if (!txReceipt) {
            throw new Error('Tx receipt not found');
        }
        return txReceipt;
    }
    async depositPendingFunds(assetId, amount, proofHash = Buffer.alloc(32), options = {}) {
        let { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const depositor = await rollupProcessor.signer.getAddress();
        const value = assetId === 0 ? amount : undefined;
        // note: Due to non deterministic gas estimations provided in depositPendingFunds, we add 10% to the total
        // transaction fee to cover the cost of all execution branches.
        // Non determinism is cause by user's individually calculating the new deposit limit, where the previous update
        // determines the path of the next user's execution.
        if (!gasLimit) {
            const estimation = await rollupProcessor.estimateGas
                .depositPendingFunds(assetId, amount, depositor, proofHash, {
                value,
            })
                .catch(fixEthersStackTrace);
            gasLimit = Math.ceil(estimation.toNumber() * RollupProcessor.DEPOSIT_GAS_LIMIT_MULTIPLIER);
        }
        const tx = await rollupProcessor
            .depositPendingFunds(assetId, amount, depositor, proofHash, {
            value,
            gasLimit,
        })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async depositPendingFundsPermit(assetId, amount, deadline, signature, options = {}) {
        let { gasLimit } = options;
        const permitHelper = this.getHelperContractWithSigner(options);
        const depositor = await permitHelper.signer.getAddress();
        // Deposit actions have non-deterministic gas consumption - see note in `depositPendingFunds`
        if (!gasLimit) {
            const estimation = await permitHelper.estimateGas
                .depositPendingFundsPermit(assetId, amount, depositor, deadline, signature.v, signature.r, signature.s)
                .catch(fixEthersStackTrace);
            gasLimit = Math.ceil(estimation.toNumber() * RollupProcessor.DEPOSIT_GAS_LIMIT_MULTIPLIER);
        }
        const tx = await permitHelper
            .depositPendingFundsPermit(assetId, amount, depositor, deadline, signature.v, signature.r, signature.s, {
            gasLimit,
        })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async depositPendingFundsPermitNonStandard(assetId, amount, nonce, deadline, signature, options = {}) {
        let { gasLimit } = options;
        const permitHelper = this.getHelperContractWithSigner(options);
        const depositor = await permitHelper.signer.getAddress();
        // Deposit actions have non-deterministic gas consumption - see note in `depositPendingFunds`
        if (!gasLimit) {
            const estimation = await permitHelper.estimateGas
                .depositPendingFundsPermitNonStandard(assetId, amount, depositor, nonce, deadline, signature.v, signature.r, signature.s)
                .catch(fixEthersStackTrace);
            gasLimit = Math.ceil(estimation.toNumber() * RollupProcessor.DEPOSIT_GAS_LIMIT_MULTIPLIER);
        }
        const tx = await permitHelper
            .depositPendingFundsPermitNonStandard(assetId, amount, depositor, nonce, deadline, signature.v, signature.r, signature.s, { gasLimit })
            .catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async approveProof(proofHash, options = {}) {
        const { gasLimit } = options;
        const rollupProcessor = this.getContractWithSigner(options);
        const tx = await rollupProcessor.approveProof(proofHash, { gasLimit }).catch(fixEthersStackTrace);
        return TxHash.fromString(tx.hash);
    }
    async getProofApprovalStatus(address, txId) {
        return await this.rollupProcessor.depositProofApprovals(address.toString(), txId);
    }
    async getUserPendingDeposit(assetId, account) {
        return BigInt(await this.rollupProcessor.userPendingDeposits(assetId, account.toString()));
    }
    async getThirdPartyContractStatus(options = {}) {
        const { gasLimit } = options;
        return await this.rollupProcessor.allowThirdPartyContracts({ gasLimit });
    }
    async getEarliestBlock() {
        const net = await this.provider.getNetwork();
        return getEarliestBlock(net.chainId);
    }
    async getRollupBlocksFrom(rollupId, minConfirmations) {
        const blocks = [];
        await this.callbackRollupBlocksFrom(rollupId, minConfirmations, block => Promise.resolve(void blocks.push(block)));
        return blocks;
    }
    /**
     * Emits on the callback, all rollup blocks from (and including) the given rollupId, with >= minConfirmations.
     * This guarantees that all requested rollups have been sent to the callback before it returns.
     *
     * First we locate the desired eth block by querying for the specific given rollupId.
     * It assumes it's querying an eth node that handles queries efficiently (e.g. infura or kebab).
     * Second it queries for all rollups from that block onwards. It chunks requests so that it can start processing
     * rollup events ASAP, and to protect memory usage, but as the node is assumed to be indexed, these chunks can be very
     * large.
     *
     * Processes results on queues. Pipeline is:
     *   eth node rollup event -> event Q -> get rollup metadata from eth node -> metadata Q -> decode data and callback
     *
     * TODO: Introduce chunking and add event Q!
     */
    async callbackRollupBlocksFrom(rollupId, minConfirmations, cb) {
        const specificRollupFilter = this.rollupProcessor.filters.RollupProcessed(rollupId);
        const e = await this.rollupProcessor.queryFilter(specificRollupFilter);
        if (!e.length) {
            this.debug(`no rollup with id ${rollupId} found. early out.`);
            return;
        }
        const start = e[0].blockNumber;
        this.debug(`fetching rollup events from block ${start}...`);
        const rollupFilter = this.rollupProcessor.filters.RollupProcessed();
        const timer = new Timer();
        const allEvents = await this.rollupProcessor.queryFilter(rollupFilter, start);
        this.debug(`${allEvents.length} fetched in ${timer.s()}s`);
        const currentBlockNumber = await new EthereumRpc(this.ethereumProvider).blockNumber();
        const events = allEvents
            .filter(e => currentBlockNumber - e.blockNumber + 1 >= minConfirmations)
            .filter(e => e.args.rollupId.toNumber() >= rollupId);
        if (events.length) {
            const processStartTime = new Timer();
            await this.getRollupBlocksFromEvents(events, cb);
            this.debug(`processing complete in ${processStartTime.s()}s`);
        }
        else {
            this.debug(`no events of interest, doing nothing.`);
        }
        return events.length;
    }
    /**
     * The same as getRollupBlocksFrom, but just search for a specific rollup.
     * If `rollupId == -1` return the latest rollup.
     */
    async getRollupBlock(rollupId, minConfirmations) {
        const currentBlockNumber = await new EthereumRpc(this.ethereumProvider).blockNumber();
        const findLatestBlock = async () => {
            const { earliestBlock } = await this.getEarliestBlock();
            const latestBlock = await this.provider.getBlockNumber();
            const rollupChunkSize = this.rollupRetrievalChunkSize();
            // look backwards to find the latest rollup, then stop
            let end = latestBlock;
            let start = Math.max(end - rollupChunkSize, earliestBlock);
            let block;
            while (end > earliestBlock && !block) {
                this.debug(`fetching rollup events between blocks ${start} and ${end}...`);
                const rollupFilter = this.rollupProcessor.filters.RollupProcessed();
                const allEvents = await this.rollupProcessor.queryFilter(rollupFilter, start, end);
                const events = allEvents.filter(e => currentBlockNumber - e.blockNumber + 1 >= minConfirmations);
                for (let i = events.length - 1; i >= 0 && !block; i--) {
                    await this.getRollupBlocksFromEvents([events[i]], b => Promise.resolve(void (block = b)));
                }
                end = Math.max(start - 1, earliestBlock);
                start = Math.max(end - rollupChunkSize, earliestBlock);
            }
            return block;
        };
        const findSpecificBlock = async () => {
            const specificRollupFilter = this.rollupProcessor.filters.RollupProcessed(rollupId);
            const allEvents = await this.rollupProcessor.queryFilter(specificRollupFilter);
            const events = allEvents.filter(e => currentBlockNumber - e.blockNumber + 1 >= minConfirmations);
            if (!events.length) {
                return;
            }
            let block;
            await this.getRollupBlocksFromEvents(events, b => Promise.resolve(void (block = b)));
            return block;
        };
        if (rollupId == -1) {
            return await findLatestBlock();
        }
        return await findSpecificBlock();
    }
    /**
     * Given an array of rollup events, fetches all the necessary data for each event in order to return a Block.
     */
    async getRollupBlocksFromEvents(rollupEvents, cb) {
        if (rollupEvents.length === 0) {
            return [];
        }
        this.debug(`fetching data for ${rollupEvents.length} rollups...`);
        const defiBridgeEventsTimer = new Timer();
        const allDefiNotes = await this.getDefiBridgeEventsForRollupEvents(rollupEvents);
        this.debug(`defi bridge events fetched in ${defiBridgeEventsTimer.s()}s.`);
        const offchainEventsTimer = new Timer();
        const allOffchainDataEvents = await this.getOffchainDataEvents(rollupEvents);
        this.debug(`offchain data events fetched in ${offchainEventsTimer.s()}s.`);
        // if any rollup's off-chain events are not present we need to exclude that rollup and any further rollups
        const firstInvalidOffchainDataIndex = allOffchainDataEvents.findIndex(x => !x.length);
        if (firstInvalidOffchainDataIndex != -1) {
            rollupEvents.splice(firstInvalidOffchainDataIndex);
        }
        // We want to concurrently perform network io and processing of results, but retain ordered output.
        // We create a tiny data pipeline to queue output of network IO for ordered processing.
        const processQueue = new MemoryFifo();
        // We use use a semaphore to protect two resources:
        //   1. Geth (suckware), can handle around 20 rollups worth of metadata requests before "bad thinhs happen".
        //   2. Our own internal queue of network IO results.
        // TODO: Kebab should be indexing the requested data so we don't have to worry about the eth node!
        // We could then raise this number higher than 20, at which point it's only acting to protect against balooning
        // the processQueue and consuming lots of memory, when the consumer is slow.
        const queueSemaphore = new Semaphore(20);
        // If we encounter a block that does not have it's full compliment of defi notes then we will
        // need to stop the pipeline from publishing that block and any further blocks
        let stop = false;
        // Start processing results of IO.
        const processPromise = processQueue.process(async ({ event, metaPromise }) => {
            try {
                if (stop) {
                    return;
                }
                const meta = await metaPromise;
                const rollupMetadata = {
                    event,
                    tx: meta[0],
                    block: meta[1],
                    receipt: meta[2],
                    offchainDataTxs: meta[3],
                    offchainDataReceipts: meta[4],
                };
                const defiNotesForRollup = this.defiNotesForBlock(rollupMetadata, allDefiNotes);
                await cb(this.rollupMetadataToBlock(rollupMetadata, defiNotesForRollup));
            }
            catch (err) {
                stop = true;
                console.log(err);
            }
            finally {
                queueSemaphore.release();
            }
        });
        // Kick off io.
        for (let i = 0; i < rollupEvents.length && !stop; ++i) {
            await queueSemaphore.acquire();
            const event = rollupEvents[i];
            const offchainData = allOffchainDataEvents[i];
            this.debug(`fetching metadata for rollup ${event.args?.rollupId}.`);
            const metaPromise = Promise.all([
                event.getTransaction(),
                event.getBlock(),
                event.getTransactionReceipt(),
                Promise.all(offchainData.map(e => e.getTransaction())),
                Promise.all(offchainData.map(e => e.getTransactionReceipt())),
            ]);
            processQueue.put({ event, metaPromise });
        }
        processQueue.end();
        await processPromise;
    }
    defiNotesForBlock(meta, allDefiNotes) {
        // we now have the tx details and defi notes for this batch of rollup events
        // we need to assign the defi notes to their specified rollup
        // assign the set of defi notes for this rollup and decode the block
        const hashesForThisRollup = this.extractDefiHashesFromRollupEvent(meta.event);
        const defiNotesForThisRollup = [];
        for (const hash of hashesForThisRollup) {
            if (!allDefiNotes[hash]) {
                throw new Error(`Unable to locate defi interaction note for hash ${hash} in rollup ${meta.event.args?.rollupId}!`);
            }
            defiNotesForThisRollup.push(allDefiNotes[hash]);
        }
        return defiNotesForThisRollup;
    }
    rollupMetadataToBlock(meta, defiNotesForThisRollup) {
        const block = this.decodeBlock({ ...meta.tx, timestamp: meta.block.timestamp }, meta.receipt, defiNotesForThisRollup, meta.offchainDataTxs, meta.offchainDataReceipts);
        return block;
    }
    extractDefiHashesFromRollupEvent(rollupEvent) {
        // the rollup contract publishes a set of hash values with each rollup event
        const rollupLog = { blockNumber: rollupEvent.blockNumber, topics: rollupEvent.topics, data: rollupEvent.data };
        const { args: { nextExpectedDefiHashes }, } = this.contract.interface.parseLog(rollupLog);
        return nextExpectedDefiHashes.map((hash) => hash.slice(2));
    }
    async getDefiBridgeEventsForRollupEvents(rollupEvents) {
        // retrieve all defi interaction notes from the DefiBridgeProcessed stream for the set of rollup events given
        const rollupHashes = rollupEvents.flatMap(ev => this.extractDefiHashesFromRollupEvent(ev));
        const hashMapping = {};
        for (const hash of rollupHashes) {
            hashMapping[hash] = undefined;
        }
        let numHashesToFind = rollupHashes.length;
        // hashMapping now contains all of the required note hashes in it's keys
        // we need to search back through the DefiBridgeProcessed stream and find all of the notes that correspond to that stream
        const { earliestBlock, chunk } = await this.getEarliestBlock();
        // the highest block number should be the event at the end, but calculate the max to be sure
        const highestBlockNumber = Math.max(...rollupEvents.map(ev => ev.blockNumber));
        let endBlock = Math.max(highestBlockNumber, earliestBlock);
        let startBlock = Math.max(endBlock - chunk, earliestBlock);
        // search back through the stream until all of our notes have been found or we have exhausted the blocks
        while (endBlock > earliestBlock && numHashesToFind > 0) {
            this.debug(`searching for defi notes from blocks ${startBlock} - ${endBlock}`);
            const filter = this.rollupProcessor.filters.DefiBridgeProcessed();
            const defiBridgeEvents = await this.rollupProcessor.queryFilter(filter, startBlock, endBlock);
            // decode the retrieved events into actual defi interaction notes
            const decodedEvents = defiBridgeEvents.map((log) => {
                const { args: { encodedBridgeCallData, nonce, totalInputValue, totalOutputValueA, totalOutputValueB, result, errorReason, }, } = this.contract.interface.parseLog(log);
                return new DefiInteractionEvent(BridgeCallData.fromBigInt(BigInt(encodedBridgeCallData)), +nonce, BigInt(totalInputValue), BigInt(totalOutputValueA), BigInt(totalOutputValueB), result, Buffer.from(errorReason.slice(2), 'hex'));
            });
            this.debug(`found ${decodedEvents.length} notes between blocks ${startBlock} - ${endBlock}`);
            // compute the hash and store the notes against that hash in our mapping
            for (const decodedNote of decodedEvents) {
                const noteHash = computeInteractionHashes([decodedNote])[0].toString('hex');
                if (Object.prototype.hasOwnProperty.call(hashMapping, noteHash) && hashMapping[noteHash] === undefined) {
                    hashMapping[noteHash] = decodedNote;
                    --numHashesToFind;
                }
            }
            endBlock = Math.max(startBlock - 1, earliestBlock);
            startBlock = Math.max(endBlock - chunk, earliestBlock);
        }
        return hashMapping;
    }
    async getOffchainDataEvents(rollupEvents) {
        const rollupLogs = rollupEvents.map(e => this.contract.interface.parseLog(e));
        // If we only have one rollup event, use the rollup id as a filter.
        const filter = this.rollupProcessor.filters.OffchainData(rollupLogs.length === 1 ? rollupLogs[0].args.rollupId : undefined);
        // Search from 1 days worth of blocks before, up to the last rollup block.
        const { offchainSearchLead } = await this.getEarliestBlock();
        const start = rollupEvents[0].blockNumber - offchainSearchLead;
        const end = rollupEvents[rollupEvents.length - 1].blockNumber;
        this.debug(`fetching offchain data events from blocks ${start} - ${end}...`);
        const offchainEvents = await this.rollupProcessor.queryFilter(filter, rollupEvents[0].blockNumber - offchainSearchLead, rollupEvents[rollupEvents.length - 1].blockNumber);
        this.debug(`found ${offchainEvents.length} offchain events.`);
        // Key the offchain data event on the rollup id and sender.
        const offchainEventMap = offchainEvents.reduce((a, e) => {
            const offChainLog = this.contract.interface.parseLog(e);
            const { args: { rollupId, chunk, totalChunks, sender }, } = offChainLog;
            // if the rollup event occurs before the offchain event, then ignore the off chain event
            const rollupLogIndex = rollupLogs.findIndex(x => x.args.rollupId.toNumber() === rollupId.toNumber());
            if (rollupLogIndex !== -1) {
                const rollupEvent = rollupEvents[rollupLogIndex];
                if (rollupEvent.blockNumber < e.blockNumber) {
                    this.debug(`ignoring offchain event at block ${e.blockNumber} for rollup ${rollupId} at block ${rollupEvent.blockNumber}`);
                    return a;
                }
            }
            const key = `${rollupId}:${sender}`;
            if (!a[key] || a[key].length != totalChunks) {
                a[key] = Array.from({ length: totalChunks });
            }
            // Store by chunk index. Copes with chunks being re-published.
            a[key][chunk] = e;
            this.debug(`parsed offchain event for rollup: ${rollupId} sender: ${sender} chunk: ${chunk}.`);
            return a;
        }, {});
        // Finally, for each rollup log, lookup the offchain events for the rollup id from the same sender.
        return rollupLogs.map(rollupLog => {
            const { args: { rollupId, sender }, } = rollupLog;
            const key = `${rollupId}:${sender}`;
            const offchainEvents = offchainEventMap[key];
            if (!offchainEvents || offchainEvents.some(e => !e)) {
                console.log(`Missing offchain data chunks for rollup: ${rollupId}`);
                return [];
            }
            return offchainEvents;
        });
    }
    decodeBlock(rollupTx, receipt, interactionResult, offchainDataTxs, offchainDataReceipts) {
        const rollupAbi = new utils.Interface(RollupProcessorAbi.abi);
        const parsedRollupTx = rollupAbi.parseTransaction({ data: rollupTx.data });
        const offchainTxDataBuf = Buffer.concat(offchainDataTxs
            .map(tx => rollupAbi.parseTransaction({ data: tx.data }))
            .map(parsed => Buffer.from(parsed.args[3].slice(2), 'hex')));
        const [proofData] = parsedRollupTx.args;
        const encodedProofBuffer = Buffer.from(proofData.slice(2), 'hex');
        const rollupProofData = RollupProofData.decode(encodedProofBuffer);
        const validProofIds = rollupProofData.getNonPaddingProofIds();
        const offchainTxData = sliceOffchainTxData(validProofIds, offchainTxDataBuf);
        this.debug(`decoded rollup ${rollupProofData.rollupId}`);
        return new Block(TxHash.fromString(rollupTx.hash), new Date(rollupTx.timestamp * 1000), rollupProofData.rollupId, rollupProofData.rollupSize, encodedProofBuffer, offchainTxData, interactionResult, receipt.gasUsed.toNumber() + offchainDataReceipts.reduce((a, r) => a + r.gasUsed.toNumber(), 0), BigInt(rollupTx.gasPrice.toString()));
    }
    getContractWithSigner(options) {
        const { signingAddress } = options;
        const provider = options.provider ? new Web3Provider(options.provider) : this.provider;
        const ethSigner = provider.getSigner(signingAddress ? signingAddress.toString() : 0);
        return new Contract(this.rollupContractAddress.toString(), RollupProcessorAbi.abi, ethSigner);
    }
    getHelperContractWithSigner(options) {
        const { signingAddress } = options;
        const provider = options.provider ? new Web3Provider(options.provider) : this.provider;
        const ethSigner = provider.getSigner(signingAddress ? signingAddress.toString() : 0);
        return new Contract(this.permitHelperAddress.toString(), PermitHelper.abi, ethSigner);
    }
    async estimateGas(data) {
        const signer = this.provider.getSigner(0);
        const from = await signer.getAddress();
        const txRequest = {
            to: this.address.toString(),
            from,
            data: `0x${data.toString('hex')}`,
        };
        try {
            const estimate = await this.provider.estimateGas(txRequest);
            return estimate.toNumber();
        }
        catch (err) {
            const rep = await this.ethereumProvider
                .request({ method: 'eth_call', params: [txRequest, 'latest'] })
                .catch(err => err);
            if (rep.data) {
                const revertError = decodeErrorFromContract(this.contract, rep.data);
                if (revertError) {
                    const message = `${revertError.name}(${revertError.params.join(', ')})`;
                    throw new Error(message);
                }
            }
            throw err;
        }
    }
    async getRevertError(txHash) {
        return await decodeErrorFromContractByTxHash(this.contract, txHash, this.ethereumProvider);
    }
}
RollupProcessor.DEFAULT_BRIDGE_GAS_LIMIT = 300000;
RollupProcessor.DEFAULT_ERC20_GAS_LIMIT = 55000;
RollupProcessor.DEPOSIT_GAS_LIMIT_MULTIPLIER = 1.1;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm9sbHVwX3Byb2Nlc3Nvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb250cmFjdHMvcm9sbHVwX3Byb2Nlc3Nvci9yb2xsdXBfcHJvY2Vzc29yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN6RCxPQUFPLEVBSUwsTUFBTSxFQUVOLFdBQVcsR0FDWixNQUFNLGdDQUFnQyxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUN6RCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDdEUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDL0UsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ2xELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQzNFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQU9uRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDeEQsT0FBTyxXQUFXLE1BQU0sT0FBTyxDQUFDO0FBQ2hDLE9BQU8sRUFBYSxRQUFRLEVBQVMsS0FBSyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQzNELE9BQU8sRUFBRSxpQkFBaUIsSUFBSSxrQkFBa0IsRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDdEYsT0FBTyxFQUFFLHVCQUF1QixFQUFFLCtCQUErQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDOUYsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sa0NBQWtDLENBQUM7QUFDeEUsT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0UsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDakUsT0FBTyxFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUVqRSxNQUFNLG1CQUFtQixHQUFHLENBQUMsR0FBVSxFQUFFLEVBQUU7SUFDekMsR0FBRyxDQUFDLEtBQU0sSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDLEtBQUssQ0FBQztJQUNoQyxNQUFNLEdBQUcsQ0FBQztBQUNaLENBQUMsQ0FBQztBQVdGOzs7R0FHRztBQUNILE1BQU0sT0FBTyxlQUFlO0lBVzFCLFlBQ1kscUJBQWlDLEVBQ25DLGdCQUFrQyxFQUNoQyxzQkFBa0MsVUFBVSxDQUFDLElBQUk7UUFGakQsMEJBQXFCLEdBQXJCLHFCQUFxQixDQUFZO1FBQ25DLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDaEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUE4QjtRQUxyRCxVQUFLLEdBQUcsV0FBVyxDQUFDLHFCQUFxQixDQUFDLENBQUM7UUEwZDNDLDZCQUF3QixHQUFHLEdBQUcsRUFBRSxDQUFDLE1BQU0sQ0FBQztRQW5kOUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQ25ELElBQUksQ0FBQyxlQUFlLEdBQUcsSUFBSSxRQUFRLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFLEVBQUUsa0JBQWtCLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUM3RyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksUUFBUSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsRUFBRSxFQUFFLFlBQVksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3BHLENBQUM7SUFFRCxJQUFJLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FBQztJQUNwQyxDQUFDO0lBRUQsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDO0lBQzlCLENBQUM7SUFFRCxLQUFLLENBQUMsd0JBQXdCO1FBQzVCLE9BQU8sTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLHdCQUF3QixFQUFFLENBQUM7SUFDL0QsQ0FBQztJQUVELEtBQUssQ0FBQyxXQUFXO1FBQ2YsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQy9ELENBQUM7SUFFRCxLQUFLLENBQUMscUJBQXFCO1FBQ3pCLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3pFLENBQUM7SUFFRCxLQUFLLENBQUMscUJBQXFCO1FBQ3pCLE9BQU8sQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3pFLENBQUM7SUFFRCxLQUFLLENBQUMsT0FBTyxDQUFDLElBQWUsRUFBRSxPQUFtQjtRQUNoRCxPQUFPLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQ3RFLENBQUM7SUFFRCxLQUFLLENBQUMsZUFBZSxDQUFDLGVBQTJCO1FBQy9DLE9BQU8sTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUNoRixDQUFDO0lBRUQsS0FBSyxDQUFDLE1BQU07UUFDVixPQUFPLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUM3QyxDQUFDO0lBRUQsS0FBSyxDQUFDLFFBQVE7UUFDWixPQUFPLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7SUFDdEUsQ0FBQztJQUVELEtBQUssQ0FBQyxlQUFlO1FBQ25CLE9BQU8sVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsZUFBZSxFQUFFLENBQUMsQ0FBQztJQUM3RSxDQUFDO0lBRUQsS0FBSyxDQUFDLFFBQVE7UUFDWixPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUNyRCxDQUFDO0lBRUQsS0FBSyxDQUFDLHFDQUFxQztRQUN6QyxPQUFPLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMscUNBQXFDLEVBQUUsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFRCxLQUFLLENBQUMsOEJBQThCO1FBQ2xDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyw4QkFBOEIsRUFBRSxDQUFDLENBQUM7SUFDeEUsQ0FBQztJQUVELEtBQUssQ0FBQyxxQkFBcUI7UUFDekIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsOEJBQThCLEVBQUUsQ0FBQztRQUMzRCxNQUFNLEdBQUcsR0FBYSxFQUFFLENBQUM7UUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMvQixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUFXLENBQUMsQ0FBQztTQUMzRTtRQUNELE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRCxLQUFLLENBQUMsbUNBQW1DO1FBQ3ZDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxtQ0FBbUMsRUFBRSxDQUFDLENBQUM7SUFDN0UsQ0FBQztJQUVELEtBQUssQ0FBQywwQkFBMEI7UUFDOUIsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsbUNBQW1DLEVBQUUsQ0FBQztRQUNoRSxNQUFNLEdBQUcsR0FBYSxFQUFFLENBQUM7UUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUMvQixHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLDBCQUEwQixDQUFDLENBQUMsQ0FBQyxDQUFXLENBQUMsQ0FBQztTQUNoRjtRQUNELE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3RELENBQUM7SUFFRCxLQUFLLENBQUMsd0JBQXdCO1FBQzVCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzlGLENBQUM7SUFFRCxLQUFLLENBQUMsU0FBUztRQUNiLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNyRixDQUFDO0lBRUQsS0FBSyxDQUFDLGtCQUFrQixDQUFDLGVBQXVCO1FBQzlDLE9BQU8sVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQztJQUMvRixDQUFDO0lBRUQsS0FBSyxDQUFDLHlCQUF5QjtRQUM3QixPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLHlCQUF5QixFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3RSxDQUFDO0lBRUQsS0FBSyxDQUFDLG1CQUFtQjtRQUN2QixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyx5QkFBeUIsRUFBRSxDQUFDO1FBQ3RELE1BQU0sT0FBTyxHQUFVLEVBQUUsQ0FBQztRQUUxQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2hDLE9BQU8sQ0FBQyxJQUFJLENBQUM7Z0JBQ1gsRUFBRSxFQUFFLENBQUM7Z0JBQ0wsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztnQkFDekMsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQzthQUMxQyxDQUFDLENBQUM7U0FDSjtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsZUFBdUI7UUFDN0MsT0FBTyxDQUFDLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFFRCxLQUFLLENBQUMsaUJBQWlCLENBQUMsT0FBZTtRQUNyQyxPQUFPLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdEYsQ0FBQztJQUVELEtBQUssQ0FBQyx3QkFBd0I7UUFDNUIsT0FBTyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyx3QkFBd0IsRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDNUUsQ0FBQztJQUVELEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFlO1FBQ3BDLE9BQU8sQ0FBQyxDQUFDLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQsS0FBSyxDQUFDLGtCQUFrQjtRQUN0QixNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO1FBQ3JELE1BQU0sTUFBTSxHQUFVLEVBQUUsQ0FBQztRQUV6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLElBQUksTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2hDLE1BQU0sQ0FBQyxJQUFJLENBQUM7Z0JBQ1YsT0FBTyxFQUFFLE1BQU0sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztnQkFDeEMsUUFBUSxFQUFFLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQzthQUN6QyxDQUFDLENBQUM7U0FDSjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBSyxDQUFDLFVBQXlCLEVBQUU7UUFDckMsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUM3QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxlQUFlLENBQUMsS0FBSyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUNoRixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsT0FBTyxDQUFDLFVBQXlCLEVBQUU7UUFDdkMsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUM3QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxlQUFlLENBQUMsT0FBTyxDQUFDLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUNsRixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsU0FBUyxDQUFDLElBQWUsRUFBRSxPQUFtQixFQUFFLFVBQXlCLEVBQUU7UUFDL0UsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUM3QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxlQUFlLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ25GLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBZSxFQUFFLE9BQW1CLEVBQUUsVUFBeUIsRUFBRTtRQUNoRixNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzdCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1RCxNQUFNLEVBQUUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDcEYsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsS0FBSyxDQUFDLGlCQUFpQixDQUFDLGVBQTJCLEVBQUUsS0FBYyxFQUFFLFVBQXlCLEVBQUU7UUFDOUYsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUM3QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxlQUFlO2FBQzdCLGlCQUFpQixDQUFDLGVBQWUsQ0FBQyxRQUFRLEVBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQzthQUNsRSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM5QixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsa0JBQWtCLENBQUMsZUFBMkIsRUFBRSxVQUF5QixFQUFFO1FBQy9FLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDN0IsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVELE1BQU0sRUFBRSxHQUFHLE1BQU0sZUFBZTthQUM3QixrQkFBa0IsQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQzthQUM1RCxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM5QixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsWUFBWSxDQUNoQixRQUFnQixFQUNoQixLQUFhLEVBQ2IsV0FBbUIsRUFDbkIsY0FBeUIsRUFDekIsVUFBeUIsRUFBRTtRQUUzQixNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzdCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1RCxNQUFNLEVBQUUsR0FBRyxNQUFNLGVBQWU7YUFDN0IsWUFBWSxDQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDO2FBQ3hFLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzlCLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELEtBQUssQ0FBQyxhQUFhLENBQUMsZ0JBQTJCLEVBQUUsVUFBcUIsRUFBRSxVQUF5QixFQUFFO1FBQ2pHLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDN0IsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVELE1BQU0sRUFBRSxHQUFHLE1BQU0sZUFBZTthQUM3QixhQUFhLENBQUMsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUM7YUFDekQsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDOUIsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBQ0QsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFtQixFQUFFLFVBQXlCLEVBQUU7UUFDaEUsTUFBTSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUM3QixNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxlQUFlLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDMUcsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsS0FBSyxDQUFDLDJCQUEyQixDQUFDLElBQWEsRUFBRSxVQUF5QixFQUFFO1FBQzFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDN0IsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVELE1BQU0sRUFBRSxHQUFHLE1BQU0sZUFBZSxDQUFDLDJCQUEyQixDQUFDLElBQUksRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDakYsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQyxDQUFDO0lBRUQsS0FBSyxDQUFDLGtCQUFrQixDQUFDLGFBQXlCLEVBQUUsY0FBYyxHQUFHLENBQUMsRUFBRSxVQUF5QixFQUFFO1FBQ2pHLE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDN0IsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVELE1BQU0sRUFBRSxHQUFHLE1BQU0sZUFBZSxDQUFDLGtCQUFrQixDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxjQUFjLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQzVHLE9BQU8sTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxZQUF3QixFQUFFLGFBQWEsR0FBRyxDQUFDLEVBQUUsVUFBeUIsRUFBRTtRQUM5RixNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzdCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1RCxNQUFNLEVBQUUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLEVBQUUsYUFBYSxFQUFFO1lBQ3pGLFFBQVE7U0FDVCxDQUFDLENBQUM7UUFDSCxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsMkJBQTJCLENBQUMsZ0JBQXdCLEVBQUUsVUFBeUIsRUFBRTtRQUNyRixNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzdCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1RCxNQUFNLEVBQUUsR0FBRyxNQUFNLGVBQWU7YUFDN0IsMkJBQTJCLENBQUMsZ0JBQWdCLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQzthQUMzRCxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM5QixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsb0JBQW9CO1FBQ3hCLE1BQU0sQ0FBQyxVQUFVLEVBQUUsZUFBZSxDQUFDLEdBQW1CLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO1FBQ3hHLE9BQU8sRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDM0QsQ0FBQztJQUVELCtHQUErRztJQUMvRywwQ0FBMEM7SUFDMUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLE9BQWUsRUFBRSxVQUFvQixFQUFFLGNBQXdCO1FBQ3ZGLGlGQUFpRjtRQUNqRixPQUFPLENBQUMsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLEdBQUcsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztJQUNyRyxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsZUFBZSxDQUFDLE9BQWUsRUFBRSxVQUFvQixFQUFFLGNBQXdCLEVBQUUsV0FBbUI7UUFDeEcsTUFBTSxhQUFhLEdBQUcsZUFBZSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN0RCxNQUFNLG1CQUFtQixHQUFHLHdCQUF3QixDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2pFLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLG1CQUFtQjthQUNwRSxhQUFhLENBQUMsT0FBTyxFQUFFLG1CQUFtQixDQUFDO2FBQzNDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzlCLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUUxRSxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBQzdDLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxXQUFXLENBQUMsQ0FBQztRQUN0RCxvRUFBb0U7UUFDcEUsNEZBQTRGO1FBQzVGLE1BQU0sU0FBUyxHQUFHLE1BQU07WUFDdEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUM7WUFDcEcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXRCLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUMxQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQ3JCLElBQUksQ0FBQyxlQUFlLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQ3RHLENBQ0YsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM3QixNQUFNLGVBQWUsR0FBRyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFNUYsTUFBTSxNQUFNLEdBQWM7WUFDeEIsYUFBYTtZQUNiLGVBQWU7U0FDaEIsQ0FBQztRQUVGLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFTSxLQUFLLENBQUMsYUFBYSxDQUN4QixFQUFFLGFBQWEsRUFBRSxlQUFlLEVBQXdELEVBQ3hGLFVBQXlCLEVBQUU7UUFFM0IsS0FBSyxNQUFNLEVBQUUsSUFBSSxlQUFlLEVBQUU7WUFDaEMsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1NBQ3ZCO1FBQ0QsT0FBTyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFTSxLQUFLLENBQUMsTUFBTSxDQUFDLElBQVksRUFBRSxVQUF5QixFQUFFO1FBQzNELE1BQU0sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDeEYsTUFBTSxNQUFNLEdBQUcsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDaEgsTUFBTSxJQUFJLEdBQUcsTUFBTSxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7UUFDdkMsTUFBTSxTQUFTLEdBQXVCO1lBQ3BDLEVBQUUsRUFBRSxJQUFJLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFO1lBQ3pDLElBQUk7WUFDSixRQUFRO1lBQ1IsSUFBSTtZQUNKLEtBQUs7WUFDTCxZQUFZO1lBQ1osb0JBQW9CO1NBQ3JCLENBQUM7UUFDRixNQUFNLFVBQVUsR0FBRyxNQUFNLE1BQU0sQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDdEYsT0FBTyxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM1QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVksQ0FBQyxNQUFjO1FBQ3RDLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUM1RSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1NBQ3pDO1FBQ0QsT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVNLEtBQUssQ0FBQyxtQkFBbUIsQ0FDOUIsT0FBZSxFQUNmLE1BQWMsRUFDZCxZQUFvQixNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUNwQyxVQUF5QixFQUFFO1FBRTNCLElBQUksRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDM0IsTUFBTSxlQUFlLEdBQUcsSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzVELE1BQU0sU0FBUyxHQUFHLE1BQU0sZUFBZSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUU1RCxNQUFNLEtBQUssR0FBRyxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztRQUVqRCwwR0FBMEc7UUFDMUcsK0RBQStEO1FBQy9ELCtHQUErRztRQUMvRyxvREFBb0Q7UUFDcEQsSUFBSSxDQUFDLFFBQVEsRUFBRTtZQUNiLE1BQU0sVUFBVSxHQUFHLE1BQU0sZUFBZSxDQUFDLFdBQVc7aUJBQ2pELG1CQUFtQixDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtnQkFDMUQsS0FBSzthQUNOLENBQUM7aUJBQ0QsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDOUIsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxHQUFHLGVBQWUsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQzVGO1FBRUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxlQUFlO2FBQzdCLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRTtZQUMxRCxLQUFLO1lBQ0wsUUFBUTtTQUNULENBQUM7YUFDRCxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM5QixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMseUJBQXlCLENBQzdCLE9BQWUsRUFDZixNQUFjLEVBQ2QsUUFBZ0IsRUFDaEIsU0FBNEIsRUFDNUIsVUFBeUIsRUFBRTtRQUUzQixJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzNCLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQywyQkFBMkIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUMvRCxNQUFNLFNBQVMsR0FBRyxNQUFNLFlBQVksQ0FBQyxNQUFNLENBQUMsVUFBVSxFQUFFLENBQUM7UUFFekQsNkZBQTZGO1FBQzdGLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLFVBQVUsR0FBRyxNQUFNLFlBQVksQ0FBQyxXQUFXO2lCQUM5Qyx5QkFBeUIsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUM7aUJBQ3RHLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1lBQzlCLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsR0FBRyxlQUFlLENBQUMsNEJBQTRCLENBQUMsQ0FBQztTQUM1RjtRQUVELE1BQU0sRUFBRSxHQUFHLE1BQU0sWUFBWTthQUMxQix5QkFBeUIsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsU0FBUyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLEVBQUU7WUFDdEcsUUFBUTtTQUNULENBQUM7YUFDRCxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM5QixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsb0NBQW9DLENBQ3hDLE9BQWUsRUFDZixNQUFjLEVBQ2QsS0FBYSxFQUNiLFFBQWdCLEVBQ2hCLFNBQTRCLEVBQzVCLFVBQXlCLEVBQUU7UUFFM0IsSUFBSSxFQUFFLFFBQVEsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUMzQixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsMkJBQTJCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDL0QsTUFBTSxTQUFTLEdBQUcsTUFBTSxZQUFZLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRXpELDZGQUE2RjtRQUM3RixJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2IsTUFBTSxVQUFVLEdBQUcsTUFBTSxZQUFZLENBQUMsV0FBVztpQkFDOUMsb0NBQW9DLENBQ25DLE9BQU8sRUFDUCxNQUFNLEVBQ04sU0FBUyxFQUNULEtBQUssRUFDTCxRQUFRLEVBQ1IsU0FBUyxDQUFDLENBQUMsRUFDWCxTQUFTLENBQUMsQ0FBQyxFQUNYLFNBQVMsQ0FBQyxDQUFDLENBQ1o7aUJBQ0EsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUM7WUFDOUIsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxHQUFHLGVBQWUsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1NBQzVGO1FBRUQsTUFBTSxFQUFFLEdBQUcsTUFBTSxZQUFZO2FBQzFCLG9DQUFvQyxDQUNuQyxPQUFPLEVBQ1AsTUFBTSxFQUNOLFNBQVMsRUFDVCxLQUFLLEVBQ0wsUUFBUSxFQUNSLFNBQVMsQ0FBQyxDQUFDLEVBQ1gsU0FBUyxDQUFDLENBQUMsRUFDWCxTQUFTLENBQUMsQ0FBQyxFQUNYLEVBQUUsUUFBUSxFQUFFLENBQ2I7YUFDQSxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUM5QixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsWUFBWSxDQUFDLFNBQWlCLEVBQUUsVUFBeUIsRUFBRTtRQUMvRCxNQUFNLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzdCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1RCxNQUFNLEVBQUUsR0FBRyxNQUFNLGVBQWUsQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsbUJBQW1CLENBQUMsQ0FBQztRQUNsRyxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3BDLENBQUM7SUFFRCxLQUFLLENBQUMsc0JBQXNCLENBQUMsT0FBbUIsRUFBRSxJQUFZO1FBQzVELE9BQU8sTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNwRixDQUFDO0lBRUQsS0FBSyxDQUFDLHFCQUFxQixDQUFDLE9BQWUsRUFBRSxPQUFtQjtRQUM5RCxPQUFPLE1BQU0sQ0FBQyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDN0YsQ0FBQztJQUVELEtBQUssQ0FBQywyQkFBMkIsQ0FBQyxVQUF5QixFQUFFO1FBQzNELE1BQU0sRUFBRSxRQUFRLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDN0IsT0FBTyxNQUFNLElBQUksQ0FBQyxlQUFlLENBQUMsd0JBQXdCLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFTyxLQUFLLENBQUMsZ0JBQWdCO1FBQzVCLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVLEVBQUUsQ0FBQztRQUM3QyxPQUFPLGdCQUFnQixDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBSU0sS0FBSyxDQUFDLG1CQUFtQixDQUFDLFFBQWdCLEVBQUUsZ0JBQXdCO1FBQ3pFLE1BQU0sTUFBTSxHQUFZLEVBQUUsQ0FBQztRQUMzQixNQUFNLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkgsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7OztPQWNHO0lBQ0ksS0FBSyxDQUFDLHdCQUF3QixDQUNuQyxRQUFnQixFQUNoQixnQkFBd0IsRUFDeEIsRUFBbUM7UUFFbkMsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDcEYsTUFBTSxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ3ZFLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxFQUFFO1lBQ2IsSUFBSSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsUUFBUSxvQkFBb0IsQ0FBQyxDQUFDO1lBQzlELE9BQU87U0FDUjtRQUNELE1BQU0sS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7UUFFL0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxxQ0FBcUMsS0FBSyxLQUFLLENBQUMsQ0FBQztRQUM1RCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUNwRSxNQUFNLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQzFCLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQzlFLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxTQUFTLENBQUMsTUFBTSxlQUFlLEtBQUssQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFM0QsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3RGLE1BQU0sTUFBTSxHQUFHLFNBQVM7YUFDckIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLEdBQUcsQ0FBQyxDQUFDLFdBQVcsR0FBRyxDQUFDLElBQUksZ0JBQWdCLENBQUM7YUFDdkUsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUssQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLElBQUksUUFBUSxDQUFDLENBQUM7UUFFeEQsSUFBSSxNQUFNLENBQUMsTUFBTSxFQUFFO1lBQ2pCLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztZQUNyQyxNQUFNLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDakQsSUFBSSxDQUFDLEtBQUssQ0FBQywwQkFBMEIsZ0JBQWdCLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQy9EO2FBQU07WUFDTCxJQUFJLENBQUMsS0FBSyxDQUFDLHVDQUF1QyxDQUFDLENBQUM7U0FDckQ7UUFFRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDdkIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLEtBQUssQ0FBQyxjQUFjLENBQUMsUUFBZ0IsRUFBRSxnQkFBd0I7UUFDcEUsTUFBTSxrQkFBa0IsR0FBRyxNQUFNLElBQUksV0FBVyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXRGLE1BQU0sZUFBZSxHQUFHLEtBQUssSUFBSSxFQUFFO1lBQ2pDLE1BQU0sRUFBRSxhQUFhLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1lBQ3hELE1BQU0sV0FBVyxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN6RCxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztZQUV4RCxzREFBc0Q7WUFDdEQsSUFBSSxHQUFHLEdBQUcsV0FBVyxDQUFDO1lBQ3RCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLGVBQWUsRUFBRSxhQUFhLENBQUMsQ0FBQztZQUMzRCxJQUFJLEtBQXdCLENBQUM7WUFFN0IsT0FBTyxHQUFHLEdBQUcsYUFBYSxJQUFJLENBQUMsS0FBSyxFQUFFO2dCQUNwQyxJQUFJLENBQUMsS0FBSyxDQUFDLHlDQUF5QyxLQUFLLFFBQVEsR0FBRyxLQUFLLENBQUMsQ0FBQztnQkFDM0UsTUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUM7Z0JBQ3BFLE1BQU0sU0FBUyxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsWUFBWSxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsQ0FBQztnQkFDbkYsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLENBQUM7Z0JBQ2pHLEtBQUssSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDckQsTUFBTSxJQUFJLENBQUMseUJBQXlCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQzNGO2dCQUVELEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUM7Z0JBQ3pDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxlQUFlLEVBQUUsYUFBYSxDQUFDLENBQUM7YUFDeEQ7WUFDRCxPQUFPLEtBQUssQ0FBQztRQUNmLENBQUMsQ0FBQztRQUVGLE1BQU0saUJBQWlCLEdBQUcsS0FBSyxJQUFJLEVBQUU7WUFDbkMsTUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDcEYsTUFBTSxTQUFTLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1lBQy9FLE1BQU0sTUFBTSxHQUFHLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxrQkFBa0IsR0FBRyxDQUFDLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ2pHLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFO2dCQUNsQixPQUFPO2FBQ1I7WUFDRCxJQUFJLEtBQXdCLENBQUM7WUFDN0IsTUFBTSxJQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNyRixPQUFPLEtBQUssQ0FBQztRQUNmLENBQUMsQ0FBQztRQUVGLElBQUksUUFBUSxJQUFJLENBQUMsQ0FBQyxFQUFFO1lBQ2xCLE9BQU8sTUFBTSxlQUFlLEVBQUUsQ0FBQztTQUNoQztRQUNELE9BQU8sTUFBTSxpQkFBaUIsRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRDs7T0FFRztJQUNLLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxZQUFxQixFQUFFLEVBQW1DO1FBQ2hHLElBQUksWUFBWSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0IsT0FBTyxFQUFFLENBQUM7U0FDWDtRQUVELElBQUksQ0FBQyxLQUFLLENBQUMscUJBQXFCLFlBQVksQ0FBQyxNQUFNLGFBQWEsQ0FBQyxDQUFDO1FBRWxFLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUMxQyxNQUFNLFlBQVksR0FBRyxNQUFNLElBQUksQ0FBQyxrQ0FBa0MsQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUNqRixJQUFJLENBQUMsS0FBSyxDQUFDLGlDQUFpQyxxQkFBcUIsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFM0UsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLEtBQUssRUFBRSxDQUFDO1FBQ3hDLE1BQU0scUJBQXFCLEdBQUcsTUFBTSxJQUFJLENBQUMscUJBQXFCLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDN0UsSUFBSSxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsbUJBQW1CLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTNFLDBHQUEwRztRQUMxRyxNQUFNLDZCQUE2QixHQUFHLHFCQUFxQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ3RGLElBQUksNkJBQTZCLElBQUksQ0FBQyxDQUFDLEVBQUU7WUFDdkMsWUFBWSxDQUFDLE1BQU0sQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1NBQ3BEO1FBRUQsbUdBQW1HO1FBQ25HLHVGQUF1RjtRQUN2RixNQUFNLFlBQVksR0FBRyxJQUFJLFVBQVUsRUFBTyxDQUFDO1FBRTNDLG1EQUFtRDtRQUNuRCw0R0FBNEc7UUFDNUcscURBQXFEO1FBQ3JELGtHQUFrRztRQUNsRywrR0FBK0c7UUFDL0csNEVBQTRFO1FBQzVFLE1BQU0sY0FBYyxHQUFHLElBQUksU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXpDLDZGQUE2RjtRQUM3Riw4RUFBOEU7UUFDOUUsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDO1FBRWpCLGtDQUFrQztRQUNsQyxNQUFNLGNBQWMsR0FBRyxZQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFO1lBQzNFLElBQUk7Z0JBQ0YsSUFBSSxJQUFJLEVBQUU7b0JBQ1IsT0FBTztpQkFDUjtnQkFDRCxNQUFNLElBQUksR0FBRyxNQUFNLFdBQVcsQ0FBQztnQkFDL0IsTUFBTSxjQUFjLEdBQW1CO29CQUNyQyxLQUFLO29CQUNMLEVBQUUsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO29CQUNYLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO29CQUNkLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO29CQUNoQixlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztvQkFDeEIsb0JBQW9CLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztpQkFDOUIsQ0FBQztnQkFDRixNQUFNLGtCQUFrQixHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLEVBQUUsWUFBWSxDQUFDLENBQUM7Z0JBQ2hGLE1BQU0sRUFBRSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxjQUFjLEVBQUUsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO2FBQzFFO1lBQUMsT0FBTyxHQUFHLEVBQUU7Z0JBQ1osSUFBSSxHQUFHLElBQUksQ0FBQztnQkFDWixPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2xCO29CQUFTO2dCQUNSLGNBQWMsQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUMxQjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsZUFBZTtRQUNmLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQ3JELE1BQU0sY0FBYyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQy9CLE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QixNQUFNLFlBQVksR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM5QyxJQUFJLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxLQUFLLENBQUMsSUFBSSxFQUFFLFFBQVEsR0FBRyxDQUFDLENBQUM7WUFDcEUsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQztnQkFDOUIsS0FBSyxDQUFDLGNBQWMsRUFBRTtnQkFDdEIsS0FBSyxDQUFDLFFBQVEsRUFBRTtnQkFDaEIsS0FBSyxDQUFDLHFCQUFxQixFQUFFO2dCQUM3QixPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQztnQkFDdEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixFQUFFLENBQUMsQ0FBQzthQUM5RCxDQUFDLENBQUM7WUFDSCxZQUFZLENBQUMsR0FBRyxDQUFDLEVBQUUsS0FBSyxFQUFFLFdBQVcsRUFBRSxDQUFDLENBQUM7U0FDMUM7UUFFRCxZQUFZLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDbkIsTUFBTSxjQUFjLENBQUM7SUFDdkIsQ0FBQztJQUVPLGlCQUFpQixDQUFDLElBQW9CLEVBQUUsWUFBaUI7UUFDL0QsNEVBQTRFO1FBQzVFLDZEQUE2RDtRQUM3RCxvRUFBb0U7UUFDcEUsTUFBTSxtQkFBbUIsR0FBRyxJQUFJLENBQUMsZ0NBQWdDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlFLE1BQU0sc0JBQXNCLEdBQTJCLEVBQUUsQ0FBQztRQUMxRCxLQUFLLE1BQU0sSUFBSSxJQUFJLG1CQUFtQixFQUFFO1lBQ3RDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3ZCLE1BQU0sSUFBSSxLQUFLLENBQ2IsbURBQW1ELElBQUksY0FBYyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxRQUFRLEdBQUcsQ0FDbEcsQ0FBQzthQUNIO1lBQ0Qsc0JBQXNCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUUsQ0FBQyxDQUFDO1NBQ2xEO1FBQ0QsT0FBTyxzQkFBc0IsQ0FBQztJQUNoQyxDQUFDO0lBRU8scUJBQXFCLENBQUMsSUFBb0IsRUFBRSxzQkFBOEM7UUFDaEcsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FDNUIsRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLEVBQy9DLElBQUksQ0FBQyxPQUFPLEVBQ1osc0JBQXNCLEVBQ3RCLElBQUksQ0FBQyxlQUFlLEVBQ3BCLElBQUksQ0FBQyxvQkFBb0IsQ0FDMUIsQ0FBQztRQUNGLE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVPLGdDQUFnQyxDQUFDLFdBQWtCO1FBQ3pELDRFQUE0RTtRQUM1RSxNQUFNLFNBQVMsR0FBRyxFQUFFLFdBQVcsRUFBRSxXQUFXLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDL0csTUFBTSxFQUNKLElBQUksRUFBRSxFQUFFLHNCQUFzQixFQUFFLEdBQ2pDLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ2hELE9BQU8sc0JBQXNCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBWSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckUsQ0FBQztJQUVPLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxZQUFxQjtRQUNwRSw2R0FBNkc7UUFDN0csTUFBTSxZQUFZLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQzNGLE1BQU0sV0FBVyxHQUF3RCxFQUFFLENBQUM7UUFDNUUsS0FBSyxNQUFNLElBQUksSUFBSSxZQUFZLEVBQUU7WUFDL0IsV0FBVyxDQUFDLElBQUksQ0FBQyxHQUFHLFNBQVMsQ0FBQztTQUMvQjtRQUNELElBQUksZUFBZSxHQUFHLFlBQVksQ0FBQyxNQUFNLENBQUM7UUFFMUMsd0VBQXdFO1FBQ3hFLHlIQUF5SDtRQUN6SCxNQUFNLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFFL0QsNEZBQTRGO1FBQzVGLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLFlBQVksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztRQUMvRSxJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGtCQUFrQixFQUFFLGFBQWEsQ0FBQyxDQUFDO1FBQzNELElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxHQUFHLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztRQUUzRCx3R0FBd0c7UUFDeEcsT0FBTyxRQUFRLEdBQUcsYUFBYSxJQUFJLGVBQWUsR0FBRyxDQUFDLEVBQUU7WUFDdEQsSUFBSSxDQUFDLEtBQUssQ0FBQyx3Q0FBd0MsVUFBVSxNQUFNLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDL0UsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztZQUNsRSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLENBQUMsQ0FBQztZQUM5RixpRUFBaUU7WUFDakUsTUFBTSxhQUFhLEdBQUcsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBNEQsRUFBRSxFQUFFO2dCQUMxRyxNQUFNLEVBQ0osSUFBSSxFQUFFLEVBQ0oscUJBQXFCLEVBQ3JCLEtBQUssRUFDTCxlQUFlLEVBQ2YsaUJBQWlCLEVBQ2pCLGlCQUFpQixFQUNqQixNQUFNLEVBQ04sV0FBVyxHQUNaLEdBQ0YsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBRTFDLE9BQU8sSUFBSSxvQkFBb0IsQ0FDN0IsY0FBYyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMscUJBQXFCLENBQUMsQ0FBQyxFQUN4RCxDQUFDLEtBQUssRUFDTixNQUFNLENBQUMsZUFBZSxDQUFDLEVBQ3ZCLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxFQUN6QixNQUFNLENBQUMsaUJBQWlCLENBQUMsRUFDekIsTUFBTSxFQUNOLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FDekMsQ0FBQztZQUNKLENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLGFBQWEsQ0FBQyxNQUFNLHlCQUF5QixVQUFVLE1BQU0sUUFBUSxFQUFFLENBQUMsQ0FBQztZQUM3Rix3RUFBd0U7WUFDeEUsS0FBSyxNQUFNLFdBQVcsSUFBSSxhQUFhLEVBQUU7Z0JBQ3ZDLE1BQU0sUUFBUSxHQUFHLHdCQUF3QixDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzVFLElBQUksTUFBTSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLEtBQUssU0FBUyxFQUFFO29CQUN0RyxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsV0FBVyxDQUFDO29CQUNwQyxFQUFFLGVBQWUsQ0FBQztpQkFDbkI7YUFDRjtZQUNELFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQVUsR0FBRyxDQUFDLEVBQUUsYUFBYSxDQUFDLENBQUM7WUFDbkQsVUFBVSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxHQUFHLEtBQUssRUFBRSxhQUFhLENBQUMsQ0FBQztTQUN4RDtRQUNELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFTyxLQUFLLENBQUMscUJBQXFCLENBQUMsWUFBcUI7UUFDdkQsTUFBTSxVQUFVLEdBQUcsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlFLG1FQUFtRTtRQUNuRSxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQ3RELFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUNsRSxDQUFDO1FBQ0YsMEVBQTBFO1FBQzFFLE1BQU0sRUFBRSxrQkFBa0IsRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7UUFDN0QsTUFBTSxLQUFLLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsR0FBRyxrQkFBa0IsQ0FBQztRQUMvRCxNQUFNLEdBQUcsR0FBRyxZQUFZLENBQUMsWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7UUFDOUQsSUFBSSxDQUFDLEtBQUssQ0FBQyw2Q0FBNkMsS0FBSyxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDN0UsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsQ0FDM0QsTUFBTSxFQUNOLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEdBQUcsa0JBQWtCLEVBQ2hELFlBQVksQ0FBQyxZQUFZLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FDbEQsQ0FBQztRQUNGLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxjQUFjLENBQUMsTUFBTSxtQkFBbUIsQ0FBQyxDQUFDO1FBQzlELDJEQUEyRDtRQUMzRCxNQUFNLGdCQUFnQixHQUFHLGNBQWMsQ0FBQyxNQUFNLENBQTZCLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xGLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN4RCxNQUFNLEVBQ0osSUFBSSxFQUFFLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEdBQy9DLEdBQUcsV0FBVyxDQUFDO1lBRWhCLHdGQUF3RjtZQUN4RixNQUFNLGNBQWMsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEtBQUssUUFBUSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDckcsSUFBSSxjQUFjLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0JBQ3pCLE1BQU0sV0FBVyxHQUFHLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDakQsSUFBSSxXQUFXLENBQUMsV0FBVyxHQUFHLENBQUMsQ0FBQyxXQUFXLEVBQUU7b0JBQzNDLElBQUksQ0FBQyxLQUFLLENBQ1Isb0NBQW9DLENBQUMsQ0FBQyxXQUFXLGVBQWUsUUFBUSxhQUFhLFdBQVcsQ0FBQyxXQUFXLEVBQUUsQ0FDL0csQ0FBQztvQkFDRixPQUFPLENBQUMsQ0FBQztpQkFDVjthQUNGO1lBRUQsTUFBTSxHQUFHLEdBQUcsR0FBRyxRQUFRLElBQUksTUFBTSxFQUFFLENBQUM7WUFDcEMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxJQUFJLFdBQVcsRUFBRTtnQkFDM0MsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQzthQUM5QztZQUNELDhEQUE4RDtZQUM5RCxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxLQUFLLENBQUMscUNBQXFDLFFBQVEsWUFBWSxNQUFNLFdBQVcsS0FBSyxHQUFHLENBQUMsQ0FBQztZQUMvRixPQUFPLENBQUMsQ0FBQztRQUNYLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNQLG1HQUFtRztRQUNuRyxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDaEMsTUFBTSxFQUNKLElBQUksRUFBRSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsR0FDM0IsR0FBRyxTQUFTLENBQUM7WUFDZCxNQUFNLEdBQUcsR0FBRyxHQUFHLFFBQVEsSUFBSSxNQUFNLEVBQUUsQ0FBQztZQUNwQyxNQUFNLGNBQWMsR0FBRyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3QyxJQUFJLENBQUMsY0FBYyxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNuRCxPQUFPLENBQUMsR0FBRyxDQUFDLDRDQUE0QyxRQUFRLEVBQUUsQ0FBQyxDQUFDO2dCQUNwRSxPQUFPLEVBQUUsQ0FBQzthQUNYO1lBQ0QsT0FBTyxjQUFjLENBQUM7UUFDeEIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRU8sV0FBVyxDQUNqQixRQUE2QixFQUM3QixPQUEyQixFQUMzQixpQkFBeUMsRUFDekMsZUFBc0MsRUFDdEMsb0JBQTBDO1FBRTFDLE1BQU0sU0FBUyxHQUFHLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM5RCxNQUFNLGNBQWMsR0FBRyxTQUFTLENBQUMsZ0JBQWdCLENBQUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7UUFDM0UsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUNyQyxlQUFlO2FBQ1osR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO2FBQ3hELEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FDOUQsQ0FBQztRQUNGLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDO1FBQ3hDLE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2xFLE1BQU0sZUFBZSxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUNuRSxNQUFNLGFBQWEsR0FBRyxlQUFlLENBQUMscUJBQXFCLEVBQUUsQ0FBQztRQUM5RCxNQUFNLGNBQWMsR0FBRyxtQkFBbUIsQ0FBQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztRQUU3RSxJQUFJLENBQUMsS0FBSyxDQUFDLGtCQUFrQixlQUFlLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUV6RCxPQUFPLElBQUksS0FBSyxDQUNkLE1BQU0sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUNoQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBVSxHQUFHLElBQUksQ0FBQyxFQUNwQyxlQUFlLENBQUMsUUFBUSxFQUN4QixlQUFlLENBQUMsVUFBVSxFQUMxQixrQkFBa0IsRUFDbEIsY0FBYyxFQUNkLGlCQUFpQixFQUNqQixPQUFPLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxHQUFHLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUMvRixNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUN0QyxDQUFDO0lBQ0osQ0FBQztJQUVNLHFCQUFxQixDQUFDLE9BQXNCO1FBQ2pELE1BQU0sRUFBRSxjQUFjLEVBQUUsR0FBRyxPQUFPLENBQUM7UUFDbkMsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxZQUFZLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3ZGLE1BQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JGLE9BQU8sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxFQUFFLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNoRyxDQUFDO0lBRU0sMkJBQTJCLENBQUMsT0FBc0I7UUFDdkQsTUFBTSxFQUFFLGNBQWMsRUFBRSxHQUFHLE9BQU8sQ0FBQztRQUNuQyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLFlBQVksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDdkYsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDckYsT0FBTyxJQUFJLFFBQVEsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsUUFBUSxFQUFFLEVBQUUsWUFBWSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN4RixDQUFDO0lBRU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFZO1FBQ25DLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzFDLE1BQU0sSUFBSSxHQUFHLE1BQU0sTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBQ3ZDLE1BQU0sU0FBUyxHQUFHO1lBQ2hCLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRTtZQUMzQixJQUFJO1lBQ0osSUFBSSxFQUFFLEtBQUssSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtTQUNsQyxDQUFDO1FBQ0YsSUFBSTtZQUNGLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7WUFDNUQsT0FBTyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7U0FDNUI7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLE1BQU0sR0FBRyxHQUFHLE1BQU0sSUFBSSxDQUFDLGdCQUFnQjtpQkFDcEMsT0FBTyxDQUFDLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxTQUFTLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztpQkFDOUQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDckIsSUFBSSxHQUFHLENBQUMsSUFBSSxFQUFFO2dCQUNaLE1BQU0sV0FBVyxHQUFHLHVCQUF1QixDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNyRSxJQUFJLFdBQVcsRUFBRTtvQkFDZixNQUFNLE9BQU8sR0FBRyxHQUFHLFdBQVcsQ0FBQyxJQUFJLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztvQkFDeEUsTUFBTSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztpQkFDMUI7YUFDRjtZQUNELE1BQU0sR0FBRyxDQUFDO1NBQ1g7SUFDSCxDQUFDO0lBRU0sS0FBSyxDQUFDLGNBQWMsQ0FBQyxNQUFjO1FBQ3hDLE9BQU8sTUFBTSwrQkFBK0IsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUM3RixDQUFDOztBQS80QmUsd0NBQXdCLEdBQUcsTUFBTSxDQUFDO0FBQ2xDLHVDQUF1QixHQUFHLEtBQUssQ0FBQztBQUVqQyw0Q0FBNEIsR0FBRyxHQUFHLENBQUMifQ==
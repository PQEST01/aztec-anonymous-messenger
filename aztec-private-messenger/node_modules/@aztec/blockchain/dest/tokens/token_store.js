import { Contract } from 'ethers';
import { Uniswap, addressesAreSame, fixEthersStackTrace } from './uniswap.js';
import { getTokenBalance, approveToken, transferToken } from './index.js';
import { MainnetAddresses } from './mainnet_addresses.js';
import { Web3Provider } from '@ethersproject/providers';
import { EthAddress } from '@aztec/barretenberg/address';
import { CurveStablePool, FactoryAbi, ProviderAbi, RegistryAbi, Zap } from '../abis.js';
/** Token Store
 *
 * @notice Acquire tokens on a mainnet fork by swapping for the required tokens on Uniswap
 */
export class TokenStore {
    constructor(provider) {
        this.provider = provider;
        this.ethersProvider = new Web3Provider(provider);
    }
    async init() {
        this.providerContract = new Contract(MainnetAddresses.Contracts['CURVE_PROVIDER'], ProviderAbi.abi, this.ethersProvider);
        const registryAddress = await this.providerContract.get_registry();
        this.registryContract = new Contract(registryAddress, RegistryAbi.abi, this.ethersProvider);
        this.factoryContract = new Contract(MainnetAddresses.Contracts['CURVE_FACTORY'], FactoryAbi.abi, this.ethersProvider);
    }
    static async create(provider) {
        const store = new TokenStore(provider);
        await store.init();
        return store;
    }
    // private async logAllStablePools() {
    //   const poolCount = (await this.registryContract!.pool_count()).toNumber();
    //   const mappings = new Map<string, string>();
    //   for (let i = 0; i < poolCount; i++) {
    //     const poolAddress = (await this.registryContract!.pool_list(i)).toString();
    //     const tokenAddress = await this.registryContract!.get_lp_token(poolAddress);
    //     mappings.set(poolAddress, tokenAddress);
    //   }
    //   console.log('Token mappings ', mappings);
    // }
    // private async logAllMetaPools() {
    //   const poolCount = (await this.factoryContract!.pool_count()).toNumber();
    //   const tokens = [];
    //   for (let i = 0; i < poolCount; i++) {
    //     const poolAddress = (await this.factoryContract!.pool_list(i)).toString();
    //     tokens.push(poolAddress);
    //   }
    //   console.log('Tokens ', tokens);
    // }
    async depositToStablePool(spender, recipient, token, amountInMaximum) {
        let amountToDeposit = token.amount;
        const poolAddress = (await this.registryContract.get_pool_from_lp_token(token.erc20Address.toString())).toString();
        const numCoinsResult = await this.registryContract.get_n_coins(poolAddress);
        const numCoins = numCoinsResult[1].toNumber();
        const coins = (await this.registryContract.get_coins(poolAddress)).map((x) => EthAddress.fromString(x));
        const inputAssetIndex = this.findPreferredAssset(coins);
        if (inputAssetIndex === -1) {
            throw new Error('Asset not supported');
        }
        const inputAsset = coins[inputAssetIndex];
        const signer = this.ethersProvider.getSigner(spender.toString());
        if (!addressesAreSame(inputAsset.toString(), MainnetAddresses.Tokens['ETH'])) {
            // need to uniswap to the preferred input asset
            const uniswap = new Uniswap(this.provider);
            amountToDeposit = await uniswap.swapFromEth(spender, spender, { erc20Address: inputAsset, amount: token.amount }, amountInMaximum);
        }
        await approveToken(inputAsset, spender, poolAddress, this.provider, amountToDeposit);
        const amounts = new Array(numCoins).fill(BigInt(0));
        amounts[inputAssetIndex] = amountToDeposit;
        const poolContract = new Contract(poolAddress, CurveStablePool.abi, signer);
        const depositFunc = poolContract.functions[`add_liquidity(uint256[${numCoins}],uint256)`];
        const amountBefore = await getTokenBalance(token.erc20Address, spender, this.provider);
        const depositResponse = await depositFunc(amounts, BigInt(0), {
            value: addressesAreSame(inputAsset.toString(), MainnetAddresses.Tokens['ETH']) ? amountToDeposit : BigInt(0),
        }).catch(fixEthersStackTrace);
        await depositResponse.wait();
        const amountAfter = await getTokenBalance(token.erc20Address, spender, this.provider);
        const amountMinted = BigInt(amountAfter) - BigInt(amountBefore);
        await transferToken(token.erc20Address, spender, recipient, this.provider, amountMinted);
        return amountMinted;
    }
    findPreferredAssset(availableAssets) {
        const ethIndex = availableAssets.findIndex(asset => addressesAreSame(asset.toString(), MainnetAddresses.Tokens['ETH']));
        if (ethIndex !== -1) {
            return ethIndex;
        }
        const wethIndex = availableAssets.findIndex(asset => addressesAreSame(asset.toString(), MainnetAddresses.Tokens['WETH']));
        if (wethIndex !== -1) {
            return wethIndex;
        }
        const stableIndex = availableAssets.findIndex(asset => Uniswap.isSupportedAsset(asset));
        return stableIndex;
    }
    async depositToMetaPool(spender, recipient, token, amountInMaximum) {
        let amountToDeposit = token.amount;
        const numCoinsResult = await this.factoryContract.get_n_coins(token.erc20Address.toString());
        const numCoins = numCoinsResult[1].toNumber();
        const coins = (await this.factoryContract.get_underlying_coins(token.erc20Address.toString())).map((x) => EthAddress.fromString(x));
        const inputAssetIndex = this.findPreferredAssset(coins);
        if (inputAssetIndex === -1) {
            throw new Error('Asset not supported');
        }
        const inputAsset = coins[inputAssetIndex];
        if (!addressesAreSame(inputAsset.toString(), MainnetAddresses.Tokens['ETH'])) {
            // need to uniswap to the preferred input asset
            const uniswap = new Uniswap(this.provider);
            amountToDeposit = await uniswap.swapFromEth(spender, spender, { erc20Address: inputAsset, amount: token.amount }, amountInMaximum);
        }
        await approveToken(inputAsset, spender, EthAddress.fromString(MainnetAddresses.Contracts['CURVE_ZAP']), this.provider, amountToDeposit);
        const amounts = new Array(numCoins).fill(BigInt(0));
        amounts[inputAssetIndex] = amountToDeposit;
        const signer = this.ethersProvider.getSigner(spender.toString());
        const zapDepositor = new Contract(MainnetAddresses.Contracts['CURVE_ZAP'], Zap.abi, signer);
        const depositFunc = zapDepositor.functions[`add_liquidity(address,uint256[${numCoins}],uint256,address)`];
        const amountBefore = await getTokenBalance(token.erc20Address, recipient, this.provider);
        const depositResponse = await depositFunc(token.erc20Address.toString(), amounts, BigInt(0), recipient.toString(), {
            value: addressesAreSame(inputAsset.toString(), MainnetAddresses.Tokens['ETH']) ? amountToDeposit : BigInt(0),
        }).catch(fixEthersStackTrace);
        await depositResponse.wait();
        const amountAfter = await getTokenBalance(token.erc20Address, recipient, this.provider);
        const amountMinted = BigInt(amountAfter) - BigInt(amountBefore);
        return amountMinted;
    }
    async getPoolForLpToken(lpTokenAddress) {
        const poolAddress = (await this.registryContract.get_pool_from_lp_token(lpTokenAddress.toString())).toString();
        return poolAddress;
    }
    async isMetaPool(lpTokenAddress) {
        const poolAddress = await this.getPoolForLpToken(lpTokenAddress);
        // for meta pools, the pool is the lp token. for stable pools, it's not
        return addressesAreSame(poolAddress, lpTokenAddress.toString());
    }
    /**
     * Will attempt to purchase or mint tokens from uniswap or curve
     * The desired token is specified by the erc20 address and quantity
     * We will attempt to achieve this quantity by
     * 1. Attempting to purchase from uniswap if it is one of our supported uniswap assets or
     * 2. Attempting to deposit to a curve pool and minting the requested tokens, this may first require us to purchase a stablecoin from uniswap
     *
     * In the case of 1 above, we ask uniswap for outputToken.amount of the requested asset and specify amountInMaximum as the maximum amount to spend
     *
     * In the case of 2 above. If we have to purchase a stable coin then we ask uniswap for outputToken.amount of the stable coin and specify amountInMaximum as the maximum amount to spend
     * Once we have the stablecoin, we deposit it all into curve to extract the lp tokens. If we don't need to purchase a stable coin, then we deposit outputToken.amount of ETH/WETH
     * to curve and mint the resulting tokens.
     */
    async purchase(spender, recipient, outputToken, amountInMaximum) {
        const uniswap = new Uniswap(this.provider);
        if (Uniswap.isSupportedAsset(outputToken.erc20Address)) {
            return await uniswap.swapFromEth(spender, recipient, outputToken, amountInMaximum);
        }
        const isMetaPool = await this.isMetaPool(outputToken.erc20Address);
        if (isMetaPool) {
            return await this.depositToMetaPool(spender, recipient, outputToken, amountInMaximum);
        }
        else {
            return await this.depositToStablePool(spender, recipient, outputToken, amountInMaximum);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9rZW5fc3RvcmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdG9rZW5zL3Rva2VuX3N0b3JlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDbEMsT0FBTyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUIsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUM5RSxPQUFPLEVBQUUsZUFBZSxFQUFFLFlBQVksRUFBRSxhQUFhLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDMUUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFMUQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsZUFBZSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLEdBQUcsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUV4Rjs7O0dBR0c7QUFDSCxNQUFNLE9BQU8sVUFBVTtJQU1yQixZQUE0QixRQUEwQjtRQUExQixhQUFRLEdBQVIsUUFBUSxDQUFrQjtRQUNwRCxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFTyxLQUFLLENBQUMsSUFBSTtRQUNoQixJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxRQUFRLENBQ2xDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUM1QyxXQUFXLENBQUMsR0FBRyxFQUNmLElBQUksQ0FBQyxjQUFjLENBQ3BCLENBQUM7UUFDRixNQUFNLGVBQWUsR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUNuRSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxRQUFRLENBQUMs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
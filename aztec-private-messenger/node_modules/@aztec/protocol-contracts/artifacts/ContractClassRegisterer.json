{
  "transpiled": true,
  "noir_version": "1.0.0-beta.3+0000000000000000000000000000000000000000",
  "name": "ContractClassRegisterer",
  "functions": [
    {
      "name": "assert_class_id_is_registered",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "7ZXNboQgFIXfhbULLn+Cr9I0E39wQmLUoDZpzLx7GQPFtthZTTILd/dyP+45OSxYUaOr5XoxfTtMqHhbUTfU5WyG3nUrArqdTWPZ39tpLu2MCsJZniHdN64UQG4Zak2nUQGE3rK/NGE40EREWrEETLHiHqYg5P8wcMWZp129w4mElBMgIjgBxiOtZGo7FTQsZ4B/0O8ZAnZGcxQNP6M5ikac0RxFkyejYRJiNPRBNAyE8jQjOBoS+aYgn66gUgoqV9LfUZJGBZ5MCdNvBVdLsZdIPUGu4htI8tsRwa/lyDWVNV1nrpf9T+OOP0pryqrTvm2Xvt5N588xTML90Q61bhar75u2mVv/BQ==",
      "brillig_names": [],
      "verification_key": "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"
    },
    {
      "name": "broadcast_private_function",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "artifact_metadata_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "unconstrained_functions_artifact_tree_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "private_function_tree_sibling_path",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "private_function_tree_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_sibling_path",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "function_data",
            "type": {
              "kind": "struct",
              "path": "events::private_function_broadcasted::InnerPrivateFunction",
              "fields": [
                {
                  "name": "selector",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "metadata_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "vk_hash",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "load",
        "debug_log_oracle_wrapper",
        "unsafe_padded_array_length",
        "notify_created_contract_class_log"
      ],
      "verification_key": "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"
    },
    {
      "name": "sync_notes",
      "is_unconstrained": true,
      "custom_attributes": [
        "aztec::macros::functions::utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "2588366281349374274": {
            "error_kind": "fmtstring",
            "length": 136,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "2709101749560550278": {
            "error_kind": "string",
            "string": "Cannot serialize point at infinity as bytes."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3367683922240523006": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "3473764466780631008": {
            "error_kind": "fmtstring",
            "length": 106,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5533887251808526417": {
            "error_kind": "fmtstring",
            "length": 120,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "5870202753060865374": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6753155520859132764": {
            "error_kind": "string",
            "string": "Failed to deliver note"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8830323656616886390": {
            "error_kind": "string",
            "string": "Got a public log emitted by a different contract"
          },
          "12099279057757775880": {
            "error_kind": "string",
            "string": "DST_LEN too large for offset"
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14514982005979867414": {
            "error_kind": "string",
            "string": "attempt to bit-shift with overflow"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15366650908120444287": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "16775516380094354375": {
            "error_kind": "fmtstring",
            "length": 40,
            "item_types": []
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "sync_notes"
      ]
    },
    {
      "name": "register",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "artifact_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "private_functions_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "public_bytecode_commitment",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "load",
        "notify_created_nullifier_oracle_wrapper",
        "debug_log_oracle_wrapper",
        "unsafe_padded_array_length",
        "notify_created_contract_class_log",
        "directive_integer_quotient",
        "directive_invert"
      ],
      "verification_key": "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"
    },
    {
      "name": "broadcast_unconstrained_function",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "num_txs",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "contract_class_id",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::contract_class_id::ContractClassId",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "artifact_metadata_hash",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "private_functions_artifact_tree_root",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_sibling_path",
            "type": {
              "kind": "array",
              "length": 5,
              "type": {
                "kind": "field"
              }
            },
            "visibility": "private"
          },
          {
            "name": "artifact_function_tree_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "function_data",
            "type": {
              "kind": "struct",
              "path": "events::unconstrained_function_broadcasted::InnerUnconstrainedFunction",
              "fields": [
                {
                  "name": "selector",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "metadata_hash",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "max_block_number",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::max_block_number::MaxBlockNumber",
                  "fields": [
                    {
                      "name": "_opt",
                      "type": {
                        "kind": "struct",
                        "path": "std::option::Option",
                        "fields": [
                          {
                            "name": "_is_some",
                            "type": {
                              "kind": "boolean"
                            }
                          },
                          {
                            "name": "_value",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                    "fields": [
                      {
                        "name": "request",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                          "fields": [
                            {
                              "name": "pk_m",
                              "type": {
                                "kind": "struct",
                                "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                "fields": [
                                  {
                                    "name": "x",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "y",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "is_infinite",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "sk_app_generator",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "note_hash",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "array",
                  "length": 5,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                    "fields": [
                      {
                        "name": "call_context",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::call_context::CallContext",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "function_selector",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "args_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "returns_hash",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "start_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "end_side_effect_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                          "fields": [
                            {
                              "name": "msg_sender",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "contract_address",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "is_static_call",
                              "type": {
                                "kind": "boolean"
                              }
                            },
                            {
                              "name": "calldata_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "array",
                  "length": 2,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                    "fields": [
                      {
                        "name": "recipient",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::eth_address::EthAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "array",
                  "length": 16,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                    "fields": [
                      {
                        "name": "log",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::log::Log",
                          "fields": [
                            {
                              "name": "fields",
                              "type": {
                                "kind": "array",
                                "length": 18,
                                "type": {
                                  "kind": "field"
                                }
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "note_hash_counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "array",
                  "length": 1,
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::log_hash::LogHash",
                    "fields": [
                      {
                        "name": "value",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "counter",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      },
                      {
                        "name": "length",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "num_txs",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "16761564377371454734": {
            "error_kind": "string",
            "string": "Array index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "brillig_names": [
        "load",
        "debug_log_oracle_wrapper",
        "unsafe_padded_array_length",
        "notify_created_contract_class_log"
      ],
      "verification_key": "AAAAAAAEAAAAAAAAAAAAEgAAAAAAAAAQAAAAAAAAVgkBAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAAAAAAAAAAAAAKs147ZBySsWnh2bYiHh70K29ylq1JNWNOnda2mjS6cwnFIunAe/NdJF/TmFpbrowhQiKzvGwimbSPnMG1x2fJRcdJuq5enUuPgm8iAO2WCagsVitRs9CZ+fMyZFBiZ4BGXaGGqLFk0agu1OBffROaH9RjUPHGWWJ3uZ0jCPdVM4PsBPiZoA1laLwV4+KPI+ldmEA8vfltyVsENQWOaJrayWmTGmJrs2xu5fwQR8uUexIUlBfVvhvD8R4tO4anWDwJTEapXAt/ULCnW261RbunLRtzQHqpcnlVg/G85OWJ7gKJ6V0j8jWHhc8DpJB6Zg8nSiFGeV1d2zp3qY0wMiXbAfX3jLnyWiPILeTlcUHV1AyV9EJ5fndrJpzUkggpJEVCyWX75zeXfJpMfYNefOp3R9lO5od4vOHyXcADKK5W/0Eec0YIUPTsIzqf5vIphevKgtQXdgZMgeMYGXglOkw2i23THmEZyqYN6S3WmlSy/CX3m53uGQnxDr4Fh0FSyM2IuSmLVifXcWOAD4X0sKeZqqcjXq3WBuYEO2nPlPhfd8OP4PTyf+mJHwLpRXOLm9SrLCVbfb6d5ltuCSwof5icCmMMxH8kXD5LelAsEKquZDVPGo7JjOc2mtz35IIMUFZB7BfQIphKEclkBa5IErkvzdTfrGWsFwdmPpRAWqbrLspxDPKNP9idyVDlH0HGQd2Cjp+IseXhOtM05rm8+dYrSAvDOxEsk4nnSGotsgQOeVfSE0cNOgk8fSnzI7PJth/EXQQK1l/+2VmTa/YOqwszW0Wte8OxBbpW0gBhISgNIkJtjKAhRYi2VPDtozMx1Hs/pz0+laMGyX/PHZpCTOmDyHrSJuRmKhkLL92LlSOA5ve52T8+85x9jwkt2+sZv9oEf1BtfmTbZMquuTG6TPg05wk6o4uDu5wKlMm81nJR8ALK0d7qPu4eemRvD4bP47YIaa+8G6YCH0ZiWhg09tSXw5tJXTI2qxjVV6qDUcFC5rRDkzSJHe2Gtcb3eZxFXmfJlZdhXIwD/hc74VObe2NqJy1bci0f2jdAwmcRXNZw2YK7YacVWaGfeaW+eVc1EibLyVHLAHzviBOtcDjlhd2vS41OFCvyimCu7i23iIxqzsf6olJUZ9KMkH73ju1GDJ3AW3qLky5DjbnMCzvKlOGGOInfYbKhZz++3wOqw3TVRkQM820Au2Rg/IoVKYLdE2pGC1AcuaC+it3F30gPebNUQH0nS5yN7Jk/1jZOEra4vK8d7QMS5NY/QRUfR0M4SuOIFtljX+LVZODMGkaoqng27SvGpuBFQf65qlyAZ5AHz4ILWVX5a96ernJ62/1Eb3eJdYaPQFPaZwIHLFMum99eRvbvxSjCKRWsO9yMGZJ/6OiOkIV4WRTg+rMEnT6gyQIHRu5u7gjfrf0w0kxc6soqr4Wv+2wlcc6brkfN27nweMuUJPbmiaZ+OBs3zdBw7blgSGKVUX5LP4jFg+3a2Nqqx/4sdEVS8zeRIBFREPou8rC7YfYrTQH4Tb6B/BD4XmiI1BCKENU1DnwKWSY6bX6SGuTyDcB6E/ki6eHFTQDWpcDYPeGi6veV0J3YY5DQmqFs61fiV/9y3pyr7chwrGVKB/yydOtXvoLHtjEgP+18hP4muBBGUWJa8XOg3dXa1ULC58NRNLpWpFAQGbX6SDScqyQDaCm7yBXM2UbSOf/UHUS/Jv/U6mjHRJg2jS0LXuXeNwZSZhiwkPu0TzGGl0bRx79GdNEyHt4pP8p53X7s4oGwmZwREfUyTNx3U4Cb+FaI0LuPvp4C/Y7lVper6jRF9Nk49fzuMGptqCJ8a94MO4OKojwCqn0AiH93S91W6/xQKb1nMKB8XHjQgBmezcPQgrcicSNdbVxY29bvrSoBvb0WWICMBtq5OsOu+rdIDNABm8oE1dI8RljHD/gf6nXAANOPidFTvmStL+EuXuqdHEuJXg1Ud9QwATsfNH03Ys7ZKZvKsSXm2XlZWjFoxsU7Rj3bPDO7MtHmN50GuibZOglj4RHfBtiVlpVm6e7OIMuLSmftoZ40BULzFsW3IJSNT1D+nDpkjnBwcZ+JxoO6sUV06xaGZq7dJM6TvyYxZsoFO3nzSfa7QDDPBKGC8SwRi041tS6Hkdjp07NsRyh80aWgMJw5VFRU0RZL1kYj6dlEts56JKCazJhDuCCUeAF/OkXwNXcoBlHfFL2B1MythIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLPhdtW9mlsaR/rzb/AQUsxPqijDf4LBHq4+1KX5loAcBV/VVyOd6196hGISxqVf/zt6ao8vmxfod8mMO47yRVQDENyb3W2/aDeIs4ODfq2vMegX/lalrKJQkxfczZw2WL5tuC04sAZaN5cMkgqp9HQoJ1xeOyTuteFj5bmTwtI0dWKphxkrVIgQ9ecSAIhnlW6GXUa3+bDYyTT+2wtoJiS18GKk8Pa5YgJ+q7saoanj0s7xh8Z1ucGk1m79H5/kH"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "1752556835457866331": {
            "error_kind": "string",
            "string": "No public functions"
          }
        }
      },
      "bytecode": "JwAABAEqAAABBRhSVSgKJhpbPAABAA==",
      "debug_symbols": "XYxLCoAwDAXvkrUn8Coi0k9aAqEpsRWk9O5+cCFdzhveNPBoa9woBdlhXhqwOFNI0k2tT2CVmCluw3wYJWMZPww1uZ8tZ8bhn1Uc+qr4lF7X134B",
      "brillig_names": [
        "public_dispatch"
      ]
    }
  ],
  "outputs": {
    "globals": {},
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "artifact_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "private_functions_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "public_bytecode_commitment",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegisterer::register_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegisterer::register_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "artifact_metadata_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "unconstrained_functions_artifact_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "private_function_tree_sibling_path",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "private_function_tree_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "artifact_function_tree_sibling_path",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "artifact_function_tree_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "function_data",
                    "type": {
                      "fields": [
                        {
                          "name": "selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "metadata_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "vk_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "events::private_function_broadcasted::InnerPrivateFunction"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegisterer::broadcast_private_function_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegisterer::broadcast_private_function_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  },
                  {
                    "name": "artifact_metadata_hash",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "private_functions_artifact_tree_root",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "artifact_function_tree_sibling_path",
                    "type": {
                      "kind": "array",
                      "length": 5,
                      "type": {
                        "kind": "field"
                      }
                    }
                  },
                  {
                    "name": "artifact_function_tree_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "function_data",
                    "type": {
                      "fields": [
                        {
                          "name": "selector",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::abis::function_selector::FunctionSelector"
                          }
                        },
                        {
                          "name": "metadata_hash",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "events::unconstrained_function_broadcasted::InnerUnconstrainedFunction"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegisterer::broadcast_unconstrained_function_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegisterer::broadcast_unconstrained_function_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "contract_class_id",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::contract_class_id::ContractClassId"
                    }
                  }
                ],
                "kind": "struct",
                "path": "ContractClassRegisterer::assert_class_id_is_registered_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "ContractClassRegisterer::assert_class_id_is_registered_abi"
        }
      ]
    }
  },
  "file_map": {
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::{\n    discovery::private_notes::MAX_NOTE_PACKED_LEN,\n    macros::{\n        dispatch::generate_public_dispatch,\n        functions::{\n            stub_registry,\n            utils::{check_each_fn_macroified, create_message_discovery_call},\n        },\n        notes::{generate_note_export, NOTES},\n        storage::STORAGE_LAYOUT_NAME,\n        utils::{get_trait_impl_method, module_has_storage},\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_notes` utility function PXE requires in order to discover notes.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    let contract_library_method_compute_note_hash_and_nullifier =\n        generate_contract_library_method_compute_note_hash_and_nullifier();\n    let note_exports = generate_note_exports();\n    let public_dispatch = generate_public_dispatch(m);\n    let sync_notes = generate_sync_notes();\n\n    quote {\n        $note_exports\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_notes\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    let notes = NOTES.entries();\n\n    if notes.len() > 0 {\n        let max_note_packed_len = notes.fold(\n            0,\n            |acc, (_, (_, len, _, _)): (Type, (TypeDefinition, u32, Field, [(Quoted, u32, bool)]))| {\n                if len > acc {\n                    len\n                } else {\n                    acc\n                }\n            },\n        );\n\n        if max_note_packed_len > MAX_NOTE_PACKED_LEN {\n            panic(\n                f\"One of the notes has packed len {max_note_packed_len} but the maximum is {MAX_NOTE_PACKED_LEN}\",\n            );\n        }\n\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..notes.len() {\n            let (typ, (_, packed_note_length, _, _)) = notes[i];\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable<_> },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret it's raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = $packed_note_length;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(nonce).into() \n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_note_exports() -> Quoted {\n    let notes = NOTES.values();\n    // Second value in each tuple is `note_packed_len` and that is ignored here because it's only used when\n    // generating partial note helper functions.\n    notes\n        .map(|(s, _, note_type_id, fields): (TypeDefinition, u32, Field, [(Quoted, u32, bool)])| {\n            generate_note_export(s, note_type_id, fields)\n        })\n        .join(quote {})\n}\n\ncomptime fn generate_sync_notes() -> Quoted {\n    let message_discovery_call = create_message_discovery_call();\n\n    // TODO(https://github.com/noir-lang/noir/issues/7912): Doing the following unfortunately doesn't work. Once\n    // the issue is fixed uncomment the following and remove the workaround from TS (look for the issue link in the\n    // codebase).\n    // let utility: fn(FunctionDefinition) -> () = crate::macros::functions::utility;\n    // quote {\n    //     #[$utility]\n    //     unconstrained fn sync_notes() {\n    //         $message_discovery_call\n    //     }\n    // }\n\n    quote {\n        #[aztec::macros::functions::utility]\n        unconstrained fn sync_notes() {\n            $message_discovery_call\n        }\n    }\n}\n"
    },
    "123": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, &[], false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T, let N: u32>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize<N>,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T, let N: u32>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize<N>,\n{\n    let serialized_option = load_oracle::<N>(contract_address, slot, N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(storeCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(loadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(deleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(copyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    unconstrained fn setup() -> AztecAddress {\n        let env = TestEnvironment::new();\n        env.contract_address()\n    }\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), value);\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n\n        let new_value = MockStruct::new(7, 8);\n        store(contract_address, SLOT, new_value);\n\n        assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let contract_address = setup();\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let contract_address = setup();\n\n        let value = MockStruct::new(5, 6);\n        store(contract_address, SLOT, value);\n        delete(contract_address, SLOT);\n\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let contract_address = setup();\n\n        delete(contract_address, SLOT);\n        let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n        assert_eq(loaded_value, Option::none());\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let contract_address = setup();\n\n        let src = 5;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 10;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let contract_address = setup();\n\n        let src = 1;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 2;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n        assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n        assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let contract_address = setup();\n\n        let src = 2;\n\n        let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n        store(contract_address, src, values[0]);\n        store(contract_address, src + 1, values[1]);\n        store(contract_address, src + 2, values[2]);\n\n        let dst = 1;\n        copy(contract_address, src, dst, 3);\n\n        assert_eq(load(contract_address, dst).unwrap(), values[0]);\n        assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n        assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n        // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n        assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n        assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n        assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let contract_address = setup();\n\n        copy(contract_address, SLOT, SLOT, 1);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let value = MockStruct::new(5, 6);\n        store(other_contract_address, SLOT, value);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        let _: Option<MockStruct> = load(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        delete(other_contract_address, SLOT);\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let contract_address = setup();\n        let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n        copy(other_contract_address, SLOT, SLOT, 0);\n    }\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/logs.nr",
      "source": "use crate::discovery::MAX_LOG_CONTENT_LEN;\nuse protocol_types::{abis::event_selector::EventSelector, address::AztecAddress};\n\n/// The below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\npub unconstrained fn notify_created_contract_class_log<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {\n    notify_created_contract_class_log_private_oracle(contract_address, message, counter)\n}\n\n#[oracle(notifyCreatedContractClassLog)]\nunconstrained fn notify_created_contract_class_log_private_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    message: [Field; N],\n    counter: u32,\n) {}\n\npub unconstrained fn store_private_event_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n) {\n    store_private_event_log_oracle(\n        contract_address,\n        recipient,\n        event_selector,\n        log_content,\n        tx_hash,\n        log_index_in_tx,\n    )\n}\n\n#[oracle(storePrivateEventLog)]\nunconstrained fn store_private_event_log_oracle(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    event_selector: EventSelector,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n    tx_hash: Field,\n    log_index_in_tx: Field,\n) {}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_discovery.nr",
      "source": "use crate::discovery::private_notes::MAX_NOTE_PACKED_LEN;\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::{MAX_NOTE_HASHES_PER_TX, PUBLIC_LOG_DATA_SIZE_IN_FIELDS},\n};\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn sync_notes(pending_tagged_log_array_base_slot: Field) {\n    sync_notes_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(syncNotes)]\nunconstrained fn sync_notes_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n/// Informs PXE of a note's existence so that it can later be retrieved by the `getNotes` oracle. The note will be\n/// scoped to `contract_address`, meaning other contracts will not be able to access it unless authorized.\n///\n/// The packed note is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\n///\n/// Returns true if the note was successfully delivered and added to PXE's database.\npub unconstrained fn deliver_note(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {\n    deliver_note_oracle(\n        contract_address,\n        storage_slot,\n        nonce,\n        packed_note,\n        note_hash,\n        nullifier,\n        tx_hash,\n        recipient,\n    )\n}\n\n/// The contents of a public log, plus contextual information about the transaction in which the log was emitted. This\n/// is the data required in order to discover notes that are being delivered in a log.\n// TODO(#11639): this could also be used to fetch private logs, but the `BoundedVec` maximum length is that of a public\n// log.\npub struct LogWithTxData {\n    pub log_content: BoundedVec<Field, PUBLIC_LOG_DATA_SIZE_IN_FIELDS>,\n    pub tx_hash: Field,\n    /// The array of new note hashes created by `tx_hash`\n    pub unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    /// The first nullifier created by `tx_hash`\n    pub first_nullifier_in_tx: Field,\n}\n\n/// Fetches a log from the node that has the corresponding `tag`. The log can be either a public or a private log, and\n/// the tag is the first field in the log's content. Returns `Option::none` if no such log exists. Throws if more than\n/// one log with that tag exists.\n/// Public logs have an extra field included at the beginning with the address of the contract that emitted them.\n// TODO(#11627): handle multiple logs with the same tag.\n// TODO(#10273): improve contract siloing of logs, don't introduce an extra field.\npub unconstrained fn get_log_by_tag(tag: Field) -> Option<LogWithTxData> {\n    get_log_by_tag_oracle(tag)\n}\n\n#[oracle(deliverNote)]\nunconstrained fn deliver_note_oracle(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) -> bool {}\n\n#[oracle(getLogByTag)]\nunconstrained fn get_log_by_tag_oracle(tag: Field) -> Option<LogWithTxData> {}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::{\n    note::{note_interface::NoteType, note_metadata::NoteMetadata, retrieved_note::RetrievedNote},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    indexed_tagging_secret::IndexedTaggingSecret,\n    traits::{FromField, Packable},\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(notifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(notifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(notifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(getNotes)]\nunconstrained fn get_notes_oracle<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; N],\n    _select_by_offsets: [u8; N],\n    _select_by_lengths: [u8; N],\n    _select_values: [Field; N],\n    _select_comparators: [u8; N],\n    _sort_by_indexes: [u8; N],\n    _sort_by_offsets: [u8; N],\n    _sort_by_lengths: [u8; N],\n    _sort_order: [u8; N],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    _return_size: u32,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {}\n\nunconstrained fn get_notes_oracle_wrapper<let N: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; N],\n    select_by_offsets: [u8; N],\n    select_by_lengths: [u8; N],\n    select_values: [Field; N],\n    select_comparators: [u8; N],\n    sort_by_indexes: [u8; N],\n    sort_by_offsets: [u8; N],\n    sort_by_lengths: [u8; N],\n    sort_order: [u8; N],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Field; ORACLE_RETURN_FIELD_LENGTH] {\n    // This wrapper exists to extract the ORACLE_RETURN_FIELD_LENGTH generic numeric param into a value and pass it to\n    // the oracle, so that it knows how big the return array must be.\n    get_notes_oracle(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n        ORACLE_RETURN_FIELD_LENGTH,\n    )\n}\n\npub unconstrained fn get_notes<Note, let N: u32, let M: u32, let MAX_NOTES: u32, let ORACLE_RETURN_FIELD_LENGTH: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n    _placeholder_fields: [Field; ORACLE_RETURN_FIELD_LENGTH], // TODO: Compute this value automatically from MAX_NOTES\n) -> [Option<RetrievedNote<Note>>; MAX_NOTES]\nwhere\n    Note: NoteType + Packable<N>,\n{\n    let fields: [_; ORACLE_RETURN_FIELD_LENGTH] = get_notes_oracle_wrapper(\n        storage_slot,\n        num_selects,\n        select_by_indexes,\n        select_by_offsets,\n        select_by_lengths,\n        select_values,\n        select_comparators,\n        sort_by_indexes,\n        sort_by_offsets,\n        sort_by_lengths,\n        sort_order,\n        limit,\n        offset,\n        status,\n    );\n    let num_notes = fields[0] as u32;\n    let contract_address = AztecAddress::from_field(fields[1]);\n\n    let mut opt_notes = [Option::none(); MAX_NOTES];\n    for i in 0..opt_notes.len() {\n        if i < num_notes {\n            // lengths named as per typescript.\n            let return_header_length: u32 = 2; // num_notes & contract_address.\n            let extra_preimage_length: u32 = 2; // nonce & note_hash_counter.\n            let read_offset: u32 = return_header_length + i * (N + extra_preimage_length);\n\n            let maybe_nonce = fields[read_offset];\n            let maybe_note_hash_counter = fields[read_offset + 1] as u32;\n            let packed_note = array::subarray(fields, read_offset + 2);\n\n            let note = Note::unpack(packed_note);\n            let retrieved_note = RetrievedNote {\n                note,\n                contract_address,\n                metadata: NoteMetadata::from_raw_data(maybe_note_hash_counter != 0, maybe_nonce),\n            };\n\n            opt_notes[i] = Option::some(retrieved_note);\n        };\n    }\n    opt_notes\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(checkNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(getIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(incrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n"
    },
    "161": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(getSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "187": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends two `BoundedVec`s together, returning one that contains all of the elements of the first one followed by all\n/// of the elements of the second one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let A_LEN: u32, let B_LEN: u32, let DST_LEN: u32>(\n    a: BoundedVec<T, A_LEN>,\n    b: BoundedVec<T, B_LEN>,\n) -> BoundedVec<T, DST_LEN> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "189": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/mod.nr",
      "source": "pub mod append;\npub mod collapse;\npub mod subarray;\npub mod subbvec;\n\npub use append::append;\npub use collapse::collapse;\npub use subarray::subarray;\npub use subbvec::subbvec;\n\n// This will eventually be replaced by `BoundedVec::for_each`, once that's implemented.\npub unconstrained fn for_each_in_bounded_vec<T, let MaxLen: u32, Env>(\n    vec: BoundedVec<T, MaxLen>,\n    f: fn[Env](T, u32) -> (),\n) {\n    for i in 0..vec.len() {\n        f(vec.get_unchecked(i), i);\n    }\n}\n"
    },
    "190": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DST_LEN` elements from a source array, starting at `offset`. `DST_LEN` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [T; SRC_LEN],\n    offset: u32,\n) -> [T; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"DST_LEN too large for offset\");\n\n    let mut dst: [T; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DST_LEN to be 0, so we always get back an emtpy array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "191": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DST_MAX_LEN` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DST_LEN` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DST_LEN` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SRC_MAX_LEN: u32, let DST_MAX_LEN: u32>(\n    bvec: BoundedVec<T, SRC_MAX_LEN>,\n    offset: u32,\n) -> BoundedVec<T, DST_MAX_LEN> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DST_LEN too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "193": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "194": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "196": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "198": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "218": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/event_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl Eq for EventSelector {\n    fn eq(self, other: EventSelector) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for EventSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for EventSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "24": {
      "path": "std/hash/poseidon2.nr",
      "source": "use crate::default::Default;\nuse crate::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "272": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_class_id.nr",
      "source": "use crate::constants::GENERATOR_INDEX__CONTRACT_LEAF;\nuse crate::traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField};\n\npub struct ContractClassId {\n    pub inner: Field,\n}\n\nimpl Eq for ContractClassId {\n    fn eq(self, other: ContractClassId) -> bool {\n        other.inner == self.inner\n    }\n}\n\nimpl ToField for ContractClassId {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for ContractClassId {\n    fn from_field(value: Field) -> Self {\n        Self { inner: value }\n    }\n}\n\nimpl Serialize<1> for ContractClassId {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<1> for ContractClassId {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] }\n    }\n}\n\nimpl Empty for ContractClassId {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n// Implement the Packable trait so ContractClassId can be stored in contract's storage.\nimpl Packable<1> for ContractClassId {\n    fn pack(self) -> [Field; 1] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; 1]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl ContractClassId {\n    pub fn compute(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) -> Self {\n        let hash = crate::hash::poseidon2_hash_with_separator(\n            [artifact_hash, private_functions_root, public_bytecode_commitment],\n            GENERATOR_INDEX__CONTRACT_LEAF,\n        ); // TODO(@spalladino): Update generator index\n        ContractClassId::from_field(hash)\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "280": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(debugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "281": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as std::hash::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = std::hash::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = std::hash::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n"
    },
    "295": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `omit`: A list of field names (as `Quoted`) to be excluded from the serialized output.\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, &[], false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, &[], false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], &[], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, &[], false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with Omitted Field and packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// Serializing while omitting `value2`:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, MyStruct, &[quote { self.value2 }], true)\n/// // Returns:\n/// // ([`value_packed[0]`], [`let value_packed = self.value.pack()`])\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    omit: [Quoted],\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // Proceed if none of the omit rules omits this name\n    if !omit.any(|to_omit| to_omit == name) {\n        // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n        let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n        let packable_constraint =\n            quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n        if (should_pack & typ.implements(packable_constraint)) {\n            // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n            // method, add the resulting field array to `aux_vars` and each field to `fields`.\n            let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n            // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n            let name_at_one_token = collapse_to_one_token(name);\n            let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n            // We add the individual fields to the fields array\n            let pack_method = get_trait_impl_method(\n                typ,\n                quote { crate::traits::Packable<$packed_len> },\n                quote { pack },\n            );\n            let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n            for i in 0..packed_len {\n                fields = fields.push_back(quote { $packed_struct_name[$i] });\n            }\n\n            // We add the new auxiliary variable to the aux_vars array\n            aux_vars = aux_vars.push_back(packed_struct);\n        } else if typ.is_field() {\n            // For field we just add the value to fields\n            fields = fields.push_back(name);\n        } else if typ.as_integer().is_some() | typ.is_bool() {\n            // For integer and bool we just cast to Field and add the value to fields\n            fields = fields.push_back(quote { $name as Field });\n        } else if typ.as_data_type().is_some() {\n            // For struct we pref\n            let nested_struct = typ.as_data_type().unwrap();\n            let params = nested_struct.0.fields(nested_struct.1);\n            let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n                let maybe_prefixed_name = if name == quote {} {\n                    // Triggered when the param name is of a value available in the current scope (e.g. a function\n                    // argument) --> then we don't prefix the name with anything.\n                    param_name\n                } else {\n                    // Triggered when we want to prefix the param name with the `name` from function input. This\n                    // can typically be `self` when implementing a method on a struct.\n                    quote { $name.$param_name }\n                };\n                generate_serialize_to_fields(\n                    quote {$maybe_prefixed_name},\n                    param_type,\n                    omit,\n                    should_pack,\n                )\n            });\n            let struct_flattened_fields = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n            );\n            let struct_flattened_aux_vars = struct_flattened.fold(\n                &[],\n                |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n            );\n            fields = fields.append(struct_flattened_fields);\n            aux_vars = aux_vars.append(struct_flattened_aux_vars);\n        } else if typ.as_array().is_some() {\n            // For array we recursively call `generate_serialize_to_fields(...)` for each element\n            let (element_type, array_len) = typ.as_array().unwrap();\n            let array_len = array_len.as_constant().unwrap();\n            for i in 0..array_len {\n                let (element_fields, element_aux_vars) = generate_serialize_to_fields(\n                    quote { $name[$i] },\n                    element_type,\n                    omit,\n                    should_pack,\n                );\n                fields = fields.append(element_fields);\n                aux_vars = aux_vars.append(element_aux_vars);\n            }\n        } else if typ.as_str().is_some() {\n            // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n            // then we add each byte to fields as a Field\n            let length_type = typ.as_str().unwrap();\n            let str_len = length_type.as_constant().unwrap();\n            let as_member = name.as_expr().unwrap().as_member_access();\n            let var_name = if as_member.is_some() {\n                as_member.unwrap().1\n            } else {\n                name\n            };\n            let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n            let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n            for i in 0..str_len {\n                fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n            }\n            aux_vars = aux_vars.push_back(as_bytes);\n        } else {\n            panic(\n                f\"Unsupported type for serialization of argument {name} and type {typ}\",\n            )\n        }\n    }\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, &[], false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) =\n        generate_serialize_to_fields(quote { self }, typ, &[], packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n"
    },
    "298": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\n\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "332": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty {\n    fn empty() -> Self;\n}\n\nimpl Empty for Field {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n}\n\nimpl<T> Empty for Option<T> {\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\npub fn is_empty<T>(item: T) -> bool\nwhere\n    T: Empty + Eq,\n{\n    item.eq(T::empty())\n}\n\npub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\nwhere\n    T: Empty + Eq,\n{\n    array.all(|elem| is_empty(elem))\n}\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    fn from_field(value: Field) -> Self {\n        value as bool\n    }\n}\nimpl FromField for u1 {\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u32 {\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Type Parameters\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize<N> for str<N> {\n///     fn serialize(self) -> [Field; N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize<let N: u32> {\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let N: u32> Serialize<N> for str<N> {\n    fn serialize(self) -> [Field; N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Type Parameters\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Deserialize<N> for str<N> {\n///     fn deserialize(fields: [Field; N]) -> Self {\n///         str<N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize<let N: u32> {\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let N: u32> Deserialize<N> for str<N> {\n    fn deserialize(fields: [Field; N]) -> Self {\n        str<N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Type Parameters\n/// * `N` - The length of the Field array, known at compile time.\n#[derive_via(derive_packable)]\npub trait Packable<let N: u32> {\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n"
    },
    "337": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n"
    },
    "353": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/arrays.nr",
      "source": "pub mod assert_array_appended;\npub mod assert_array_prepended;\npub mod assert_combined_array;\npub mod assert_combined_transformed_array;\npub mod assert_exposed_sorted_transformed_value_array;\npub mod assert_sorted_array;\npub mod assert_sorted_transformed_value_array;\npub mod assert_split_sorted_transformed_value_arrays;\npub mod assert_split_transformed_value_arrays;\npub mod get_sorted_result;\npub mod get_sorted_tuple;\npub mod sort_by;\npub mod sort_by_counter;\n\n// Re-exports.\npub use assert_array_appended::{\n    assert_array_appended, assert_array_appended_and_scoped, assert_array_appended_reversed,\n    assert_array_appended_scoped,\n};\npub use assert_array_prepended::assert_array_prepended;\npub use assert_combined_array::{assert_combined_array, combine_arrays};\npub use assert_combined_transformed_array::{\n    assert_combined_transformed_array, combine_and_transform_arrays,\n};\npub use assert_exposed_sorted_transformed_value_array::{\n    assert_exposed_sorted_transformed_value_array,\n    get_order_hints::{get_order_hints_asc, get_order_hints_desc, OrderHint},\n};\npub use assert_sorted_array::assert_sorted_array;\npub use assert_sorted_transformed_value_array::{\n    assert_sorted_transformed_value_array, assert_sorted_transformed_value_array_capped_size,\n};\npub use assert_split_sorted_transformed_value_arrays::{\n    assert_split_sorted_transformed_value_arrays_asc,\n    assert_split_sorted_transformed_value_arrays_desc,\n    get_split_order_hints::{get_split_order_hints_asc, get_split_order_hints_desc, SplitOrderHints},\n};\npub use assert_split_transformed_value_arrays::assert_split_transformed_value_arrays;\npub use get_sorted_result::{get_sorted_result, SortedResult};\npub use sort_by_counter::{sort_by_counter_asc, sort_by_counter_desc};\n\nuse crate::traits::{Empty, is_empty};\n\npub fn subarray<let SRC_LEN: u32, let DST_LEN: u32>(\n    src: [Field; SRC_LEN],\n    offset: u32,\n) -> [Field; DST_LEN] {\n    assert(offset + DST_LEN <= SRC_LEN, \"offset too large\");\n\n    let mut dst: [Field; DST_LEN] = std::mem::zeroed();\n    for i in 0..DST_LEN {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\n// Helper function to convert a validated array to BoundedVec.\n// Important: Only use it for validated arrays: validate_array(array) should be true.\npub unconstrained fn array_to_bounded_vec<T, let N: u32>(array: [T; N]) -> BoundedVec<T, N>\nwhere\n    T: Empty + Eq,\n{\n    let len = array_length(array);\n    BoundedVec::from_parts_unchecked(array, len)\n}\n\n// Helper function to find the index of the first element in an array that satisfies a given predicate. If the element\n// is not found, the function returns N as the index.\npub unconstrained fn find_index_hint<T, let N: u32, Env>(\n    array: [T; N],\n    find: fn[Env](T) -> bool,\n) -> u32 {\n    let mut index = N;\n    for i in 0..N {\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & find(array[i]) {\n            index = i;\n        }\n    }\n    index\n}\n\n// Routine which validates that all zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where any * is non-zero. Note that a full array of non-zero values is\n// valid.\npub fn validate_array<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut seen_empty = false;\n    let mut length = 0;\n    for i in 0..N {\n        if is_empty(array[i]) {\n            seen_empty = true;\n        } else {\n            assert(seen_empty == false, \"invalid array\");\n            length += 1;\n        }\n    }\n    length\n}\n\n// Helper function to count the number of non-empty elements in a validated array.\n// Important: Only use it for validated arrays where validate_array(array) returns true,\n// which ensures that:\n// 1. All elements before the first empty element are non-empty\n// 2. All elements after and including the first empty element are empty\n// 3. The array forms a contiguous sequence of non-empty elements followed by empty elements\npub fn array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // We get the length by checking the index of the first empty element.\n\n    // Safety: This is safe because we have validated the array (see function doc above) and the emptiness\n    // of the element and non-emptiness of the previous element is checked below.\n    let length = unsafe { find_index_hint(array, |elem: T| is_empty(elem)) };\n    if length != 0 {\n        assert(!is_empty(array[length - 1]));\n    }\n    if length != N {\n        assert(is_empty(array[length]));\n    }\n    length\n}\n\npub fn array_concat<T, let N: u32, let M: u32>(array1: [T; N], array2: [T; M]) -> [T; N + M] {\n    let mut result = [array1[0]; N + M];\n    for i in 1..N {\n        result[i] = array1[i];\n    }\n    for i in 0..M {\n        result[i + N] = array2[i];\n    }\n    result\n}\n/// This function assumes that `array1` and `array2` contain no more than N non-empty elements between them,\n/// if this is not the case then elements from the end of `array2` will be dropped.\npub fn array_merge<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    // Safety: we constrain this array below\n    let result = unsafe { array_merge_helper(array1, array2) };\n    // We assume arrays have been validated. The only use cases so far are with previously validated arrays.\n    let array1_len = array_length(array1);\n    let mut add_from_left = true;\n    for i in 0..N {\n        add_from_left &= i != array1_len;\n        if add_from_left {\n            assert_eq(result[i], array1[i]);\n        } else {\n            assert_eq(result[i], array2[i - array1_len]);\n        }\n    }\n    result\n}\n\nunconstrained fn array_merge_helper<T, let N: u32>(array1: [T; N], array2: [T; N]) -> [T; N]\nwhere\n    T: Empty + Eq,\n{\n    let mut result: [T; N] = [T::empty(); N];\n    let mut i = 0;\n    for elem in array1 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    for elem in array2 {\n        if !is_empty(elem) {\n            result[i] = elem;\n            i += 1;\n        }\n    }\n    result\n}\n\n// Helper fn to create a subarray from a given array\npub fn array_splice<T, let N: u32, let M: u32>(array: [T; N], offset: u32) -> [T; M]\nwhere\n    T: Empty,\n{\n    assert(M + offset <= N, \"Subarray length larger than array length\");\n    let mut result: [T; M] = [T::empty(); M];\n    for i in 0..M {\n        result[i] = array[offset + i];\n    }\n    result\n}\n\npub fn check_permutation<T, let N: u32>(\n    original_array: [T; N],\n    permuted_array: [T; N],\n    original_indexes: [u32; N],\n)\nwhere\n    T: Eq + Empty,\n{\n    let mut seen_value = [false; N];\n    for i in 0..N {\n        let index = original_indexes[i];\n        let original_value = original_array[index];\n        assert(permuted_array[i].eq(original_value), \"Invalid index\");\n        assert(!seen_value[index], \"Duplicated index\");\n        seen_value[index] = true;\n    }\n}\n\n// Helper function to find the index of the last element in an array, allowing empty elements.\n// e.g. useful for removing trailing 0s from [1, 0, 2, 0, 0, 0] -> [1, 0, 2]\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn find_last_value_index<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let mut index = N;\n    for i in 0..N {\n        let j = N - i - 1;\n        // We check `index == N` to ensure that we only update the index if we haven't found a match yet.\n        if (index == N) & !is_empty(array[j]) {\n            index = j;\n        }\n    }\n    index\n}\n\n// Routine which returns the length of an array right padded by empty elements\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\n// See smoke_validate_array_trailing for examples.\n// Nothing to do with validated arrays. Correctness constrained by padded_array_length.\npub unconstrained fn unsafe_padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    let index = find_last_value_index(array);\n    if index == N {\n        0\n    } else {\n        index + 1\n    }\n}\n\n// Routine which validates that zero values of an array form a contiguous region at the end, i.e.,\n// of the form: [*,*,*...,0,0,0,0] where * is any value (zeroes allowed).\npub fn padded_array_length<T, let N: u32>(array: [T; N]) -> u32\nwhere\n    T: Empty + Eq,\n{\n    // Safety: this value is constrained in the below loop.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    // Check the elt just before length is non-zero:\n    if length != 0 {\n        assert(!is_empty(array[length - 1]), \"invalid right padded array\");\n    }\n    // Check all beyond length are zero:\n    let mut check_zero = false;\n    for i in 0..N {\n        check_zero |= i == length;\n        if check_zero {\n            assert(is_empty(array[i]), \"invalid right padded array\");\n        }\n    }\n    length\n}\n\n#[test]\nfn smoke_validate_array() {\n    let valid_array: [Field; 0] = [];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(validate_array(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(validate_array(valid_array) == 1);\n\n    let valid_array = [1, 2, 3];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0];\n    assert(validate_array(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(validate_array(valid_array) == 3);\n}\n\n#[test]\nfn smoke_validate_array_trailing() {\n    let valid_array: [Field; 0] = [];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [0];\n    assert(padded_array_length(valid_array) == 0);\n\n    let valid_array = [3];\n    assert(padded_array_length(valid_array) == 1);\n\n    let valid_array = [1, 0, 3];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 0, 3, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [1, 2, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n\n    let valid_array = [0, 0, 3, 0, 0];\n    assert(padded_array_length(valid_array) == 3);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case0() {\n    let invalid_array = [0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case1() {\n    let invalid_array = [1, 0, 0, 1, 0];\n    let _ = validate_array(invalid_array);\n}\n\n#[test(should_fail_with = \"invalid array\")]\nfn smoke_validate_array_invalid_case2() {\n    let invalid_array = [0, 0, 0, 0, 1];\n    let _ = validate_array(invalid_array);\n}\n\n#[test]\nfn test_empty_array_length() {\n    assert_eq(array_length([0]), 0);\n    assert_eq(array_length([0, 0, 0]), 0);\n}\n\n#[test]\nfn test_array_length() {\n    assert_eq(array_length([123]), 1);\n    assert_eq(array_length([123, 0, 0]), 1);\n    assert_eq(array_length([123, 456]), 2);\n    assert_eq(array_length([123, 456, 0]), 2);\n}\n\n#[test]\nfn test_array_length_invalid_arrays() {\n    // Result can be misleading (but correct) for invalid arrays.\n    assert_eq(array_length([0, 0, 123]), 0);\n    assert_eq(array_length([0, 123, 0]), 0);\n    assert_eq(array_length([0, 123, 456]), 0);\n    assert_eq(array_length([123, 0, 456]), 1);\n}\n\n#[test]\nunconstrained fn find_index_greater_than_min() {\n    let values = [10, 20, 30, 40];\n    let min = 22;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 2);\n}\n\n#[test]\nunconstrained fn find_index_not_found() {\n    let values = [10, 20, 30, 40];\n    let min = 100;\n    let index = find_index_hint(values, |v: Field| min.lt(v));\n    assert_eq(index, 4);\n}\n\n#[test]\nfn test_array_concat() {\n    let array0 = [1, 2, 3];\n    let array1 = [4, 5];\n    let concatenated = array_concat(array0, array1);\n    assert_eq(concatenated, [1, 2, 3, 4, 5]);\n}\n\n#[test]\nfn check_permutation_basic_test() {\n    let original_array = [1, 2, 3];\n    let permuted_array = [3, 1, 2];\n    let indexes = [2, 0, 1];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Duplicated index\")]\nfn check_permutation_duplicated_index() {\n    let original_array = [0, 1, 0];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 0];\n    check_permutation(original_array, permuted_array, indexes);\n}\n\n#[test(should_fail_with = \"Invalid index\")]\nfn check_permutation_invalid_index() {\n    let original_array = [0, 1, 2];\n    let permuted_array = [1, 0, 0];\n    let indexes = [1, 0, 2];\n    check_permutation(original_array, permuted_array, indexes);\n}\n"
    },
    "356": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "362": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "46": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "47": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n"
    },
    "58": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/contract_class_registerer_contract/src/main.nr",
      "source": "mod events;\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract ContractClassRegisterer {\n    use dep::aztec::protocol_types::{\n        abis::log_hash::LogHash,\n        constants::{\n            ARTIFACT_FUNCTION_TREE_MAX_HEIGHT, CONTRACT_CLASS_LOG_DATA_SIZE_IN_FIELDS,\n            FUNCTION_TREE_HEIGHT, MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS,\n            MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS,\n            MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS, REGISTERER_CONTRACT_BYTECODE_CAPSULE_SLOT,\n        },\n        contract_class_id::ContractClassId,\n        hash::poseidon2_hash,\n        utils::arrays::{array_concat, unsafe_padded_array_length},\n    };\n\n    use dep::aztec::{\n        context::PrivateContext, macros::functions::private,\n        oracle::logs::notify_created_contract_class_log,\n    };\n\n    use crate::events::{\n        class_registered::ContractClassRegistered,\n        private_function_broadcasted::{\n            ClassPrivateFunctionBroadcasted, InnerPrivateFunction, PrivateFunction,\n        },\n        unconstrained_function_broadcasted::{\n            ClassUnconstrainedFunctionBroadcasted, InnerUnconstrainedFunction,\n            UnconstrainedFunction,\n        },\n    };\n\n    use dep::aztec::protocol_types::traits::ToField;\n\n    // docs:start:import_capsules\n    use dep::aztec::oracle::capsules;\n    // docs:end:import_capsules\n\n    #[private]\n    fn register(\n        artifact_hash: Field,\n        private_functions_root: Field,\n        public_bytecode_commitment: Field,\n    ) {\n        // TODO: Validate public_bytecode_commitment is the correct commitment of packed_public_bytecode\n        // TODO: We should be able to remove public_bytecode_commitment from the input if it's calculated in this function\n        // docs:start:load_capsule\n        let packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS] = unsafe {\n            capsules::load(\n                context.this_address(),\n                REGISTERER_CONTRACT_BYTECODE_CAPSULE_SLOT,\n            )\n                .unwrap()\n        };\n        // docs:end:load_capsule\n        // First field element contains the length of the bytecode\n        let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n        let bytecode_length_in_fields: u32 =\n            (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n        // We don't allow registering classes with empty public bytecode.\n        // Since the AVM doesn't handle execution of empty bytecode at the moment.\n        assert(bytecode_length_in_fields != 0);\n        assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n        // The first value in the running hash is the bytecode length in bytes\n        let mut computed_public_bytecode_commitment = packed_public_bytecode[0];\n        // We can hash up to MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS - 1, since the first element is the length\n        for i in 0..(MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS - 1) {\n            // While we are forced to run the hash MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS times in the circuit,\n            // we want the bytecode commitment to be based on the actual length\n            if (i < bytecode_length_in_fields) {\n                // We skip the first element when hashing since it is the length\n                computed_public_bytecode_commitment = std::hash::poseidon2::Poseidon2::hash(\n                    [packed_public_bytecode[i + 1], computed_public_bytecode_commitment],\n                    2,\n                );\n            } else {\n                // Any bytes after the bytecode length must be 0\n                assert_eq(packed_public_bytecode[i + 1], 0);\n            }\n        }\n        assert_eq(computed_public_bytecode_commitment, public_bytecode_commitment);\n\n        // Compute contract class id from preimage\n        let contract_class_id = ContractClassId::compute(\n            artifact_hash,\n            private_functions_root,\n            public_bytecode_commitment,\n        );\n\n        // Emit the contract class id as a nullifier to be able to prove that this class has been (not) registered\n        context.push_nullifier(contract_class_id.to_field());\n\n        // Broadcast class info including public bytecode\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ContractClassRegistered: {}\",\n            [\n                contract_class_id.to_field(),\n                artifact_hash,\n                private_functions_root,\n                public_bytecode_commitment,\n            ],\n        );\n\n        let event = ContractClassRegistered {\n            contract_class_id,\n            version: 1,\n            artifact_hash,\n            private_functions_root,\n            packed_public_bytecode,\n        };\n        emit_contract_class_log(&mut context, event.serialize_non_standard());\n    }\n\n    #[private]\n    fn broadcast_private_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        unconstrained_functions_artifact_tree_root: Field,\n        private_function_tree_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n        private_function_tree_leaf_index: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: InnerPrivateFunction,\n    ) {\n        let private_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_PRIVATE_FUNCTION_IN_FIELDS] = unsafe {\n            capsules::load(\n                context.this_address(),\n                REGISTERER_CONTRACT_BYTECODE_CAPSULE_SLOT,\n            )\n                .unwrap()\n        };\n\n        let event = ClassPrivateFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            unconstrained_functions_artifact_tree_root,\n            private_function_tree_sibling_path,\n            private_function_tree_leaf_index,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: PrivateFunction {\n                selector: function_data.selector,\n                metadata_hash: function_data.metadata_hash,\n                vk_hash: function_data.vk_hash,\n                bytecode: private_bytecode,\n            },\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassPrivateFunctionBroadcasted: {}\",\n            [\n                contract_class_id.to_field(),\n                artifact_metadata_hash,\n                unconstrained_functions_artifact_tree_root,\n                function_data.selector.to_field(),\n                function_data.vk_hash,\n                function_data.metadata_hash,\n            ],\n        );\n        emit_contract_class_log(&mut context, event.serialize_non_standard());\n    }\n\n    #[private]\n    fn broadcast_unconstrained_function(\n        contract_class_id: ContractClassId,\n        artifact_metadata_hash: Field,\n        private_functions_artifact_tree_root: Field,\n        artifact_function_tree_sibling_path: [Field; ARTIFACT_FUNCTION_TREE_MAX_HEIGHT],\n        artifact_function_tree_leaf_index: Field,\n        function_data: InnerUnconstrainedFunction,\n    ) {\n        let unconstrained_bytecode: [Field; MAX_PACKED_BYTECODE_SIZE_PER_UNCONSTRAINED_FUNCTION_IN_FIELDS] = unsafe {\n            capsules::load(\n                context.this_address(),\n                REGISTERER_CONTRACT_BYTECODE_CAPSULE_SLOT,\n            )\n                .unwrap()\n        };\n        let event = ClassUnconstrainedFunctionBroadcasted {\n            contract_class_id,\n            artifact_metadata_hash,\n            private_functions_artifact_tree_root,\n            artifact_function_tree_sibling_path,\n            artifact_function_tree_leaf_index,\n            function: UnconstrainedFunction {\n                selector: function_data.selector,\n                metadata_hash: function_data.metadata_hash,\n                bytecode: unconstrained_bytecode,\n            },\n        };\n        dep::aztec::oracle::debug_log::debug_log_format(\n            \"ClassUnconstrainedFunctionBroadcasted: {}\",\n            [\n                contract_class_id.to_field(),\n                artifact_metadata_hash,\n                private_functions_artifact_tree_root,\n                function_data.selector.to_field(),\n                function_data.metadata_hash,\n            ],\n        );\n        emit_contract_class_log(&mut context, event.serialize_non_standard());\n    }\n\n    #[contract_library_method]\n    fn emit_contract_class_log<let N: u32>(context: &mut PrivateContext, log: [Field; N]) {\n        let contract_address = context.this_address();\n        let counter = context.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_DATA_SIZE_IN_FIELDS] =\n            array_concat(log, [0; CONTRACT_CLASS_LOG_DATA_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup.\n        let length = unsafe { unsafe_padded_array_length(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, counter);\n        }\n\n        context.contract_class_logs_hashes.push(LogHash { value: log_hash, counter, length });\n    }\n\n    #[private]\n    fn assert_class_id_is_registered(contract_class_id: ContractClassId) {\n        context.push_nullifier_read_request(contract_class_id.to_field());\n    }\n}\n"
    },
    "59": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push<let N: u32>(self, value: T)\n    where\n        T: Serialize<N>,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get<let N: u32>(self, index: u32) -> T\n    where\n        T: Deserialize<N>,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n    use protocol_types::address::AztecAddress;\n\n    global SLOT: Field = 1230;\n\n    unconstrained fn setup() -> AztecAddress {\n        TestEnvironment::new().utility().this_address()\n    }\n\n    #[test]\n    unconstrained fn empty_array() {\n        let contract_address = setup();\n\n        let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n        assert_eq(array.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        let _: Field = array.get(0);\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        assert_eq(array.len(), 1);\n        assert_eq(array.get(0), 5);\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n        array.push(5);\n\n        let _ = array.get(1);\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(5);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        assert_eq(array.len(), 3);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 8);\n        assert_eq(array.get(2), 9);\n\n        array.remove(1);\n\n        assert_eq(array.len(), 2);\n        assert_eq(array.get(0), 7);\n        assert_eq(array.get(1), 9);\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let contract_address = setup();\n\n        let array = CapsuleArray::at(contract_address, SLOT);\n\n        array.push(7);\n        array.push(8);\n        array.push(9);\n\n        array.remove(1);\n        array.remove(1);\n        array.remove(0);\n\n        assert_eq(array.len(), 0);\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n"
    },
    "67": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use dep::protocol_types::debug_log::debug_log_format;\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log::Log,\n        log_hash::LogHash,\n        max_block_number::MaxBlockNumber,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::PrivateLogData,\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    block_header::BlockHeader,\n    constants::{\n        MAX_CONTRACT_CLASS_LOGS_PER_CALL, MAX_ENQUEUED_CALLS_PER_CALL,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::array_concat,\n};\n\n// When finished, one can call .finish() to convert back to the abi\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub max_block_number: MaxBlockNumber,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<L2ToL1Message, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<LogHash, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n\n        // WARNING(https://github.com/AztecProtocol/aztec-packages/issues/10558): if you delete this debug_log_format line, some tests fail.\n        debug_log_format(\n            \"Context.note_hashes, after pushing new note hash: {0}\",\n            self.note_hashes.storage().map(|nh: NoteHash| nh.value),\n        );\n    }\n\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage(),\n            nullifier_read_requests: self.nullifier_read_requests.storage(),\n            key_validation_requests_and_generators: self\n                .key_validation_requests_and_generators\n                .storage(),\n            note_hashes: self.note_hashes.storage(),\n            nullifiers: self.nullifiers.storage(),\n            private_call_requests: self.private_call_requests.storage(),\n            public_call_requests: self.public_call_requests.storage(),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: self.l2_to_l1_msgs.storage(),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: self.private_logs.storage(),\n            contract_class_logs_hashes: self.contract_class_logs_hashes.storage(),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number =\n            MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request =\n            self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index],\n                },\n            );\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS]) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log = PrivateLogData { log: Log::new(log), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    pub fn static_call_private_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1;\n        ReturnsHash::new(returns_hash)\n    }\n\n    pub fn call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    pub fn set_public_teardown_function<let ARGS_COUNT: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT],\n    ) {\n        let calldata = array_concat([function_selector.to_field()], args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/mod.nr",
      "source": "use crate::encrypted_logs::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\nuse protocol_types::{address::AztecAddress, debug_log::debug_log};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod pending_tagged_log;\npub mod private_logs;\npub mod private_notes;\n\n/// We reserve two fields in the note private log that are not part of the note content: one for the storage slot, and\n/// one for the combined log and note type ID.\nglobal PRIVATE_LOG_EXPANDED_METADATA_LEN: u32 = 1;\n\n/// The maximum length of the log's content, i.e. after log type ID and metadata extraction.\npub global MAX_LOG_CONTENT_LEN: u32 =\n    PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS - PRIVATE_LOG_EXPANDED_METADATA_LEN;\n\nuse private_notes::MAX_NOTE_PACKED_LEN;\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, nonce, storage slot and note type\n/// ID and attempts to compute its note hash (not siloed by nonce nor address) and inner nullifier (not siloed by\n/// address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    private_logs::fetch_and_process_private_tagged_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    partial_notes::fetch_and_process_public_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/nonce_discovery.nr",
      "source": "use crate::{\n    discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    array::for_each_in_bounded_vec(\n        unique_note_hashes_in_tx,\n        |expected_unique_note_hash, i| {\n            // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n            // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n            let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n            // Given nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n            // the note hash at the array index we're currently processing.\n            // TODO(#11157): handle failed note_hash_and_nullifier computation\n            let hashes = compute_note_hash_and_nullifier(\n                packed_note,\n                storage_slot,\n                note_type_id,\n                contract_address,\n                candidate_nonce,\n            )\n                .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n            let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n            let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n            if unique_note_hash == expected_unique_note_hash {\n                // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n                // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n                // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n                // PXE may fail to realize that a given note has been nullified already, and calls to the application\n                // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n                // application already has more direct means of making a call to it fail the transaction.\n                discovered_notes.push(\n                    DiscoveredNoteInfo {\n                        nonce: candidate_nonce,\n                        note_hash: hashes.note_hash,\n                        inner_nullifier: hashes.inner_nullifier,\n                    },\n                );\n\n                // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n                // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n                // notes containing random values in order to hide their contents.\n            }\n        },\n    );\n\n    debug_log_format(\n        \"Discovered a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n"
    },
    "74": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle::message_discovery::{deliver_note, get_log_by_tag},\n    utils::array,\n};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::PUBLIC_LOG_DATA_SIZE_IN_FIELDS,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize, ToField},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private log (e.g.\n/// the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// Public logs contain an extra field at the beginning with the address of the contract that emitted them, and partial\n/// notes emit their completion tag in the log, resulting in the first two fields in the public log not being part of\n/// the packed public content.\n// TODO(#10273): improve how contract log siloing is handled\npub global NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG: u32 = 2;\n\n/// The maximum length of the packed representation of public fields in a partial note. This is limited by public log\n/// size and extra fields in the log (e.g. the tag).\npub global MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH: u32 =\n    PUBLIC_LOG_DATA_SIZE_IN_FIELDS - NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG;\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_log(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_log(log_metadata, log_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for public logs that would result in the completion of pending partial notes, ultimately resulting in the\n/// notes being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_public_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    let mut i = 0;\n    while i < pending_partial_notes.len() {\n        let pending_partial_note: DeliveredPendingPartialNote = pending_partial_notes.get(i);\n\n        let maybe_log = get_log_by_tag(pending_partial_note.note_completion_log_tag);\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            i += 1 as u32;\n            // Note that we're not removing the pending partial note from the PXE DB, so we will continue searching\n            // for this tagged log when performing message discovery in the future until we either find it or the\n            // entry is somehow removed from the PXE DB.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public logs have an extra field at the beginning with the contract address, which we use to verify\n            // that we're getting the logs from the expected contract.\n            // TODO(#10273): improve how contract log siloing is handled\n            assert_eq(\n                log.log_content.get(0),\n                contract_address.to_field(),\n                \"Got a public log emitted by a different contract\",\n            );\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the log sans the extra fields) to get the\n            // complete packed content.\n            let packed_public_note_content: BoundedVec<_, MAX_PUBLIC_PARTIAL_NOTE_PACKED_CONTENT_LENGTH> =\n                array::subbvec(log.log_content, NON_PACKED_CONTENT_FIELDS_IN_PUBLIC_LOG);\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                packed_public_note_content,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            array::for_each_in_bounded_vec(\n                discovered_notes,\n                |discovered_note: DiscoveredNoteInfo, _| {\n                    // TODO:(#10728): decide how to handle notes that fail delivery. This could be due to e.g. a\n                    // temporary node connectivity issue - is simply throwing good enough here?\n                    assert(\n                        deliver_note(\n                            contract_address,\n                            pending_partial_note.storage_slot,\n                            discovered_note.nonce,\n                            complete_packed_note,\n                            discovered_note.note_hash,\n                            discovered_note.inner_nullifier,\n                            log.tx_hash,\n                            pending_partial_note.recipient,\n                        ),\n                        \"Failed to deliver note\",\n                    );\n                },\n            );\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            // TODO(#11627): only remove the pending entry if we actually process a log that results in the note\n            // being completed.\n            pending_partial_notes.remove(i);\n\n            // We don't increment `i` here, because CapsuleArray is contiguous and its `remove(...)` function\n            // shifts the elements to the left if the removed element is not the last element.\n        }\n    }\n}\n\nfn decode_partial_note_private_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all partial note private logs must have at least {PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private log encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = log_content.get(0);\n    let note_completion_log_tag = log_content.get(1);\n\n    let packed_private_note_content = array::subbvec(log_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_logs.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        partial_notes::process_partial_note_private_log,\n        pending_tagged_log::{PENDING_TAGGED_LOG_ARRAY_BASE_SLOT, PendingTaggedLog},\n        PRIVATE_LOG_EXPANDED_METADATA_LEN,\n        private_notes::process_private_note_log,\n    },\n    encrypted_logs::{\n        log_assembly_strategies::default_aes128::aes128::AES128,\n        log_encryption::LogEncryption,\n        log_type::{\n            PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID, PRIVATE_EVENT_LOG_TYPE_ID, PRIVATE_NOTE_LOG_TYPE_ID,\n        },\n        metadata_packing::from_expanded_metadata,\n    },\n    oracle::{logs::store_private_event_log, message_discovery::sync_notes},\n    utils::array,\n};\n\nuse protocol_types::{\n    abis::event_selector::EventSelector,\n    address::AztecAddress,\n    debug_log::{debug_log, debug_log_format},\n    traits::FromField,\n};\n\n// TODO(#12750): don't make these values assume we're using AES.\nuse crate::encrypted_logs::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\n/// Searches for private logs that signal new private notes that are then delivered to PXE, or new partial notes that\n/// are stored in the PXE capsules so that `fetch_and_process_public_partial_note_completion_logs` can later search for\n/// public logs that will complete them.\npub unconstrained fn fetch_and_process_private_tagged_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `syncNotes` oracle.\n    // This makes PXE synchronize tags, download logs and store the pending tagged logs in capsule array which are then\n    // retrieved and processed here.\n    sync_notes(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    // Get logs from capsules\n    let logs =\n        CapsuleArray::<PendingTaggedLog>::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n    let len = logs.len();\n\n    // We iterate over the logs in reverse order to avoid shifting elements.\n    let mut i = len;\n    while i > 0 {\n        i -= 1;\n\n        // Get and process each log\n        let log = logs.get(i);\n        process_log(contract_address, compute_note_hash_and_nullifier, log);\n\n        // Remove the log from the capsule array\n        logs.remove(i);\n    }\n}\n\n/// Processes a log's ciphertext by decrypting it and then searching the plaintext for private notes or partial notes.\n///\n/// Private notes result in nonce discovery being performed prior to delivery, which requires knowledge of the\n/// transaction hash in which the notes would've been created (typically the same transaction in which the log was\n/// emitted), along with the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier`\n/// function.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\nunconstrained fn process_log<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    pending_tagged_log: PendingTaggedLog,\n) {\n    debug_log_format(\n        \"Processing log with tag {0}\",\n        [pending_tagged_log.log.get(0)],\n    );\n\n    // The tag is ignored for now.\n    let ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n    let log_plaintext = AES128::decrypt_log(ciphertext, pending_tagged_log.recipient);\n\n    // The first thing to do after decrypting the log is to determine what type of private log we're processing. We\n    // have 3 log types: private note logs, partial note logs and event logs.\n\n    let (log_type_id, log_metadata, log_content) = decode_log_plaintext(log_plaintext);\n\n    if log_type_id == PRIVATE_NOTE_LOG_TYPE_ID {\n        debug_log(\"Processing private note log\");\n\n        process_private_note_log(\n            contract_address,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.unique_note_hashes_in_tx,\n            pending_tagged_log.first_nullifier_in_tx,\n            pending_tagged_log.recipient,\n            compute_note_hash_and_nullifier,\n            log_metadata,\n            log_content,\n        );\n    } else if log_type_id == PARTIAL_NOTE_PRIVATE_LOG_TYPE_ID {\n        debug_log(\"Processing partial note private log\");\n\n        process_partial_note_private_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            log_metadata,\n            log_content,\n        );\n    } else if log_type_id == PRIVATE_EVENT_LOG_TYPE_ID {\n        debug_log(\"Processing private event log\");\n\n        // In the case of event logs, the log metadata is the event selector.\n        let event_selector = EventSelector::from_field(log_metadata as Field);\n\n        store_private_event_log(\n            contract_address,\n            pending_tagged_log.recipient,\n            event_selector,\n            log_content,\n            pending_tagged_log.tx_hash,\n            pending_tagged_log.log_index_in_tx,\n        );\n    } else {\n        debug_log_format(\n            \"Unknown log type id {0} (probably belonging to an event log)\",\n            [log_type_id as Field],\n        );\n    }\n}\n\n/// Decodes a log's plaintext following aztec-nr's standard log encoding.\n///\n/// The standard private log layout is composed of:\n///  - an initial field called the 'expanded metadata'\n///  - an arbitrary number of fields following that called the 'log content'\n///\n/// ```\n/// log_plaintext: [ log_expanded_metadata, ...log_content ]\n/// ```\n///\n/// The expanded metadata itself is (currently) interpreted as a u128, of which:\n///  - the upper 64 bits are the log type id\n///  - the lower 64 bits are called the 'log metadata'\n///\n/// ```\n/// log_expanded_metadata: [  log_type_id    |  log_metadata  ]\n///                        <---  64 bits --->|<--- 64 bits --->\n/// ```\n///\n/// The meaning of the log metadata and log content depend on the value of the log type id. Note that there is\n/// nothing special about the log metadata, it _can_ be considered part of the content. It just has a different name\n/// to make it distinct from the log content given that it is not a full field.\nunconstrained fn decode_log_plaintext(\n    log_plaintext: BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>,\n) -> (u64, u64, BoundedVec<Field, MAX_LOG_CONTENT_LEN>) {\n    assert(\n        log_plaintext.len() >= PRIVATE_LOG_EXPANDED_METADATA_LEN,\n        f\"Invalid log plaintext: all logs must be decrypted into at least {PRIVATE_LOG_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If PRIVATE_LOG_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_LOG_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for PRIVATE_LOG_EXPANDED_METADATA_LEN\",\n    );\n\n    // See the documentation of this function for a description of the log layout\n    let expanded_log_metadata = log_plaintext.get(0);\n    let (log_metadata, log_type_id) = from_expanded_metadata(expanded_log_metadata);\n    let log_content = array::subbvec(log_plaintext, PRIVATE_LOG_EXPANDED_METADATA_LEN);\n\n    (log_type_id, log_metadata, log_content)\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/discovery/private_notes.nr",
      "source": "use crate::{\n    discovery::{\n        ComputeNoteHashAndNullifier,\n        MAX_LOG_CONTENT_LEN,\n        nonce_discovery::{attempt_note_nonce_discovery, DiscoveredNoteInfo},\n    },\n    oracle,\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note log content that are not the note's packed representation.\nglobal PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the log (e.g. log type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_LOG_CONTENT_LEN - PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_log<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_log(log_metadata, log_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private log\",\n        [discovered_notes.len() as Field],\n    );\n\n    array::for_each_in_bounded_vec(\n        discovered_notes,\n        |discovered_note: DiscoveredNoteInfo, _| {\n            // TODO:(#10728): handle notes that fail delivery. This could be due to e.g. a temporary node connectivity\n            // issue, and we should perhaps not have marked the tag index as taken.\n            assert(\n                oracle::message_discovery::deliver_note(\n                    contract_address,\n                    storage_slot,\n                    discovered_note.nonce,\n                    packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    tx_hash,\n                    recipient,\n                ),\n                \"Failed to deliver note\",\n            );\n        },\n    );\n}\n\nfn decode_private_note_log(\n    log_metadata: u64,\n    log_content: BoundedVec<Field, MAX_LOG_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = log_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        log_content.len() > PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note log: all private note logs must have at least {PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the private note log encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = log_content.get(0);\n    let packed_note = array::subbvec(log_content, PRIVATE_NOTE_LOG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "78": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/encrypted_logs/encrypt/aes128.nr",
      "source": "use dep::protocol_types::{\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::utils::point::point_to_bytes;\n\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let rand1: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY,\n    );\n    let rand2: Field = poseidon2_hash_with_separator(\n        [shared_secret.x, shared_secret.y],\n        GENERATOR_INDEX__SYMMETRIC_KEY_2,\n    );\n    let rand1_bytes: [u8; 16] = rand1.to_le_bytes();\n    let rand2_bytes: [u8; 16] = rand2.to_le_bytes();\n    let mut bytes: [u8; 32] = [0; 32];\n    for i in 0..16 {\n        bytes[i] = rand1_bytes[i];\n        bytes[i + 1] = rand2_bytes[i];\n    }\n    bytes\n}\n\n// TODO(#10537): Consider nuking this function.\nfn extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> [u8; 32] {\n    let shared_secret_bytes: [u8; 32] = point_to_bytes(shared_secret);\n\n    let mut shared_secret_bytes_with_separator: [u8; 33] = std::mem::zeroed();\n    for i in 0..shared_secret_bytes.len() {\n        shared_secret_bytes_with_separator[i] = shared_secret_bytes[i];\n    }\n    shared_secret_bytes_with_separator[32] = GENERATOR_INDEX__SYMMETRIC_KEY;\n\n    sha256::digest(shared_secret_bytes_with_separator)\n}\n\nfn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n    shared_secret: Point,\n    randomness_extraction_fn: fn(Point) -> [u8; 32],\n) -> ([u8; 16], [u8; 16]) {\n    let random_256_bits = randomness_extraction_fn(shared_secret);\n    let mut sym_key = [0; 16];\n    let mut iv = [0; 16];\n    for i in 0..16 {\n        sym_key[i] = random_256_bits[i];\n        iv[i] = random_256_bits[i + 16];\n    }\n    (sym_key, iv)\n}\n\n// TODO(#10537): Consider nuking this function.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_sha256,\n    )\n}\n\n// TODO(#10537): This function is currently unused. Consider using it instead of the sha256 one.\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2(\n    shared_secret: Point,\n) -> ([u8; 16], [u8; 16]) {\n    derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret(\n        shared_secret,\n        extract_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2,\n    )\n}\n"
    },
    "81": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/encrypted_logs/log_assembly_strategies/default_aes128/aes128.nr",
      "source": "use crate::{\n    encrypted_logs::{\n        encrypt::aes128::derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256,\n        log_assembly_strategies::default_aes128::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n        log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_CIPHERTEXT_LEN,\n            PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n    },\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    prelude::AztecAddress,\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\nuse std::aes128::aes128_encrypt;\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PLAINTEXT_LEN: u32>(\n        plaintext: [Field; PLAINTEXT_LEN],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, iv, sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PLAINTEXT_LEN * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        // TODO: consider nuking the header altogether and just have a fixed-size ciphertext by padding the plaintext.\n        // This would be more costly constraint-wise but cheaper DA-wise.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // TODO: this is insecure and wasteful:\n        // \"Insecure\", because the esk shouldn't be used twice (once for the header,\n        // and again for the proper ciphertext) (at least, I never got the\n        // \"go ahead\" that this would be safe, unfortunately).\n        // \"Wasteful\", because the exact same computation is happening further down.\n        // I'm leaving that 2nd computation where it is, because this 1st computation\n        // will be imminently deleted, when the header logic is deleted.\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, iv, sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PLAINTEXT_LEN * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PLAINTEXT_LEN * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) as bool;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret and symmetric key\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n        let (sym_key, iv) = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_sha256(\n            ciphertext_shared_secret,\n        );\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext = aes128_decrypt_oracle(header_ciphertext_bvec, iv, sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, iv, sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        encrypted_logs::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let mut env = TestEnvironment::new();\n        // Advance 1 block so we can read historic state from private\n        env.advance_block_by(1);\n\n        let plaintext = [1, 2, 3];\n\n        let recipient = AztecAddress::from_field(\n            0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n        );\n\n        // Mock random values for deterministic test\n        let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n        let _ = OracleMock::mock(\"getRandomField\").returns(eph_sk).times(1);\n\n        let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n        let _ = OracleMock::mock(\"getRandomField\").returns(randomness).times(1000000);\n\n        let _ = OracleMock::mock(\"getIndexedTaggingSecretAsSender\").returns(\n            IndexedTaggingSecret::deserialize([69420, 1337]),\n        );\n        let _ = OracleMock::mock(\"incrementAppTaggingSecretIndexAsSender\").returns(());\n\n        // Encrypt the log\n        let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n        // Mock shared secret for deterministic test\n        let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n            EmbeddedCurveScalar::from_field(eph_sk),\n            recipient,\n        );\n        let _ = OracleMock::mock(\"getSharedSecret\").returns(shared_secret);\n\n        // Decrypt the log\n        let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n        // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n        // at compile time. For this reason we need to convert the original input to a BoundedVec.\n        let plaintext_bvec =\n            BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n        // Verify decryption matches original plaintext\n        assert_eq(decrypted, plaintext_bvec, \"Decrypted bytes should match original plaintext\");\n\n        // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n        // static methods of the struct).\n        let _ = AES128 {};\n    }\n}\n"
    },
    "90": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/encrypted_logs/metadata_packing.nr",
      "source": "global U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\npub fn to_expanded_metadata(log_metadata: u64, log_type: u64) -> Field {\n    let metadata_field = log_metadata as Field;\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (log_type as Field) * U64_SHIFT_MULTIPLIER;\n    type_field + metadata_field\n}\n\npub fn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let metadata = (input as u64);\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    let log_type = ((input - (metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    (metadata, log_type)\n}\n\nmod tests {\n    use super::{from_expanded_metadata, to_expanded_metadata};\n\n    global U64_MAX: Field = 2.pow_32(64) - 1;\n    global U128_MAX: Field = 2.pow_32(128) - 1;\n\n    #[test]\n    fn packing_metadata() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX as u64, U64_MAX as u64);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(0, U64_MAX as u64);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 3: Only metadata bits set\n        let packed = to_expanded_metadata(U64_MAX as u64, 0);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n\n        // Test case 4: Zero\n        let packed = to_expanded_metadata(0, 0);\n        let (metadata, log_type) = from_expanded_metadata(packed);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n    }\n\n    #[test]\n    fn unpacking_metadata() {\n        // Test case 1: All bits set\n        let input = U128_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 2: Only log type bits set\n        let input = U128_MAX - U64_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == U64_MAX as u64, \"Log type bits should be all 1s\");\n\n        // Test case 3: Only metadata bits set\n        let input = U64_MAX;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == U64_MAX as u64, \"Metadata bits should be all 1s\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n\n        // Test case 4: Zero\n        let input = 0;\n        let (metadata, log_type) = from_expanded_metadata(input);\n        assert(metadata == 0, \"Metadata bits should be 0\");\n        assert(log_type == 0, \"Log type bits should be 0\");\n    }\n\n    #[test]\n    fn roundtrip_metadata(original_metadata: u64, original_type: u64) {\n        let packed = to_expanded_metadata(original_metadata, original_type);\n        let (unpacked_metadata, unpacked_type) = from_expanded_metadata(packed);\n        assert(original_type == unpacked_type, \"Log type bits should match after roundtrip\");\n        assert(\n            original_metadata == unpacked_metadata,\n            \"Metadata bits should match after roundtrip\",\n        );\n    }\n}\n"
    },
    "94": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_CALLDATA, GENERATOR_INDEX__SECRET_HASH,\n    },\n    hash::{poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice, sha256_to_field},\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    }
  }
}

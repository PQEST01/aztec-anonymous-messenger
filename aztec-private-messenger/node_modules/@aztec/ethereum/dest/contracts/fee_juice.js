import { EthAddress } from '@aztec/foundation/eth-address';
import { TestERC20Abi as FeeJuiceAbi } from '@aztec/l1-artifacts/TestERC20Abi';
import { getContract } from 'viem';
export class FeeJuiceContract {
    publicClient;
    walletClient;
    publicFeeJuice;
    walletFeeJuice;
    constructor(address, publicClient, walletClient){
        this.publicClient = publicClient;
        this.walletClient = walletClient;
        this.publicFeeJuice = getContract({
            address,
            abi: FeeJuiceAbi,
            client: publicClient
        });
        this.walletFeeJuice = walletClient ? getContract({
            address,
            abi: FeeJuiceAbi,
            client: walletClient
        }) : undefined;
    }
    get address() {
        return EthAddress.fromString(this.publicFeeJuice.address);
    }
    assertWalletFeeJuice() {
        if (!this.walletFeeJuice) {
            throw new Error('Wallet client is required for this operation');
        }
        return this.walletFeeJuice;
    }
    async mint(to, amount) {
        const walletFeeJuice = this.assertWalletFeeJuice();
        const tx = await walletFeeJuice.write.mint([
            to,
            amount
        ]);
        const receipt = await this.publicClient.waitForTransactionReceipt({
            hash: tx
        });
        if (receipt.status === 'success') {
            return;
        }
        throw new Error('Mint failed');
    }
    async approve(spender, amount) {
        const walletFeeJuice = this.assertWalletFeeJuice();
        const tx = await walletFeeJuice.write.approve([
            spender,
            amount
        ]);
        const receipt = await this.publicClient.waitForTransactionReceipt({
            hash: tx
        });
        if (receipt.status === 'success') {
            return;
        }
        throw new Error('Approve failed');
    }
}

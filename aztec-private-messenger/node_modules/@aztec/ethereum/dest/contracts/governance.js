import { EthAddress } from '@aztec/foundation/eth-address';
import { sleep } from '@aztec/foundation/sleep';
import { GovernanceAbi } from '@aztec/l1-artifacts/GovernanceAbi';
import { encodeFunctionData, getContract, parseEventLogs } from 'viem';
import { L1TxUtils } from '../l1_tx_utils.js';
// NOTE: Must be kept in sync with DataStructures.ProposalState in l1-contracts
export var ProposalState = /*#__PURE__*/ function(ProposalState) {
    ProposalState[ProposalState["Pending"] = 0] = "Pending";
    ProposalState[ProposalState["Active"] = 1] = "Active";
    ProposalState[ProposalState["Queued"] = 2] = "Queued";
    ProposalState[ProposalState["Executable"] = 3] = "Executable";
    ProposalState[ProposalState["Rejected"] = 4] = "Rejected";
    ProposalState[ProposalState["Executed"] = 5] = "Executed";
    ProposalState[ProposalState["Dropped"] = 6] = "Dropped";
    ProposalState[ProposalState["Expired"] = 7] = "Expired";
    return ProposalState;
}({});
export function extractProposalIdFromLogs(logs) {
    const parsedLogs = parseEventLogs({
        abi: GovernanceAbi,
        logs: logs,
        eventName: 'Proposed'
    });
    if (parsedLogs.length === 0) {
        throw new Error('Proposal log not found');
    }
    return parsedLogs[0].args.proposalId;
}
export class GovernanceContract {
    publicClient;
    walletClient;
    publicGovernance;
    walletGovernance;
    constructor(address, publicClient, walletClient){
        this.publicClient = publicClient;
        this.walletClient = walletClient;
        this.publicGovernance = getContract({
            address,
            abi: GovernanceAbi,
            client: publicClient
        });
        this.walletGovernance = walletClient ? getContract({
            address,
            abi: GovernanceAbi,
            client: walletClient
        }) : undefined;
    }
    get address() {
        return EthAddress.fromString(this.publicGovernance.address);
    }
    async getGovernanceProposerAddress() {
        return EthAddress.fromString(await this.publicGovernance.read.governanceProposer());
    }
    getConfiguration() {
        return this.publicGovernance.read.getConfiguration();
    }
    getProposal(proposalId) {
        return this.publicGovernance.read.getProposal([
            proposalId
        ]);
    }
    async getProposalState(proposalId) {
        const state = await this.publicGovernance.read.getProposalState([
            proposalId
        ]);
        if (state < 0 || state > 7) {
            throw new Error(`Invalid proposal state: ${state}`);
        }
        return state;
    }
    assertWalletGovernance() {
        if (!this.walletGovernance) {
            throw new Error('Wallet client is required for this operation');
        }
        return this.walletGovernance;
    }
    async deposit(onBehalfOf, amount) {
        const walletGovernance = this.assertWalletGovernance();
        const depositTx = await walletGovernance.write.deposit([
            onBehalfOf,
            amount
        ]);
        await this.publicClient.waitForTransactionReceipt({
            hash: depositTx
        });
    }
    async proposeWithLock({ payloadAddress, withdrawAddress }) {
        const walletGovernance = this.assertWalletGovernance();
        const proposeTx = await walletGovernance.write.proposeWithLock([
            payloadAddress,
            withdrawAddress
        ]);
        const receipt = await this.publicClient.waitForTransactionReceipt({
            hash: proposeTx
        });
        if (receipt.status !== 'success') {
            throw new Error(`Proposal failed: ${receipt.status}`);
        }
        return extractProposalIdFromLogs(receipt.logs);
    }
    async awaitProposalActive({ proposalId, logger }) {
        const state = await this.getProposalState(proposalId);
        if (state === 1) {
            return;
        } else if (state !== 0) {
            throw new Error(`Proposal ${proposalId} is in state [${state}]: it will never be active`);
        } else {
            const proposal = await this.getProposal(proposalId);
            const startOfActive = proposal.creation + proposal.config.votingDelay;
            const block = await this.publicClient.getBlock();
            // Add 12 seconds to the time to make sure we don't vote too early
            const secondsToActive = Number(startOfActive - block.timestamp) + 12;
            const now = new Date();
            logger.info(`
        The time is ${now.toISOString()}.
        The proposal will be active at ${new Date(Number(startOfActive) * 1000).toISOString()}.
        Waiting ${secondsToActive} seconds for proposal to be active.
        `);
            await sleep(secondsToActive * 1000);
        }
    }
    async awaitProposalExecutable({ proposalId, logger }) {
        const state = await this.getProposalState(proposalId);
        if (state === 3) {
            return;
        } else if (![
            0,
            1,
            2,
            3
        ].includes(state)) {
            throw new Error(`Proposal ${proposalId} is in state [${state}]: it will never be executable`);
        } else {
            const proposal = await this.getProposal(proposalId);
            const startOfExecutable = proposal.creation + proposal.config.votingDelay + proposal.config.votingDuration + proposal.config.executionDelay;
            const block = await this.publicClient.getBlock();
            const secondsToExecutable = Number(startOfExecutable - block.timestamp) + 12;
            const now = new Date();
            logger.info(`
        The time is ${now.toISOString()}.
        The proposal will be executable at ${new Date(Number(startOfExecutable) * 1000).toISOString()}.
        Waiting ${secondsToExecutable} seconds for proposal to be executable.
        `);
            await sleep(secondsToExecutable * 1000);
        }
    }
    async getPower() {
        const walletGovernance = this.assertWalletGovernance();
        const now = await this.publicClient.getBlock();
        return walletGovernance.read.powerAt([
            this.walletClient.account.address,
            now.timestamp
        ]);
    }
    async vote({ proposalId, voteAmount, inFavor, retries = 10, logger }) {
        const walletGovernance = this.assertWalletGovernance();
        const l1TxUtils = new L1TxUtils(this.publicClient, this.walletClient, logger);
        const retryDelaySeconds = 12;
        voteAmount = voteAmount ?? await this.getPower();
        let success = false;
        for(let i = 0; i < retries; i++){
            try {
                const voteFunctionData = {
                    abi: GovernanceAbi,
                    functionName: 'vote',
                    args: [
                        proposalId,
                        voteAmount,
                        inFavor
                    ]
                };
                const encodedVoteData = encodeFunctionData(voteFunctionData);
                const { receipt } = await l1TxUtils.sendAndMonitorTransaction({
                    to: walletGovernance.address,
                    data: encodedVoteData
                });
                if (receipt.status === 'success') {
                    success = true;
                    break;
                } else {
                    const args = {
                        ...voteFunctionData,
                        address: walletGovernance.address
                    };
                    const errorMsg = await l1TxUtils.tryGetErrorFromRevertedTx(encodedVoteData, args, undefined, []);
                    logger.error(`Error voting on proposal ${proposalId}: ${errorMsg}`);
                }
            } catch (error) {
                logger.error(`Error voting on proposal ${proposalId}: ${error}`);
            }
            logger.info(`Retrying vote on proposal ${proposalId} in ${retryDelaySeconds} seconds`);
            await sleep(retryDelaySeconds * 1000);
        }
        if (!success) {
            throw new Error(`Failed to vote on proposal ${proposalId} after ${retries} retries`);
        }
        logger.info(`Voted [${inFavor ? 'yea' : 'nay'}] on proposal [${proposalId}]`);
        const proposal = await this.getProposal(proposalId);
        logger.info(`Proposal [${proposalId}] has state [${proposal.state}]`);
        logger.info(`Proposal [${proposalId}] has summedBallot yea [${proposal.summedBallot.yea}]`);
        logger.info(`Proposal [${proposalId}] has summedBallot nea [${proposal.summedBallot.nea}]`);
    }
    async executeProposal({ proposalId, retries = 10, logger }) {
        const walletGovernance = this.assertWalletGovernance();
        const l1TxUtils = new L1TxUtils(this.publicClient, this.walletClient, logger);
        const retryDelaySeconds = 12;
        let success = false;
        for(let i = 0; i < retries; i++){
            try {
                const executeFunctionData = {
                    abi: GovernanceAbi,
                    functionName: 'execute',
                    args: [
                        proposalId
                    ]
                };
                const encodedExecuteData = encodeFunctionData(executeFunctionData);
                const { receipt } = await l1TxUtils.sendAndMonitorTransaction({
                    to: walletGovernance.address,
                    data: encodedExecuteData
                });
                if (receipt.status === 'success') {
                    success = true;
                    break;
                } else {
                    const args = {
                        ...executeFunctionData,
                        address: walletGovernance.address
                    };
                    const errorMsg = await l1TxUtils.tryGetErrorFromRevertedTx(encodedExecuteData, args, undefined, []);
                    logger.error(`Error executing proposal ${proposalId}: ${errorMsg}`);
                }
            } catch (error) {
                logger.error(`Error executing proposal ${proposalId}: ${error}`);
            }
            logger.info(`Retrying execute proposal ${proposalId} in ${retryDelaySeconds} seconds`);
            await sleep(retryDelaySeconds * 1000);
        }
        if (!success) {
            throw new Error(`Failed to execute proposal ${proposalId} after ${retries} retries`);
        } else {
            logger.info(`Executed proposal ${proposalId}`);
        }
    }
}

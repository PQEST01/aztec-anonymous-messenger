import { AbortError } from '@aztec/foundation/error';
import { createLogger } from '@aztec/foundation/log';
import { RunningPromise } from '@aztec/foundation/running-promise';
/** Creates a stream of events for new blocks, chain tips updates, and reorgs, out of polling an archiver or a node. */ export class L2BlockStream {
    l2BlockSource;
    localData;
    handler;
    log;
    opts;
    runningPromise;
    isSyncing;
    hasStarted;
    constructor(l2BlockSource, localData, handler, log = createLogger('types:block_stream'), opts = {}){
        this.l2BlockSource = l2BlockSource;
        this.localData = localData;
        this.handler = handler;
        this.log = log;
        this.opts = opts;
        this.isSyncing = false;
        this.hasStarted = false;
        this.runningPromise = new RunningPromise(()=>this.work(), log, this.opts.pollIntervalMS ?? 1000);
    }
    start() {
        this.log.verbose(`Starting L2 block stream`, this.opts);
        this.runningPromise.start();
    }
    async stop() {
        await this.runningPromise.stop();
    }
    isRunning() {
        return this.runningPromise.isRunning();
    }
    async sync() {
        this.isSyncing = true;
        await this.runningPromise.trigger();
        this.isSyncing = false;
    }
    async work() {
        try {
            const sourceTips = await this.l2BlockSource.getL2Tips();
            const localTips = await this.localData.getL2Tips();
            this.log.trace(`Running L2 block stream`, {
                sourceLatest: sourceTips.latest.number,
                localLatest: localTips.latest.number,
                sourceFinalized: sourceTips.finalized.number,
                localFinalized: localTips.finalized.number,
                sourceProven: sourceTips.proven.number,
                localProven: localTips.proven.number,
                sourceLatestHash: sourceTips.latest.hash,
                localLatestHash: localTips.latest.hash,
                sourceProvenHash: sourceTips.proven.hash,
                localProvenHash: localTips.proven.hash,
                sourceFinalizedHash: sourceTips.finalized.hash,
                localFinalizedHash: localTips.finalized.hash
            });
            // Check if there was a reorg and emit a chain-pruned event if so.
            let latestBlockNumber = localTips.latest.number;
            const sourceCache = new BlockHashCache([
                sourceTips.latest
            ]);
            while(!await this.areBlockHashesEqualAt(latestBlockNumber, {
                sourceCache
            })){
                latestBlockNumber--;
            }
            if (latestBlockNumber < localTips.latest.number) {
                this.log.verbose(`Reorg detected. Pruning blocks from ${latestBlockNumber + 1} to ${localTips.latest.number}.`);
                await this.emitEvent({
                    type: 'chain-pruned',
                    block: {
                        number: latestBlockNumber,
                        hash: sourceCache.get(latestBlockNumber) ?? await this.getBlockHashFromSource(latestBlockNumber)
                    }
                });
            }
            // If we are just starting, use the starting block number from the options.
            if (latestBlockNumber === 0 && this.opts.startingBlock !== undefined) {
                latestBlockNumber = Math.max(this.opts.startingBlock - 1, 0);
            }
            // Only log this entry once (for sanity)
            if (!this.hasStarted) {
                this.log.verbose(`Starting sync from block number ${latestBlockNumber}`);
                this.hasStarted = true;
            }
            // Request new blocks from the source.
            while(latestBlockNumber < sourceTips.latest.number){
                const from = latestBlockNumber + 1;
                const limit = Math.min(this.opts.batchSize ?? 20, sourceTips.latest.number - from + 1);
                this.log.trace(`Requesting blocks from ${from} limit ${limit} proven=${this.opts.proven}`);
                const blocks = await this.l2BlockSource.getPublishedBlocks(from, limit, this.opts.proven);
                if (blocks.length === 0) {
                    break;
                }
                await this.emitEvent({
                    type: 'blocks-added',
                    blocks
                });
                latestBlockNumber = blocks.at(-1).block.number;
            }
            // Update the proven and finalized tips.
            if (localTips.proven !== undefined && sourceTips.proven.number !== localTips.proven.number) {
                await this.emitEvent({
                    type: 'chain-proven',
                    block: sourceTips.proven
                });
            }
            if (localTips.finalized !== undefined && sourceTips.finalized.number !== localTips.finalized.number) {
                await this.emitEvent({
                    type: 'chain-finalized',
                    block: sourceTips.finalized
                });
            }
        } catch (err) {
            if (err.name === 'AbortError') {
                return;
            }
            this.log.error(`Error processing block stream`, err);
        }
    }
    /**
   * Returns whether the source and local agree on the block hash at a given height.
   * @param blockNumber - The block number to test.
   * @param args - A cache of data already requested from source, to avoid re-requesting it.
   */ async areBlockHashesEqualAt(blockNumber, args) {
        if (blockNumber === 0) {
            return true;
        }
        const localBlockHash = await this.localData.getL2BlockHash(blockNumber);
        const sourceBlockHashFromCache = args.sourceCache.get(blockNumber);
        const sourceBlockHash = args.sourceCache.get(blockNumber) ?? await this.getBlockHashFromSource(blockNumber);
        if (!sourceBlockHashFromCache && sourceBlockHash) {
            args.sourceCache.add({
                number: blockNumber,
                hash: sourceBlockHash
            });
        }
        this.log.trace(`Comparing block hashes for block ${blockNumber}`, {
            localBlockHash,
            sourceBlockHash
        });
        return localBlockHash === sourceBlockHash;
    }
    getBlockHashFromSource(blockNumber) {
        return this.l2BlockSource.getBlockHeader(blockNumber).then((h)=>h?.hash()).then((hash)=>hash?.toString());
    }
    async emitEvent(event) {
        this.log.debug(`Emitting ${event.type} (${event.type === 'blocks-added' ? event.blocks.length : event.block.number})`);
        await this.handler.handleBlockStreamEvent(event);
        if (!this.isRunning() && !this.isSyncing) {
            throw new AbortError();
        }
    }
}
class BlockHashCache {
    cache = new Map();
    constructor(initial = []){
        for (const block of initial){
            this.add(block);
        }
    }
    add(block) {
        if (block.hash) {
            this.cache.set(block.number, block.hash);
        }
    }
    get(blockNumber) {
        return this.cache.get(blockNumber);
    }
}

import { jsonParseWithSchema, jsonStringify } from '@aztec/foundation/json-rpc';
import { schemas } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { PublicKeys } from '../keys/public_keys.js';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { NullifierLeafPreimage } from '../trees/nullifier_leaf.js';
import { PublicDataTreeLeafPreimage } from '../trees/public_data_leaf.js';
import { AvmCircuitPublicInputs } from './avm_circuit_public_inputs.js';
import { serializeWithMessagePack } from './message_pack.js';
////////////////////////////////////////////////////////////////////////////
// Hints (contracts)
////////////////////////////////////////////////////////////////////////////
export class AvmContractClassHint {
    classId;
    artifactHash;
    privateFunctionsRoot;
    packedBytecode;
    constructor(classId, artifactHash, privateFunctionsRoot, packedBytecode){
        this.classId = classId;
        this.artifactHash = artifactHash;
        this.privateFunctionsRoot = privateFunctionsRoot;
        this.packedBytecode = packedBytecode;
    }
    static get schema() {
        return z.object({
            classId: schemas.Fr,
            artifactHash: schemas.Fr,
            privateFunctionsRoot: schemas.Fr,
            packedBytecode: schemas.Buffer
        }).transform(({ classId, artifactHash, privateFunctionsRoot, packedBytecode })=>new AvmContractClassHint(classId, artifactHash, privateFunctionsRoot, packedBytecode));
    }
}
export class AvmBytecodeCommitmentHint {
    classId;
    commitment;
    constructor(classId, commitment){
        this.classId = classId;
        this.commitment = commitment;
    }
    static get schema() {
        return z.object({
            classId: schemas.Fr,
            commitment: schemas.Fr
        }).transform(({ classId, commitment })=>new AvmBytecodeCommitmentHint(classId, commitment));
    }
}
export class AvmContractInstanceHint {
    address;
    salt;
    deployer;
    currentContractClassId;
    originalContractClassId;
    initializationHash;
    publicKeys;
    constructor(address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys){
        this.address = address;
        this.salt = salt;
        this.deployer = deployer;
        this.currentContractClassId = currentContractClassId;
        this.originalContractClassId = originalContractClassId;
        this.initializationHash = initializationHash;
        this.publicKeys = publicKeys;
    }
    static get schema() {
        return z.object({
            address: AztecAddress.schema,
            salt: schemas.Fr,
            deployer: AztecAddress.schema,
            currentContractClassId: schemas.Fr,
            originalContractClassId: schemas.Fr,
            initializationHash: schemas.Fr,
            publicKeys: PublicKeys.schema
        }).transform(({ address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys })=>new AvmContractInstanceHint(address, salt, deployer, currentContractClassId, originalContractClassId, initializationHash, publicKeys));
    }
}
////////////////////////////////////////////////////////////////////////////
// Hints (merkle db)
////////////////////////////////////////////////////////////////////////////
// Hint for MerkleTreeDB.getSiblingPath.
export class AvmGetSiblingPathHint {
    hintKey;
    treeId;
    index;
    path;
    constructor(hintKey, // params
    treeId, index, // return
    path){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.index = index;
        this.path = path;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            index: schemas.BigInt,
            path: schemas.Fr.array()
        }).transform(({ hintKey, treeId, index, path })=>new AvmGetSiblingPathHint(hintKey, treeId, index, path));
    }
}
// Hint for MerkleTreeDB.getPreviousValueIndex.
export class AvmGetPreviousValueIndexHint {
    hintKey;
    treeId;
    value;
    index;
    alreadyPresent;
    constructor(hintKey, // params
    treeId, value, // return
    index, alreadyPresent){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.value = value;
        this.index = index;
        this.alreadyPresent = alreadyPresent;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            value: schemas.Fr,
            index: schemas.BigInt,
            alreadyPresent: z.boolean()
        }).transform(({ hintKey, treeId, value, index, alreadyPresent })=>new AvmGetPreviousValueIndexHint(hintKey, treeId, value, index, alreadyPresent));
    }
}
// Hint for MerkleTreeDB.getLeafPreimage.
// NOTE: I need this factory because in order to get hold of the schema, I need an actual instance of the class,
// having the type doesn't suffice since TS does type erasure in the end.
function AvmGetLeafPreimageHintFactory(klass) {
    return class AvmGetLeafPreimageHint {
        hintKey;
        index;
        leafPreimage;
        constructor(hintKey, // params (tree id will be implicit)
        index, // return
        leafPreimage){
            this.hintKey = hintKey;
            this.index = index;
            this.leafPreimage = leafPreimage;
        }
        static get schema() {
            return z.object({
                hintKey: AppendOnlyTreeSnapshot.schema,
                index: schemas.BigInt,
                leafPreimage: klass.schema
            }).transform(({ hintKey, index, leafPreimage })=>new AvmGetLeafPreimageHint(hintKey, index, leafPreimage));
        }
    };
}
// Note: only supported for PUBLIC_DATA_TREE and NULLIFIER_TREE.
export class AvmGetLeafPreimageHintPublicDataTree extends AvmGetLeafPreimageHintFactory(PublicDataTreeLeafPreimage) {
}
export class AvmGetLeafPreimageHintNullifierTree extends AvmGetLeafPreimageHintFactory(NullifierLeafPreimage) {
}
// Hint for MerkleTreeDB.getLeafValue.
// Note: only supported for NOTE_HASH_TREE and L1_TO_L2_MESSAGE_TREE.
export class AvmGetLeafValueHint {
    hintKey;
    treeId;
    index;
    value;
    constructor(hintKey, // params
    treeId, index, // return
    value){
        this.hintKey = hintKey;
        this.treeId = treeId;
        this.index = index;
        this.value = value;
    }
    static get schema() {
        return z.object({
            hintKey: AppendOnlyTreeSnapshot.schema,
            treeId: z.number().int().nonnegative(),
            index: schemas.BigInt,
            value: schemas.Fr
        }).transform(({ hintKey, treeId, index, value })=>new AvmGetLeafValueHint(hintKey, treeId, index, value));
    }
}
// Hint for MerkleTreeDB.sequentialInsert.
// NOTE: I need this factory because in order to get hold of the schema, I need an actual instance of the class,
// having the type doesn't suffice since TS does type erasure in the end.
function AvmSequentialInsertHintFactory(klass) {
    return class AvmSequentialInsertHint {
        hintKey;
        stateAfter;
        treeId;
        leaf;
        lowLeavesWitnessData;
        insertionWitnessData;
        constructor(hintKey, stateAfter, // params
        treeId, leaf, // return
        lowLeavesWitnessData, insertionWitnessData){
            this.hintKey = hintKey;
            this.stateAfter = stateAfter;
            this.treeId = treeId;
            this.leaf = leaf;
            this.lowLeavesWitnessData = lowLeavesWitnessData;
            this.insertionWitnessData = insertionWitnessData;
        }
        static get schema() {
            return z.object({
                hintKey: AppendOnlyTreeSnapshot.schema,
                stateAfter: AppendOnlyTreeSnapshot.schema,
                treeId: z.number().int().nonnegative(),
                leaf: klass.leafSchema,
                lowLeavesWitnessData: z.object({
                    leaf: klass.schema,
                    index: schemas.BigInt,
                    path: schemas.Fr.array()
                }),
                insertionWitnessData: z.object({
                    leaf: klass.schema,
                    index: schemas.BigInt,
                    path: schemas.Fr.array()
                })
            }).transform(({ hintKey, stateAfter, treeId, leaf, lowLeavesWitnessData, insertionWitnessData })=>new AvmSequentialInsertHint(hintKey, stateAfter, treeId, leaf, lowLeavesWitnessData, insertionWitnessData));
        }
    };
}
// Note: only supported for PUBLIC_DATA_TREE and NULLIFIER_TREE.
export class AvmSequentialInsertHintPublicDataTree extends AvmSequentialInsertHintFactory(PublicDataTreeLeafPreimage) {
}
export class AvmSequentialInsertHintNullifierTree extends AvmSequentialInsertHintFactory(NullifierLeafPreimage) {
}
////////////////////////////////////////////////////////////////////////////
// Hints (other)
////////////////////////////////////////////////////////////////////////////
export class AvmEnqueuedCallHint {
    msgSender;
    contractAddress;
    calldata;
    isStaticCall;
    constructor(msgSender, contractAddress, calldata, isStaticCall){
        this.msgSender = msgSender;
        this.contractAddress = contractAddress;
        this.calldata = calldata;
        this.isStaticCall = isStaticCall;
    }
    static get schema() {
        return z.object({
            msgSender: AztecAddress.schema,
            contractAddress: AztecAddress.schema,
            calldata: schemas.Fr.array(),
            isStaticCall: z.boolean()
        }).transform(({ msgSender, contractAddress, calldata, isStaticCall })=>new AvmEnqueuedCallHint(msgSender, contractAddress, calldata, isStaticCall));
    }
}
export class AvmTxHint {
    nonRevertibleAccumulatedData;
    revertibleAccumulatedData;
    setupEnqueuedCalls;
    appLogicEnqueuedCalls;
    teardownEnqueuedCall;
    constructor(nonRevertibleAccumulatedData, revertibleAccumulatedData, setupEnqueuedCalls, appLogicEnqueuedCalls, // We need this to be null and not undefined because that's what
    // MessagePack expects for an std::optional.
    teardownEnqueuedCall){
        this.nonRevertibleAccumulatedData = nonRevertibleAccumulatedData;
        this.revertibleAccumulatedData = revertibleAccumulatedData;
        this.setupEnqueuedCalls = setupEnqueuedCalls;
        this.appLogicEnqueuedCalls = appLogicEnqueuedCalls;
        this.teardownEnqueuedCall = teardownEnqueuedCall;
    }
    static fromTx(tx) {
        const setupCallRequests = tx.getNonRevertiblePublicCallRequestsWithCalldata();
        const appLogicCallRequests = tx.getRevertiblePublicCallRequestsWithCalldata();
        const teardownCallRequest = tx.getTeardownPublicCallRequestWithCalldata();
        return new AvmTxHint({
            noteHashes: tx.data.forPublic.nonRevertibleAccumulatedData.noteHashes.filter((x)=>!x.isZero()),
            nullifiers: tx.data.forPublic.nonRevertibleAccumulatedData.nullifiers.filter((x)=>!x.isZero())
        }, {
            noteHashes: tx.data.forPublic.revertibleAccumulatedData.noteHashes.filter((x)=>!x.isZero()),
            nullifiers: tx.data.forPublic.revertibleAccumulatedData.nullifiers.filter((x)=>!x.isZero())
        }, setupCallRequests.map((call)=>new AvmEnqueuedCallHint(call.request.msgSender, call.request.contractAddress, call.calldata, call.request.isStaticCall)), appLogicCallRequests.map((call)=>new AvmEnqueuedCallHint(call.request.msgSender, call.request.contractAddress, call.calldata, call.request.isStaticCall)), teardownCallRequest ? new AvmEnqueuedCallHint(teardownCallRequest.request.msgSender, teardownCallRequest.request.contractAddress, teardownCallRequest.calldata, teardownCallRequest.request.isStaticCall) : null);
    }
    static empty() {
        return new AvmTxHint({
            noteHashes: [],
            nullifiers: []
        }, {
            noteHashes: [],
            nullifiers: []
        }, [], [], null);
    }
    static get schema() {
        return z.object({
            nonRevertibleAccumulatedData: z.object({
                noteHashes: schemas.Fr.array(),
                nullifiers: schemas.Fr.array()
            }),
            revertibleAccumulatedData: z.object({
                noteHashes: schemas.Fr.array(),
                nullifiers: schemas.Fr.array()
            }),
            setupEnqueuedCalls: AvmEnqueuedCallHint.schema.array(),
            appLogicEnqueuedCalls: AvmEnqueuedCallHint.schema.array(),
            teardownEnqueuedCall: AvmEnqueuedCallHint.schema.nullable()
        });
    }
}
export class AvmExecutionHints {
    tx;
    contractInstances;
    contractClasses;
    bytecodeCommitments;
    getSiblingPathHints;
    getPreviousValueIndexHints;
    getLeafPreimageHintsPublicDataTree;
    getLeafPreimageHintsNullifierTree;
    getLeafValueHints;
    sequentialInsertHintsPublicDataTree;
    sequentialInsertHintsNullifierTree;
    constructor(tx, // Contract hints.
    contractInstances = [], contractClasses = [], bytecodeCommitments = [], // Merkle DB hints.
    getSiblingPathHints = [], getPreviousValueIndexHints = [], getLeafPreimageHintsPublicDataTree = [], getLeafPreimageHintsNullifierTree = [], getLeafValueHints = [], sequentialInsertHintsPublicDataTree = [], sequentialInsertHintsNullifierTree = []){
        this.tx = tx;
        this.contractInstances = contractInstances;
        this.contractClasses = contractClasses;
        this.bytecodeCommitments = bytecodeCommitments;
        this.getSiblingPathHints = getSiblingPathHints;
        this.getPreviousValueIndexHints = getPreviousValueIndexHints;
        this.getLeafPreimageHintsPublicDataTree = getLeafPreimageHintsPublicDataTree;
        this.getLeafPreimageHintsNullifierTree = getLeafPreimageHintsNullifierTree;
        this.getLeafValueHints = getLeafValueHints;
        this.sequentialInsertHintsPublicDataTree = sequentialInsertHintsPublicDataTree;
        this.sequentialInsertHintsNullifierTree = sequentialInsertHintsNullifierTree;
    }
    static empty() {
        return new AvmExecutionHints(AvmTxHint.empty());
    }
    static get schema() {
        return z.object({
            tx: AvmTxHint.schema,
            contractInstances: AvmContractInstanceHint.schema.array(),
            contractClasses: AvmContractClassHint.schema.array(),
            bytecodeCommitments: AvmBytecodeCommitmentHint.schema.array(),
            getSiblingPathHints: AvmGetSiblingPathHint.schema.array(),
            getPreviousValueIndexHints: AvmGetPreviousValueIndexHint.schema.array(),
            getLeafPreimageHintsPublicDataTree: AvmGetLeafPreimageHintPublicDataTree.schema.array(),
            getLeafPreimageHintsNullifierTree: AvmGetLeafPreimageHintNullifierTree.schema.array(),
            getLeafValueHints: AvmGetLeafValueHint.schema.array(),
            sequentialInsertHintsPublicDataTree: AvmSequentialInsertHintPublicDataTree.schema.array(),
            sequentialInsertHintsNullifierTree: AvmSequentialInsertHintNullifierTree.schema.array()
        }).transform(({ tx, contractInstances, contractClasses, bytecodeCommitments, getSiblingPathHints, getPreviousValueIndexHints, getLeafPreimageHintsPublicDataTree, getLeafPreimageHintsNullifierTree, getLeafValueHints, sequentialInsertHintsPublicDataTree, sequentialInsertHintsNullifierTree })=>new AvmExecutionHints(tx, contractInstances, contractClasses, bytecodeCommitments, getSiblingPathHints, getPreviousValueIndexHints, getLeafPreimageHintsPublicDataTree, getLeafPreimageHintsNullifierTree, getLeafValueHints, sequentialInsertHintsPublicDataTree, sequentialInsertHintsNullifierTree));
    }
}
export class AvmCircuitInputs {
    functionName;
    calldata;
    hints;
    publicInputs;
    constructor(functionName, calldata, hints, publicInputs){
        this.functionName = functionName;
        this.calldata = calldata;
        this.hints = hints;
        this.publicInputs = publicInputs;
    }
    static empty() {
        return new AvmCircuitInputs('', [], AvmExecutionHints.empty(), AvmCircuitPublicInputs.empty());
    }
    static get schema() {
        return z.object({
            functionName: z.string(),
            calldata: schemas.Fr.array(),
            hints: AvmExecutionHints.schema,
            publicInputs: AvmCircuitPublicInputs.schema
        }).transform(({ functionName, calldata, hints, publicInputs })=>new AvmCircuitInputs(functionName, calldata, hints, publicInputs));
    }
    serializeWithMessagePack() {
        return serializeWithMessagePack(this);
    }
    // These are used by the prover to generate an id, and also gcs_proof_store.ts.
    toBuffer() {
        return Buffer.from(jsonStringify(this));
    }
    static fromBuffer(buf) {
        return jsonParseWithSchema(buf.toString(), this.schema);
    }
}

{"noir_version":"1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec","name":"PrivateMessenger","functions":[{"name":"constructor","hash":"13116034492861280854","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"tZndbhs5DIXfxde50A8pUnmVoijc1F0YMJzATRZYFHn3JS1SYxeQMJm2Nzmfk8yxRJGUZP/cfTt8ffvny/H8/fnH7vHTz93Xy/F0Ov7z5fT8tH89Pp/ltz93QX9E2D3Cwy7i7pFEShNqwk3qVVJoEnePLJKa5CbQBJuUJtSEm4hLDA+7HEyjaTIVp5hFwRRNiymZsqn6ycghmEbTZJpNwVT9imgxJVP1q6K1KQbTaJpMsymYil+ScWMxFb+URNlU/JL4l2AaTZNpNhW/LM8XNC2mZMqmtSkF02iaTLOp+ZH5kfmR+qEom9amHEyjaTLNpmCKpsXU/Fj9ZB5cm9ZgGk2TaTYFUzQtpmRqftX8YggO0UEtNWlDdgAHdCgO5MAO1SAGh+jgztGdoztrTWStBq2DXBXkKQgKySE7gIM8BZINUdMeskJ0SA7ZARzQQWYBqEAO7FANtAAaRIfkkB3UOSqgQ3EgB3XW8GolXEFLAXTKWgsNkoM6axC0HFAnqPWA104izqhvqhXRgB3EGfUpLYqiT2k1XOOj5dAAHNBBDItGQ0vgGhbyYJIHU6ug6LtrGTQAB/Ep+u5aCe2fyYEd3Jndmd2ZfZnYl4l9mdiXid2Z3VCzv2gMNf0bZAcdGCugQ3EgB/EpGiitAoWkVdAgOogzBQXt3VGhOJCDdvCkUA005xtEh+SQHcBBnbNCcSAHdqgG1/3hCtEhOejjqKD/XHTbCA7RITlkB3DQYVw3m+JADuxQDbQcGkSH5KDOGjothwboUBzIgR2qBVPLoUF0SA66pro5as5fZ6o536AaaM430B1UF674BDXVGxQH3TvVWdt/g2qgyc+6OuShIw8deejIncmdyZ01+Ruwgy8K+6KwO/PV8P39Yecnhy+vl8NBDw43Rwk5YLzsL4fz6+7x/HY6Pez+3Z/erv/042V/vurr/iJ/lUkfzt9ExfD78XRQen9Yng7jR2Oqlexx6aGYuoX0/DuTODHBWtyjxHJjke4s0sSCKncPqhW7Sal3HnnskSX92TyEE4w8ZlMpugfZVDgNp4JjC8l1H0XCvKyJNO47izIZBUdfU2mCY4vVo8hDi9WxqMNY1LEF6QZzdSBa8gLS6iFQyj0riIZDiHGWFgyeFRloHIlJekpf9lAkaVhjj7XjmHmsDAfDOBz4F5eEYclNHBd7pEk4Qyo9niExDyuVJ/EEiD4VYRyX+3QkOS0jEZuNJiHcmAybV5qlB/o4MsVuIFvp+oUpy8JwHHfhPJuJLGmfCd80wF9nAmMTlt5rHpzDeEdJ+CcWd9pF0xKQcbWkydLmEPuWEmHiwbOKQx8HlZuFybHce0waKS69GMvNLp0/MIqKvfBzGo4iTyJKkHvzAA5jjzTLcw8G3BwV5Cx77zBLUrkG9GYc6thjkqPYq/52i/6QQz83lYjb5pHyMg9I2zwo9nql2Uz473rIbbI3n0K8zYNo2d3qOB4wzdBealA2OVTwMqnImxykN/S+E8o4N2CSXQDFcwOgLuOIdX04a+jHt5rG4Zx20OVyUG8PkWH9caH2tiN37PGuBJOZAPYzC+BtctW4dhi6RfdhAI/P9bO7UsW+sQlDGO1JOD0FZsLlklLDho0tLZuSfEoRxpOZXZZ6mkNMS6XgB9YVljGM13UWTzkR96aRZb8fnhRwclfCfs8pYTwMpD9w90T+A5fP2VxKv/aVPL57lllMKSP0uWSqo2GUWY7K9SQvV5U8DMi0jwZvHTVt7MTFq60S/m4vp417dO6RkN06btznl8vj7Xn4V49Cv70fzCzkw/debRF40zBi7GsS5fa3zSPffOJUN44DU58L3tzpP+bR76DyUXrdOJdlj5VuNvQg+N0jy8xh3ZFl5rD2yEJ/OUUz9OaVkbYFY1XfmTqs6jsrF+RXh8/ycv90vNx9Z/yuVpfj/uvpYC+/v52fbv76+t+L/8W/c365PD8dvr1dDuq0fPEsPz6lyg851s/6pZy+lN1Njkr6Uj6A/iS700NO+PldB/M/","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"9626575571355737262","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"TL3L0iy7jpz5LnvcgyRAAMR5lR7IWn2RlVmZyqwljerl9QdA0H1S6/NTe9ERjIBnZCQy13/+8//8v//1f/23//Jv//3/+4//8c+//s///Oe//v//9u///m//7b/8+3/83//X//y3//jvf//rf/7z+/5P5D//0v/jn/Mn/O+P9c+/zt8f8s+/1u/vT/37U/7+3H9/7r8/7Z9/fX94/xH9x/n7f35/N/vP/N0/1/1T7p96/9z3T7t/+v0z7p93vbzrrd9vYA3IgA7sARvwgRg4A7PympXXrLxm5TUrr1l5zcprVl6z8pqV16wss7LMyjIry6wss7LMyjIry6wss7LMyjor66yss7LOyjor66yss7LOyjor66y8Z+U9K+9Zec/Ke1bes/KelfesvGflPSvbrGyzss3KNivbrGyzss3KNivbrGyzss/KPiv7rOyzss/K/rey/D7wgRg4A3khfgNrQAZ0YA/MyjErx7fy+uAM5IWv1xrWgAzowLfy/uBb+XzgAzFwBvLC13oNfyurfCADOrAH/lZW/cAHYuBb+duxrwc/kK8HG76V8wMZ0IE9YAM+EANnIC98PdgwK69Zec3Ka1b+enCvD3wgBs5AXvh6sGENyIAO7IFZWWZlmZVlVpZZWWdlnZV1VtZZWWdlnZV1VtZZWWdlnZX3rLxn5T0rfz249YM9YAM+EANnIC98PdiwBmRgVrZZ2WZlm5VtVrZZ2WZln5V9VvZZ2Wdln5V9VvZZ2Wdln5V9Vo5ZOWblmJVjVo5ZOWblmJVjVo5ZOWblMyufWfnMymdWPrPymZXPrHxm5TMrn1k5Z+WclXNWzlk5Z+WclXNWzlk5Z+W8K+vvN7AGZEAH9oAN+EAMnIFv5b+m1q8HG9aADOjAHrABH4iBMzAry6wss7LMytWD+cEesIG/lW1/EANnIC98PdiwBmRAB/aADczKOivrrKyz8r6JpHsNyIAO7AEb8IEYOAM369RmZZuVbVa2WfnrQYsPbMAHYuAM5IWvBxvWgAzowKzss7LPyj4r+6z89aD9vZTo14MNa0AGdGAP2IAPxMAZmJXPrHxm5TMrfz3o9sEesAEfiIEzkBe+HmxYAzIwK+esnLNyzso5K+esnHfl/fsNrAEZ0IE9YAM+EANnYFZes/KaldesvGblNSuvWXnNymtWXrPympVlVpZZWWZlmZVlVpZZWWZlmZVlVpZZWWdlnZV1VtZZWWdlnZV1VtZZWWdlnZX3rLxn5T0r71l5z8p7Vt6z8p6V96y8Z2WblW1WtlnZZmWblW1WtlnZZmWblW1W9lnZZ2WflX1W9lnZZ2WflX1W9lnZZ+WYlWNWjlk5ZuWYlWNWjlk5ZuWYlWNWPrPymZXPrDw9uKcH9/Tgnh7c04N7enBPD+7pwT09uKcH9/Tgnh7c04N7enBPD+7pwT09aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PWjTgzY9aNODNj1o04M2PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj3o04M+PejTgz496NODPj0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9GNODMT0Y04MxPRjTgzE9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgmR4804NnevBMD57pwTM9eKYHz/TgqR78PqOsHjzf542/gb+VQz6QAR3YAzbgAzFwBvLC14MNs/KaldesvGblNSuvWXnNymtWXrOyzMoyK8usLLOyzMoyK8usLLOyzMoyK+usrLOyzso6K+usrLOyzso6K+usrLPynpX3rLxn5T0r71l5z8p7Vt6z8p6V96xss7LNyjYr26xss7LNyjYr26xss7LNyj4r+6zss7LPyj4r+6zss7LPyj4r+6wcs3LMyjErx6wcs3LMyjErx6wcs3LMymdWPrPymZXPrHxm5TMrn1n5zMpnVj6zcs7KOSvnrJyzcs7KOSvnrJyzcs7KeVf++4z+92g9kkf6aD+yR/4oHp1Hz2M9j/U81vNYz2M9j/U81vNYz2M9j/U85HnI85DnIc9Dnoc8D3ke8jzkecjz0Oehz0Ofhz4PfR76PPR56PPQ56HPYz+P/Tz289jPYz+P/Tz289jPYz+P/TzsedjzsOdhz8Oehz0Pex72POx52PPw5+HPw5+HPw9/Hv48/Hn48/Dn4c8jnkc8j3ge8TziecTziOcRzyOeRzyP8zzO8zjP4zyP8zzO8zjP4zyP8zzO88jnkc8jn0c+j3we+TzyeeTzyOfx+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6fL0+X6/P1+vz9fp8vT5fr8/X6/P1+ny9Pl+vz9fr8/X6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/l9bm8PpfX5/L6XF6fy+tzeX0ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6XF+f6+tzfX2ur8/19bm+PtfX5/r6fL8+36/P9+vz/fp8vz7fr8/36/P9+ny/Pt+vz/fr8/36fL8+36/Pa4wpdpE98kfx6DzKoerzpvVIHumj5yHPQ56HPA95HvI89Hno89Dnoc9Dn4c+D30e+jz0eejz2M9jP4/9PPbz2M9jP4/9PPbz2M9jPw97HvY87HnY87DnYc/Dnoc9D3se9jz8efjz8Ofhz8Ofhz8Pfx7+PPx5+POI5xHPI55HPI94HvE84nnE84jnEc/jPI/zPM7zOM/jPI/zPM7zOM/jPI/zPPJ55PPI55HPI59HPo98Hvk88nnkeNRw1KX1SB7po/3IHvmjeHQePY/1PNbzWM9jPY/X5/b63F6f2+tze31e81LR3w/5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","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"10797080900716432763","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"10492081608786484886":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"send_message","hash":"12088914895469533613","is_unconstrained":false,"custom_attributes":["private"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"part0","type":{"kind":"field"},"visibility":"private"},{"name":"part1","type":{"kind":"field"},"visibility":"private"},{"name":"part2","type":{"kind":"field"},"visibility":"private"},{"name":"part3","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"include_by_timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"note_hash_read_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_read_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"key_validation_requests_and_generators","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"std::embedded_curve_ops::EmbeddedCurvePoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}},{"name":"is_infinite","type":{"kind":"boolean"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hashes","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifiers","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_call_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":5,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_call_requests","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_teardown_call_request","type":{"kind":"struct","path":"aztec::protocol_types::abis::public_call_request::PublicCallRequest","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"calldata_hash","type":{"kind":"field"}}]}},{"name":"l2_to_l1_msgs","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"private_logs","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_log::PrivateLogData","fields":[{"name":"log","type":{"kind":"struct","path":"aztec::protocol_types::abis::log::Log","fields":[{"name":"fields","type":{"kind":"array","length":18,"type":{"kind":"field"}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"contract_class_logs_hashes","type":{"kind":"struct","path":"aztec::protocol_types::utils::arrays::ClaimedLengthArray","fields":[{"name":"array","type":{"kind":"array","length":1,"type":{"kind":"struct","path":"aztec::protocol_types::abis::side_effect::counted::Counted","fields":[{"name":"inner","type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"length","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::abis::block_header::BlockHeader","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"blobs_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::abis::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::abis::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"slot_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}},{"name":"total_fees","type":{"kind":"field"}},{"name":"total_mana_used","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}},{"name":"max_priority_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"integer","sign":"unsigned","width":128}},{"name":"fee_per_l2_gas","type":{"kind":"integer","sign":"unsigned","width":128}}]}}]}}]}}]},"visibility":"databus"},"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d56PrfHSdj67z0XU+us5H1/noOh9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XU+u85n1/nsOp9d57PrfHadz67z2XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1/nqOl9d56vrfHWdr67z1XW+us5X1znakrJZOescdJpuUdY5aDTNptW0m6ypPaI9oj2iPU57nPY47XHa47THaY/THqc9Tnuc9rjtcdvjtsdtj9setz1ue9z2uO1xywONS6DRNJtW026yJm+KptPUHqM9RnuM9hjtMdpjtMdoj9Eeoz1Ge8z2mO0x22O2x2yP2R6zPWZ7zPaY7bHaY7XHao/VHqs9Vnus9ljtsdpjtcduj90euz12e+z22O2x22O3x26P3R7WHtYe1h7WHtYe1h7WHtYe1h7WHt4e3h7eHt4e3h7eHl3nu+t8d53vrvPddZ79Tz6SZtNq2k3W5E3RdJpu0Vfnj9rjtMdpj9Mepz1Oe5z2OO1x2uO2x22P2x63PW573Pa47XHb47bHLY9sjno0mmbTatpN1uRN0XSa2mO0x2iP0R6jPUZ7jPYY7THaY7THaI/ZHrM9ZnvM9pjtMdtjtsdsj9kesz1We6z2WO2x2mO1x2qP1R6rPVZ7rPbY7bHbY7fHbo/dHrs9dnvs9tjtsdvD2sPaw9rD2sPaw9rD2sPaw9rD2sPbw9vD28Pbw9vD28Pbw9vD28PbI9qj69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOrevcus6t69y6zq3r3LrOs//K8XtPv6bRNJtW026yJm+KptPUHqM9RnuM9hjtMdpjtMdoj9Eeoz1Ge8z2mO0x22O2x2yPr87jl+RN0XSabtFX549G02xaTbupPb46j5EUTafpFn11/mg0zabVtJusqT12e+z22O3x1XmspNE0m1bTbrImb4qm03SLvD28Pbw9vD28Pbw9vD28Pbw9vD2iPaI9oj2iPaI9oj2iPaI9oj2iPb46D/xm32iaTX8eZybtJmv68zgYJZpO05/H+X4VM1u7Ho2m2bSadpM1eVM0nabyyCavR6NpNn0e+G3F3WRNn8dNiqbTdIu+On80mmbTatpN1tQeoz1Ge4z2+Or8/pJG02xaTbvJmrwpmk7TLVrtsdpjtcdqj9Ueqz1We6z2WO2x2mO3x26P3R67PXZ77PbY7bHbY7fHbg9rD2sPaw9rD2sPaw9rD2sPaw9rD28Pbw9vD28Pbw9vD28Pbw9vD2+PaI9oj2iPaI9oj2iPaI9oj2iPaI/THqc9Tnuc9jjtcdrjtMdpj9Mepz1ue9z2uO1x2+O2x22P2x63PW573PLIRrJHo2k2rabdZE3eFE2nqT1Ge4z2GO0x2mO0x2iP0R6jPb46vzPpFmWdg0bTbFpNu8mavCma2mO2x2qP1R6rPVZ7rPZY7bHaY7XHao/VHrs9dnvs9tjtsdtjt8duj90euz12e1h7WHtYe1h7WHtYe1h7WHtYe1h7eHt4e3h7eHt4e3h7eHt4e3h7eHtEe0R7RHtEe0R7RHtEe0R7RHtEe5z2OO1x2uO0x2mP0x6nPU57nPY47XHb47bHbY/bHrc9bnvc9rjtcdvjlkc2qz0aTbNpNe0ma/KmaDpN7THaY7THaI/RHqM9RnuM9hjt0XV+u85v1/ntOr9d57fr/Had367z23V+u85v1/ntOr9d57fr/Had367z23V+u85v1/ntOr9d57fr/Had367z23V+u85v1/ntOr9d57fr/Had367z23V+u85v1/ntOr9d57fr/Had367z23V+u85v1/ntOr9d57fr/Had367z23V+u85v1/ntOr9d57fr/Had367z23V+u85v1/ntOr9d57fr/Had367z23V+u85v13l2wF1L8qZoOk23KOscNJpm02raTe1x2+O2x22PrHPP78v4NY2m2bSadpM1eVM0nab2GO0x2mO0x2iP0R6jPUZ7jPYY7THaY7bHbI/ZHrM9ZnvM9pjtMdtjtsdsj9Ueqz1We6z2WO2x2mO1x2qP1R6rPXZ77PbY7bHbY7fHbo/dHrs9dnvs9rD2sPaw9rD2sPaw9rD2sPbIr376/RJvY34F1MPx4UqcxEXcRCM6MYiHeBvzq6Ie0i3oFnQLugXdgm5Bt6Bb0O3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0u3S7dLt0u3S7bYbvqHq4SBO4iJuohGdGMRDpNug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptumm9HN6GZ0M7oZ3YxuRjejm9HN6OZ0Y5YMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglgxmyWCWDGbJYJYMZslglkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJZMZslklkxmyWSWTGbJZJYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixmyWKWLGbJYpYsZslilixkiScG8RBvI7IEOIiTuIibaES6Lbotui26IUsicRAncRE30YhODOIh3kajm9HN6GZ0M7oZ3YxuRjejm9HN6eZ0c7o53ZxuTjenm9PN6eZ0C7oF3YJuQbegW9At6BZ0C7oF3Q7dDt0O3Q7dDt0O3Q7dDt0O3Q7dLt0u3S7dLt0u3S7dLt0u3S7dbrvt3484iJO4iJtoRCcG8RDpNug26DboNug26JZZ8n357Myuw8Igfm5jJ97GzJKHgziJi7iJRnRiEOk26bbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oNuh26Hboduh26Hboduh26Hboduh26Xbpdul26Xbpdul26Xbpdul22237GQsHMRJXMRNNKITg3iIdBt0G3QbdBt0G3QbdBt0G3RjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SYJcYsMWaJMUuMWWLMEmOWGLPEmCXGLDFmiTFLjFlizBJjlhizxJglxiwxZokxS4xZYswSY5YYs8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0ucWeLMEmeWOLPEmSXOLHFmiTNLnFnizBJnljizxJklzixxZokzS5xZ4swSZ5Y4s8SZJc4scWaJM0uCWRLMkmCWBLMkmCXBLAlmSTBLglkSzJJglgSyJBIncRE30YhODOIh3kZkCZBuk26TbpNumSVzJDoxiId4GzNLHg7iJC7iJtJt0W3RbdFt0W3TbdNt023TbdMts2T+Ep0YxEO8jZklDwdxEhdxE+lmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeh26Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbbLbs+CwdxEhdxE43oxCAeIt0G3QbdBt0G3QbdBt0G3QbdBt0G3SbdJt0m3SbdJt0m3SbdJt0m3SbdFt0W3RbdFt0W3RbdFt0W3RbdFt023TbdNt023TbdmCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWHWXKYJYdZcpglh1lymCWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1lymSWXWXKZJZdZcpkll1lykSUzcRON6MQgHuJtRJYAB3ES6bbotui26Lbotui26Lbptum26bbptum26bbptum26bbpZnQzuhndjG5GN6Ob0c3oZnQzujndnG5ON6eb083p5nRzujndnG5Bt6Bb0C3oFnQLugXdgm5Bt6Dboduh26HboRuyxBON6MR0O4mHeBuRJcBBnMRF3EQjOpFul2633Nbv9yMO4iQu4iYa0YlBPES6DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26bboZ3YxuRjejm9HN6GZ0M7oZ3YxuTjenm9PN6eZ0c7o53ZxuTjenW9At6BZ0C7oF3YJuQbegW9At6Hboduh26Hboduh26Hboduh26Hbodul26Xbpdul26Xbpdul26XbpxiwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsGcySwSwZzJLBLBnMksEsmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySyZzJLJLJnMksksmcySySxB3+v3V2UX+l4fHuLnttaHmSUPB3ESF3ETjejEIB4i3YJuyJJInMRF3EQjOjGIh3gbkSVAuh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbrddkPf68NBnMRF3EQjOjGIh0i3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt8yS/Bu96Ht96MTP7f2F3UO8jZkl3x9aXuh7fTiJi7iJRnRiEA/xNm66bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeh26Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbbDX2vDwdxEhdxE43oxCAeIt0G3QbdBt0G3QbdBt0G3QbdBt0G3Sbd8JnwTZzERdxEIzoxiId4G9FfAqTbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm6Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul26XbrfdXt8rcBAncRE30YhODOIh0m3QbdAts2R74iJuYt4pnEQnBvEQb2NmycNBnMRF3ES6TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bbptum26Gd2MbkY3o5vRzehmdDO6Gd2Mbk43p5vTzenmdHO6Od2cbk43p1vQLegWdAu6Bd2CbkG3oFvQLeh26Hboduh26Hboduh26Hboduh26Hbpdul26Xbpdul26Xbpdul2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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"1682865016165857438","is_unconstrained":true,"custom_attributes":["utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"576755928210959028":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"1004672304334401604":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"3206131020419630384":{"error_kind":"fmtstring","length":75,"item_types":[]},"3305101268118424981":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"3738765135689704617":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8270195893599566439":{"error_kind":"string","string":"Invalid public keys hint for address"},"10676044680617262041":{"error_kind":"fmtstring","length":98,"item_types":[{"kind":"integer","sign":"unsigned","width":32},{"kind":"integer","sign":"unsigned","width":32},{"kind":"field"}]},"11732781666457836689":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13649294680379557736":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"14101993474458164081":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14657895983200220173":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"15200354114977654233":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"15760694058516861966":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"16218014537381711836":{"error_kind":"string","string":"Value does not fit in field"},"16446004518090376065":{"error_kind":"string","string":"Input length must be a multiple of 32"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17226037485472400844":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17610130137239148460":{"error_kind":"fmtstring","length":98,"item_types":[]},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"TL3JjjVNc5x5L99aixODD8Fb6YXQ6pYEAoQIaFjx5lXpFh5mG36P8X8rzHNwO3kyvbL+45///7/+l//z3//zv/6P//bv/+uff/l//uOf//I///Xf/u1f//t//rd////+3//9r//+P/7+v//xz+/7Pyv++Zf1n/5Z+c+/+N9/zj//kv/pn/33P43f33/H33/n33/n33/333/X33///tne9792/+v3v3H/m/e/B/+13/3vuP+d9793Pbvr2V3P7np217O7nt31/K7ndz2/6/ldz+96ftfzu57f9fyu53e9uOvFXS/uenHXi7te3PXirhd3vbjrxV0v73p518u7Xt718q6Xd7286+VdL+96edc7d71z1zt3vXPXO3e9c9c7d71z1zt3vXPXG79fw2iYDathN1iDN0RDNvTKo1cevfLolUevPHrl0SuPXnn0yqNXHr3y/Ft5/j4YDbNhNewGa/CGaMiGc2H1yqtXXt/K44PVsBuswRuiIRu+lf/6ZXyNNPOD0TAbVsNusIa/ldf8IBqy4Vz4WmqtD0bDbPhW/vbY11YAa/hWPh9EQzacC19zAUbDbFgNu8EaemXvlb1X9l75a7P97Z+vzwCzYTXsBmvwhmjIhnMhe+XslbNXzl45e+XslbNXzl45e+XslU+vfHrl0yufXvn0yqdXPr3y6ZW/Ftzf0fl68IP59SBgNMyG1bAbrMEboiEbeuXRK49eefTKo1cevfLolUevPHrl0SuPXnn2yrNXnr3y7JVnrzx75dkrz1559sqzV1698uqVV6+8euXVK69eefXKq1devfLqlXevvHvl3SvvXnn3yrtX3r3y7pV3r7x7ZeuVrVe2Xtl6ZeuVrVe2Xtl6ZeuVrVf2Xtl7Ze+VvVf+enD7B9bgDdGQDedC9WDBaJgNq6FXjl45euXolasHzwfnQvVgwd/Ktj+YDathN1iDN0RDNpwLXw8CeuXTK59e+fTK5ybSPN4QDdlwE2n9fg2jYTasht1gDd4QDdnw1Rx/8PUgYDTMhtWwG6zBG6IhG3rl2SvPXnn2yrNX/nrQ8gNr8IZoyIZz4etBwGiYDauhV1698uqVV69cF5P2wbnw9SBgNMyG1bAbrMEboqFX3r2y9crWK1uvbL2y9crWK1uvbL2y9crWK3uv7L2y98reK3uv7L2y98reK3uv7L1y9MrRK0evHL1y9MrRK0evHL1y9MrRK2evnL1y9srZK2evnL1y9srZK2evnL3y6ZVPr3x65dMrn1759MqnVz698umVz115/34No2E2rIbdYA3eEA3Z0CuPXnn0yqNXHr3y6JVHrzx65dErj1559MqzV5698uyVZ688e+XZK89eefbKs1eevfLqlVevvHrl1SuvXnn1yqtXXr1y9+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u7B3T24uwd39+DuHtzdg7t7cHcP7u5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQesetO5B6x607kHrHrTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707kHvHvTuQe8e9O5B7x707sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B6B6M7sHoHozuwegejO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezO7B7B7M7sHsHszuwewezOrB/GA3WMPfyjE/iIZsOBe+HgSMhtmwGnaDNfTK3it7r+y9cvTK0StHrxy9cvTK0StHrxy9cvTK0Stnr5y9cvbK2Stnr5y9cvbK2Stnr5y98umVT698euXTK59e+fTKp1c+vfLplc9d+fx+DaNhNqyG3WAN3hAN2dArj1559MqjVx698uiVR688euXRK49eefTKs1eevfLslWevPHvl2SvPXnn2yrNXnr3y6pVXr7x65dUrr1559cqrV1698uqVV6+8e+XdK+9eeffKu1fevfLulXevvHvl3Stbr2y9svXK1itbr2y9cvfg6R483YOne/B0D57uwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R483YOne/B0D57uwdM9eLoHT/fg6R483YOne/DvGf3v0Xg0H61H+5E98kfxKB89j/E8xvMYz2M8j/E8xvMYz2M8j/E8xvOYz2M+j/k85vOYz2M+j/k85vOYz2M+j/U81vNYz2M9j/U81vNYz2M9j/U81vPYz2M/j/089vPYz2M/j/089vPYz2M/D3se9jzsedjzsOdhz8Oehz0Pex72PPx5+PPw5+HPw5+HPw9/Hv48/Hn484jnEc8jnkc8j3ge8TziecTziOcRzyOfRz6PfB75PPJ55PPI55HPI59HPo/zPM7zOM/jPI/zPM7zOM/jPI/zPF6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5en4/X5+P1+Xh9Pl6fj9fn4/X5eH0+Xp+P1+fj9fl4fT5e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0YlBTOJ5WFlycRAncRHpNuk26TbpVlmyvPA8rCy5OIiTuIibaEQnBpFui26bbptum26bbptum26bbptulSXLCs/DypKLgziJi7iJRnRiEOlmdHO6Od2cbk43p5vTzenmdHO6Od2CbkG3oFvQLegWdAu6Bd2CbkG3pFvSLemWdEu6Jd2Sbkm3pFvS7dDt0O3Q7dDt0O3Q7dDt0O3Q7Tw3zL1eHMRJXMRNNKITg5hEug26DboNug26DboNug26DboNug26TbpNuk26TbpNuk26TbpNuk26Tbotui26Lbotui26Lbotui26Lbotum26bbptum26bbptum26bboxS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYksySZJcksSWZJMkuSWZLMkmSWJLMkmSXJLElmSTJLklmSzJJkliSzJJklySxJZkkyS5JZksySZJYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlhxmyWGWHGbJYZYcZslhlmDudUVhEJN4HiJLgIM4iYu4iUak26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm5Jt6Rb0i3plnRLuiXdKku+v3Q3Mfd68TysLKk/XIa514uTuIibaEQnBjGJ5+LC3OvFQZzERdxEIzoxiEmk26DboNug26DboNug26DboNug26DbpNuk26TbpNuk26TbpNuk26TbpNui26Lbotui26Lbotui26Lbotui26bbptum26bbptum26bbptum26ab0c3oZnQzuhndjG5GN6Ob0c3o5nRzujndnG5ON6eb083p5nRzugXdgm5Bt6Bb0C3oFnQLugXdgm5Jt6Rb0i3plnRLuiXdkm5Jt6Tboduh26Hboduh26Hboduh26Ebs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMEsGs2QwSwazZDBLBrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLJrNkMksms2QySyazZDJLMPf6/SXfhbnXi4NYblm4iJtoRCcGMYnnIbIEOIh0C7ohS2ahEZ0YxCSeh8gS4CBO4iLSLemWdEu6Jd2Sboduh26Hboduh26Hboduh26Hbue5Ye714iBO4iJuohGdGMQk0m3QbdBt0G3QbdBt0G3QbdBt0G3QbdJt0m3SbdJt0m3SbdKtsqT+LjLmXi+eh5Ul9+8cD+Ikltsp3EQjOjGISTwPkSXAQZxEum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXdkm5Jt6Rb0i3plnRLuh26Hboduh26Hboduh26Hbodup3nhrnXi4M4iYu4iUZ0YhCTSLdBt0G3QbdBt0G3QbdBt0G3QbdBt0m3SbdJt0k33HvdhUZ0YhCTeB7i3itwECdxEem26Lbotui26Lbotum26bbptum26bbptum26bbptulmdDO6Gd2MbkY3o5vRzehmdDO6Od2cbk43p5vTzenmdHO6Od2cbkG3oFvQLegWdAu6Bd2CbkG3oFvSLemWdEu6Jd2Sbkm3pFvSLel26Hboduh26Hboduh26Hboduh2nhvmXi8O4iQu4iYa0YlBTCLdBt0G3QbdBt0G3SpLfBQ6MYifm6/C87Cy5OIgTuIibqIRnRhEuk26Lbotui26Lbotui26Lbotui26Lbptum26bbptum26bbptum26bbptuhndjG5GN6Ob0c3oZnQzuhndjG5ON6eb083p5nRzujndnG5ON6db0C3oFnQLugXdgm5Bt6Bb0C3olnRLuiXd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","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"PrivateMessenger::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateMessenger::constructor_parameters","fields":[]}}]},{"kind":"struct","path":"PrivateMessenger::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateMessenger::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"PrivateMessenger::send_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateMessenger::send_message_parameters","fields":[{"name":"sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"part0","type":{"kind":"field"}},{"name":"part1","type":{"kind":"field"}},{"name":"part2","type":{"kind":"field"}},{"name":"part3","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"PrivateMessenger::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"PrivateMessenger::sync_private_state_parameters","fields":[]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"PrivateMessenger"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"inbox","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"12":{"source":"// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n","path":"std/convert.nr"},"16":{"source":"use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n","path":"std/embedded_curve_ops.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"// src/main.nr\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract PrivateMessenger {\n    // macros\n    use dep::aztec::macros::{\n        functions::{initializer, private, public},\n        notes::note,\n        storage::storage,\n    };\n\n    // protocol types & traits\n    use dep::aztec::protocol_types::address::AztecAddress;\n    use dep::aztec::protocol_types::traits::{Packable, Serialize, Deserialize};\n\n    // state vars\n    use dep::aztec::state_vars::{Map, PrivateSet};\n\n    // ---------------- Note ----------------\n    #[derive(Eq, Packable, Serialize, Deserialize)]\n    #[note]\n    struct MessageNote {\n        owner: AztecAddress,     // recipient (note owner)\n        sender: AztecAddress,    // sender\n        recipient: AztecAddress, // duplicated for convenience\n        part0: Field,\n        part1: Field,\n        part2: Field,\n        part3: Field,\n    }\n\n    // ---------------- Storage ----------------\n    #[storage]\n    struct Storage<Context> {\n        // Map<recipient, PrivateSet<MessageNote, Context>, Context>\n        inbox: Map<AztecAddress, PrivateSet<MessageNote, Context>, Context>,\n    }\n\n    // ---------------- Initializer ----------------\n    #[public]\n    #[initializer]\n    fn constructor() {\n        // no-op; public initializer needs no verification key\n    }\n\n    // ---------------- Write API ----------------\n    #[private]\n    fn send_message(\n        sender: AztecAddress,\n        recipient: AztecAddress,\n        part0: Field,\n        part1: Field,\n        part2: Field,\n        part3: Field,\n    ) {\n        let note = MessageNote {\n            owner: recipient,\n            sender,\n            recipient,\n            part0,\n            part1,\n            part2,\n            part3,\n        };\n\n        // minimal constraint ensures a circuit exists  VK gets generated\n        assert(note.owner == recipient);\n\n        // insert and ignore the return value to silence warning\n        let _ = storage.inbox.at(recipient).insert(note);\n    }\n}\n","path":"/home/emreb/code/pm-contract/PrivateMessenger/src/main.nr"},"60":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/capsules/mod.nr"},"68":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/context/private_context.nr"},"69":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/context/public_context.nr"},"71":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/context/utility_context.nr"},"73":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/event/event_selector.nr"},"75":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/hash.nr"},"92":{"source":"use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/keys/getters/mod.nr"},"96":{"source":"use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/macros/aztec.nr"},"97":{"source":"use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/macros/dispatch.nr"},"102":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/macros/functions/initialization_utils.nr"},"105":{"source":"use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/macros/functions/utils.nr"},"107":{"source":"use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/macros/notes.nr"},"108":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/macros/storage.nr"},"110":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/discovery/mod.nr"},"111":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/discovery/nonce_discovery.nr"},"112":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/discovery/partial_notes.nr"},"113":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/discovery/private_events.nr"},"114":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/discovery/private_notes.nr"},"115":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/discovery/process_message.nr"},"116":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/encoding.nr"},"117":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/encryption/aes128.nr"},"133":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/messages/processing/mod.nr"},"138":{"source":"use crate::context::PrivateContext;\nuse crate::note::{\n    note_emission::NoteEmission,\n    note_interface::{NoteHash, NoteType},\n    retrieved_note::RetrievedNote,\n    utils::{compute_note_hash_for_nullify_from_read_request, compute_note_hash_for_read_request},\n};\nuse crate::oracle::notes::notify_created_note;\nuse protocol_types::traits::Packable;\n\npub fn create_note<Note>(\n    context: &mut PrivateContext,\n    storage_slot: Field,\n    note: Note,\n) -> NoteEmission<Note>\nwhere\n    Note: NoteType + NoteHash + Packable,\n{\n    let note_hash_counter = context.side_effect_counter;\n\n    let note_hash = note.compute_note_hash(storage_slot);\n\n    let packed_note = Note::pack(note);\n    notify_created_note(\n        storage_slot,\n        Note::get_id(),\n        packed_note,\n        note_hash,\n        note_hash_counter,\n    );\n\n    context.push_note_hash(note_hash);\n\n    NoteEmission::new(note, storage_slot, note_hash_counter)\n}\n\n// Note: This function is currently totally unused.\npub fn destroy_note<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_read_request =\n        compute_note_hash_for_read_request(retrieved_note, storage_slot);\n\n    destroy_note_unsafe(context, retrieved_note, note_hash_for_read_request)\n}\n\npub fn destroy_note_unsafe<Note>(\n    context: &mut PrivateContext,\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n)\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify =\n        compute_note_hash_for_nullify_from_read_request(retrieved_note, note_hash_for_read_request);\n    let nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    let note_hash = if retrieved_note.metadata.is_settled() {\n        // Counter is zero, so we're nullifying a settled note and we don't populate the note_hash with real value.\n        0\n    } else {\n        // A non-zero note hash counter implies that we're nullifying a pending note (i.e. one that has not yet been\n        // persisted in the trees and is instead in the pending new note hashes array). In such a case we populate its\n        // hash with real value to inform the kernel which note we're nullifying so that it can either squash both\n        // the note and the nullifier if it's an inner note hash, or check that the it matches a pending note if it's\n        // a siloed note hash.\n        note_hash_for_nullify\n    };\n\n    context.push_nullifier_for_note_hash(nullifier, note_hash)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/note/lifecycle.nr"},"145":{"source":"use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/note/note_metadata.nr"},"148":{"source":"use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/note/utils.nr"},"153":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/capsules.nr"},"155":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/execution.nr"},"157":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/get_contract_instance.nr"},"162":{"source":"use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/key_validation_request.nr"},"163":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/keys.nr"},"165":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/message_processing.nr"},"167":{"source":"use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(utilityGetIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(privateIncrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/notes.nr"},"170":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/shared_secret.nr"},"173":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/oracle/version.nr"},"177":{"source":"use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/state_vars/map.nr"},"183":{"source":"use crate::context::{PrivateContext, UtilityContext};\nuse crate::note::{\n    constants::MAX_NOTES_PER_PAGE,\n    lifecycle::{create_note, destroy_note_unsafe},\n    note_emission::NoteEmission,\n    note_getter::{get_notes, view_notes},\n    note_getter_options::NoteGetterOptions,\n    note_interface::{NoteHash, NoteType},\n    note_viewer_options::NoteViewerOptions,\n    utils::compute_note_hash_for_read_request,\n};\nuse crate::note::retrieved_note::RetrievedNote;\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{\n    abis::read_request::ReadRequest, constants::MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    traits::Packable,\n};\n\nmod test;\n\n/// # PrivateSet\n///\n/// PrivateSet is a private state variable type, which enables you to read, mutate,\n/// and write private state within the #[private] functions of your smart contract.\n///\n/// You can declare a state variable of type PrivateSet within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PrivateSet<YourNote, Context>`\n/// or:\n/// `your_mapping: Map<Field, PrivateSet<YourNote, Context>>`\n///\n/// The PrivateSet type operates over notes, by facilitating: the insertion\n/// of new notes, the reading of existing notes, and the nullification of existing\n/// notes.\n///\n/// The methods of PrivateSet are:\n/// - `insert`\n/// - `pop_notes`\n/// - `get_notes`\n/// - `remove`\n/// (see the methods' own doc comments for more info).\n///\n/// The \"current value\" of a PrivateSet state variable is represented as a\n/// _collection_ (or \"Set\") of multiple notes.\n///\n/// > More exactly, the 'current value' is the collection of all\n/// > _not-yet-nullified_ notes in the set.\n///\n///\n/// ## Example.\n///\n/// A user's token balance can be represented as a PrivateSet of multiple notes,\n/// where the note type contains a value.\n/// The \"current value\" of the user's token balance (the PrivateSet state variable)\n/// can be interpreted as the summation of the values contained within all\n/// not-yet-nullified notes (aka \"current notes\") in the PrivateSet.\n///\n/// This is similar to a physical wallet containing five $10 notes: the owner's\n/// wallet balance is the sum of all those $10 notes: $50.\n/// To spend $2, they can get one $10 note, nullify it, and insert one $8 note as\n/// change. Their new wallet balance will then be interpreted as the new summation: $48.\n///\n/// The interpretation doesn't always have to be a \"summation of values\". When\n/// `get_notes` is called, PrivateSet does not attempt to interpret the notes at all;\n/// it's up to the custom code of the smart contract to make an interpretation.\n///\n/// For example: a set of notes could instead represent a moving average; or a modal\n/// value; or some other single statistic. Or the set of notes might not be\n/// collapsible into a single statistic: it could be a disjoint collection of NFTs\n/// which are housed under the same \"storage slot\".\n///\n/// It's worth noting that a user can prove existence of _at least_ some subset\n/// of notes in a PrivateSet, but they cannot prove existence of _all_ notes\n/// in a PrivateSet.\n/// The physical wallet is a good example: a user can prove that there are five\n/// $10 notes in their wallet by furnishing those notes. But because we cannot\n/// _see_ the entirety of their wallet, they might have many more notes that\n/// they're choosing to not showing us.\n///\n/// ## When to choose PrivateSet vs PrivateMutable:\n///\n/// - If you want _someone else_ (other than the owner of the private state) to be\n///   able to make edits (insert notes).\n/// - If you don't want to leak the storage_slot being initialized (see the\n///   PrivateMutable file).\n/// - If you find yourself needing to re-initialize a PrivateMutable (see that file).\n///\n/// The 'current' value of a _PrivateMutable_ state variable is only ever represented\n/// by _one_ note at a time. To mutate the current value of a PrivateMutable, the\n/// current note always gets nullified, and a new, replacement note gets inserted.\n/// So if nullification is always required to mutate a PrivateMutable, that means\n/// only the 'owner' of a given PrivateMutable state variable can ever mutate it.\n/// For some use cases, this can be too limiting: A key feature of some smart contract\n/// functions is that _multiple people_ are able to mutate a particular state\n/// variable.\n///\n/// PrivateSet enables \"other people\" (other than the owner of the private state) to\n/// mutate the 'current' value, with some limitations:\n/// The 'owner' is still the only person with the ability to `remove` notes from the\n/// the set.\n/// \"Other people\" can `insert` notes into the set.\n///\n/// It's important to notice that the \"owner\" of a state variable is an abstract\n/// concept which will differ depending on the rules of a smart contract. When we\n/// talk about the \"owner\" in the context of these aztec-nr files, we tend to mean\n/// \"the person who has the ability to nullify the state variable's notes\".\n/// Notice that the state variable abstractions of aztec-nr do not know what an\n/// \"owner\" is: they delegate responsibility of understanding who the \"owner\" of a\n/// note is to the note itself, via a `compute_nullifier` call.\n///\n///\n/// ## Privacy\n///\n/// The methods of a PrivateSet are only executable in a PrivateContext, and are\n/// designed to not leak anything about _which_ state variable was read/modified/\n/// inserted, to the outside world.\n///\n/// The design of the Note does impact the privacy of the state variable: the note\n/// will need to contain a `randomness` field so that, when hashed, the contents of\n/// the note are private.\n/// > Note: we decided to explicitly require `randomness` in a note definition,\n/// > because we anticipated use cases where notes might also be used to store\n/// > certain _public_ state. We might roll-back that decision, so that users don't\n/// > need to worry about handling their own randomness when defining custom notes.\n///\n/// The design of the note's custom `compute_nullifier` method will also impact the\n/// privacy of the note at the time it is nullified. (Note: all Notes must implement\n/// `compute_nullifier` to be compatible with PrivateSet). See the docs.\n///\n///\n/// # Struct Fields:\n///\n/// * context - The execution context (PrivateContext or UtilityContext).\n/// * storage_slot -  All notes that \"belong\" to a given PrivateSet state variable\n///                   are augmented with a common `storage_slot` field, as a way of\n///   identifying which set they belong to. (Management of `storage_slot` is handled\n///   within the innards of the PrivateSet impl, so you shouldn't need to think about\n///   this any further).\n///\n///\n/// # Generic Parameters:\n///\n/// * `Note` - Many notes of this type will collectively form the PrivateSet at the\n///            given storage_slot.\n/// * `Context` - The execution context (PrivateContext or UtilityContext).\n///\n/// docs:start:struct\npub struct PrivateSet<Note, Context> {\n    pub context: Context,\n    pub storage_slot: Field,\n}\n// docs:end:struct\n\nimpl<T, Context> HasStorageSlot<1> for PrivateSet<T, Context> {\n    // Private storage slots are not really 'slots' but rather a value in the note\n    // hash preimage, so there is no notion of a value spilling over multiple slots.\n    // For this reason, PrivateSet (and all other private state variables) needs\n    // just one slot to be reserved, regardless of what it stores.\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<Note, Context> PrivateSet<Note, Context> {\n    /// Initializes a new PrivateSet state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. All notes that \"belong\" to a given PrivateSet\n    ///                    state variable are augmented with a common `storage_slot`\n    ///                    field, as a way of identifying which set they belong to.\n    ///                    Usually, the #[storage] macro will determine an appropriate\n    ///                    storage_slot automatically. A smart contract dev shouldn't\n    ///                    have to worry about this, as it's managed behind the scenes.\n    ///\n    /// docs:start:new\n    pub fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PrivateSet { context, storage_slot }\n    }\n    // docs:end:new\n}\n\nimpl<Note> PrivateSet<Note, &mut PrivateContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Inserts a new `note` into the PrivateSet.\n    ///\n    /// # Arguments\n    ///\n    /// - `note` - A newly-created note that you would like to insert into this\n    ///            PrivateSet.\n    ///\n    /// # Returns\n    ///\n    /// - NoteEmission<Note> - A type-safe wrapper which makes it clear to the\n    ///                        smart contract dev that they now have a choice: they\n    ///   need to decide whether they would like to send the contents of the newly-\n    ///   created note to someone, or not. If they would like to, they have some\n    ///   further choices:\n    ///   - What kind of log to use? (Private log, or offchain log).\n    ///   - What kind of encryption scheme to use? (Currently only AES128 is supported)\n    ///   - Whether to _constrain_ delivery of the note, or not.\n    ///   At the moment, aztec-nr provides limited options.\n    ///   You can call `.emit()` on the returned type to encrypt and log the note, or\n    ///   `.discard()` to skip emission.\n    ///   See NoteEmission for more details.\n    ///   > Note: We're planning a _significant_ refactor of this syntax, to make the\n    ///     syntax of how to encrypt and deliver notes much clearer, and to make the\n    ///     default options much clearer to developers. We will also be enabling\n    ///     easier ways to customize your own note encryption options.\n    ///\n    /// # Advanced:\n    ///\n    /// Ultimately, this function inserts the `note` into the protocol's Note Hash\n    /// Tree.\n    /// Behind the scenes, we do the following:\n    /// - Augment the note with the `storage_slot` of this PrivateSet, to\n    ///   convey which set it belongs to.\n    /// - Augment the note with a `note_type_id`, so that it can be correctly filed-\n    ///   away when it is eventually discovered, decrypted, and processed by its\n    ///   intended recipient.\n    ///   (The note_type_id is usually allocated by the #[note] macro).\n    /// - Provide the contents of the (augmented) note to the PXE, so that it can\n    ///   store all notes created by the user executing this function.\n    ///   - The note is also kept in the PXE's memory during execution, in case this\n    ///     newly-created note gets _read_ in some later execution frame of this\n    ///     transaction. In such a case, we feed hints to the kernel to squash:\n    ///     the so-called \"transient note\", its note log (if applicable), and the\n    ///     nullifier that gets created by the reading function.\n    /// - Hash the (augmented) note into a single Field, via the note's own\n    ///   `compute_note_hash` method.\n    /// - Push the `note_hash` to the PrivateContext. From here, the protocol's\n    ///   kernel circuits will take over and insert the note_hash into the protocol's\n    ///   \"note hash tree\".\n    ///   - Before insertion, the protocol will:\n    ///     - \"Silo\" the `note_hash` with the `contract_address` of the calling\n    ///       function, to yield a `siloed_note_hash`. This prevents state collisions\n    ///       between different smart contracts.\n    ///     - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///       attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///       yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// docs:start:insert\n    pub fn insert(self, note: Note) -> NoteEmission<Note>\n    where\n        Note: Packable,\n    {\n        create_note(self.context, self.storage_slot, note)\n    }\n    // docs:end:insert\n\n    /// Pops a collection of \"current\" notes (i.e. not-yet-nullified notes) which\n    /// belong to this PrivateSet.\n    ///\n    /// \"Pop\" indicates that, conceptually, the returned notes will get _permanently\n    /// removed_ (nullified) from the PrivateSet by this method.\n    ///\n    /// The act of nullifying convinces us that the returned notes are indeed\n    /// \"current\" (because if they can be nullified, it means they haven't been\n    /// nullified already, because a note can only be nullified once).\n    ///\n    /// This means that -- whilst the returned notes should be considered \"current\"\n    /// within the currently-executing execution frame of the tx -- they will be not\n    /// be considered \"current\" by any _later_ execution frame of this tx (or any\n    /// future tx).\n    ///\n    /// Notes will be selected from the PXE's database, via an oracle call, according\n    /// to the filtering `options` provided.\n    ///\n    /// # Arguments\n    ///\n    /// - `options` - See NoteGetterOptions. Enables the caller to specify the\n    ///               properties of the notes that must be returned by the oracle\n    ///               call to the PXE.\n    ///               The NoteGetterOptions are designed to contain functions which\n    ///               _constrain_ that the returned notes do indeed adhere to the\n    ///               specified options. Those functions are executed _within_ this\n    ///               `pop_notes` call.\n    ///\n    /// # Returns\n    ///\n    /// - BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    ///   - A vector of \"current\" notes, that have been constrained to satisfy the\n    ///     retrieval criteria specified by the given `options`.\n    ///\n    /// # Generic Parameters\n    ///\n    /// * `PreprocessorArgs` - See `NoteGetterOptions`.\n    /// * `FilterArgs` - See `NoteGetterOptions`.\n    /// * `M` - The length of the note (in Fields), when packed by the Packable trait.\n    ///\n    /// # Advanced:\n    ///\n    /// Reads the notes:\n    ///\n    /// - Gets notes from the PXE, via an oracle call, according to the filtering\n    ///   `options` provided.\n    /// - Constrains that the returned notes do indeed adhere to the `options`.\n    ///   (Note: the `options` contain _constrained_ functions that get invoked\n    ///   _within_ this function).\n    /// - Asserts that the notes do indeed belong to this calling function's\n    ///   `contract_address`, and to this PrivateSet's `storage_slot`.\n    /// - Computes the note_hash for each note, using the `storage_slot` and\n    ///   `contract_address` of this PrivateSet instance.\n    /// - Asserts that the note_hash does indeed exist:\n    ///   - For settled notes: makes a request to the kernel to perform a merkle\n    ///     membership check against the historical Note Hashes Tree that this tx\n    ///     is referencing.\n    ///   - For transient notes: makes a request to the kernel to ensure that the\n    ///     note was indeed emitted by some earlier execution frame of this tx.\n    ///\n    /// Nullifies the notes:\n    ///\n    /// - Computes the nullifier for each note.\n    ///   - (The nullifier computation differs depending on whether the note is\n    ///     settled or transient).\n    /// - Pushes the nullifiers to the PrivateContext. From here, the protocol's\n    ///   kernel circuits will take over and insert the nullifiers into the\n    ///   protocol's \"nullifier tree\".\n    ///   - Before insertion, the protocol will:\n    ///     - \"Silo\" each `nullifier` with the `contract_address` of the calling\n    ///       function, to yield a `siloed_nullifier`. This prevents nullifier\n    ///       collisions between different smart contracts.\n    ///     - Ensure that each `siloed_nullifier` does not already exist in the\n    ///       nullifier tree. The nullifier tree is an indexed merkle tree, which\n    ///       supports efficient non-membership proofs.\n    ///\n    pub fn pop_notes<PreprocessorArgs, FilterArgs, let M: u32>(\n        self,\n        options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N = M>,\n    {\n        let (retrieved_notes, note_hashes) = get_notes(self.context, self.storage_slot, options);\n        // We iterate in a range 0..options.limit instead of 0..notes.len() because options.limit is known at compile\n        // time and hence will result in fewer constraints when set to a lower value than\n        // MAX_NOTE_HASH_READ_REQUESTS_PER_CALL.\n        for i in 0..options.limit {\n            if i < retrieved_notes.len() {\n                let retrieved_note = retrieved_notes.get_unchecked(i);\n                let note_hash = note_hashes.get_unchecked(i);\n                // We immediately destroy the note without doing any of the read request checks `remove` typically\n                // performs because we know that the `get_notes` call has already placed those constraints.\n                destroy_note_unsafe(self.context, retrieved_note, note_hash);\n            }\n        }\n\n        // Since the notes were already destroyed, we no longer need the additional data in RetrievedNote and can\n        // discard it.\n        retrieved_notes.map(|retrieved_note| retrieved_note.note)\n    }\n\n    /// Permanently removes (conceptually) the given note from this PrivateSet,\n    /// by nullifying it.\n    ///\n    /// Note that if you obtained the note via `get_notes` it's much better to use\n    /// `pop_notes`, as `pop_notes` results in significantly fewer constraints,\n    /// due to avoiding an extra hash and read request check.\n    ///\n    /// # Arguments\n    ///\n    /// - `retrieved_note` - A note which -- earlier in the calling function's\n    ///                      execution -- has been retrieved from the PXE.\n    ///                      The `retrieved_note` is constrained to have been read\n    ///                      from the i\n    ///\n    /// # Returns\n    ///\n    /// - NoteEmission<Note> - A type-safe wrapper which makes it clear to the\n    ///                        smart contract dev that they now have a choice: they\n    ///   need to decide whether they would like to send the contents of the newly-\n    ///   created note to someone, or not. If they would like to, they have some\n    ///   further choices:\n    ///   - What kind of log to use? (Private log, or offchain log).\n    ///   - What kind of encryption scheme to use? (Currently only AES128 is supported)\n    ///   - Whether to _constrain_ delivery of the note, or not.\n    ///   At the moment, aztec-nr provides limited options.\n    ///   See NoteEmission for further details.\n    ///   > Note: We're planning a _significant_ refactor of this syntax, to make the\n    ///     syntax of how to encrypt and deliver notes much clearer, and to make the\n    ///     default options much clearer to developers. We will also be enabling\n    ///     easier ways to customize your own note encryption options.\n    ///\n    pub fn remove(self, retrieved_note: RetrievedNote<Note>) {\n        let note_hash = compute_note_hash_for_read_request(retrieved_note, self.storage_slot);\n        let has_been_read =\n            self.context.note_hash_read_requests.any(|r: ReadRequest| r.value == note_hash);\n        assert(has_been_read, \"Can only remove a note that has been read from the set.\");\n\n        destroy_note_unsafe(self.context, retrieved_note, note_hash);\n    }\n\n    /// Returns a collection of which belong to this PrivateSet.\n    ///\n    /// DANGER: the returned notes do not get nullified within this `get_notes`\n    /// function, and so they cannot necessarily be considered \"current\" notes.\n    /// I.e. you might be reading notes that have already been nullified. It is\n    /// this which distinguishes `get_notes` from `pop_notes`.\n    ///\n    /// Note that if you later on remove the note it's much better to use\n    /// `pop_notes` as `pop_notes` results in significantly fewer constrains\n    /// due to avoiding 1 read request check.\n    /// If you need for your app to see the notes before it can decide which to\n    /// nullify (which ideally would not be the case, and you'd be able to rely\n    /// on the filter and preprocessor to do this), then you have no resort but\n    /// to call `get_notes` and then `remove`.\n    ///\n    /// Notes will be selected from the PXE's database, via an oracle call, according\n    /// to the filtering `options` provided.\n    ///\n    /// # Arguments\n    ///\n    /// - `options` - See NoteGetterOptions. Enables the caller to specify the\n    ///               properties of the notes that must be returned by the oracle\n    ///               call to the PXE.\n    ///               The NoteGetterOptions are designed to contain functions which\n    ///               _constrain_ that the returned notes do indeed adhere to the\n    ///               specified options. Those functions are executed _within_ this\n    ///               `pop_notes` call.\n    ///\n    /// # Returns\n    ///\n    /// - BoundedVec<Note, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    ///   - A vector of \"current\" notes, that have been constrained to satisfy the\n    ///     retrieval criteria specified by the given `options`.\n    ///\n    /// # Generic Parameters\n    ///\n    /// * `PreprocessorArgs` - See `NoteGetterOptions`.\n    /// * `FilterArgs` - See `NoteGetterOptions`.\n    /// * `M` - The length of the note (in Fields), when packed by the Packable trait.\n    ///\n    /// # Advanced:\n    ///\n    /// Reads the notes:\n    ///\n    /// - Gets notes from the PXE, via an oracle call, according to the filtering\n    ///   `options` provided.\n    /// - Constrains that the returned notes do indeed adhere to the `options`.\n    ///   (Note: the `options` contain _constrained_ functions that get invoked\n    ///   _within_ this function).\n    /// - Asserts that the notes do indeed belong to this calling function's\n    ///   `contract_address`, and to this PrivateSet's `storage_slot`.\n    /// - Computes the note_hash for each note, using the `storage_slot` and\n    ///   `contract_address` of this PrivateSet instance.\n    /// - Asserts that the note_hash does indeed exist:\n    ///   - For settled notes: makes a request to the kernel to perform a merkle\n    ///     membership check against the historical Note Hashes Tree that this tx\n    ///     is referencing.\n    ///   - For transient notes: makes a request to the kernel to ensure that the\n    ///     note was indeed emitted by some earlier execution frame of this tx.\n    ///\n    pub fn get_notes<PreprocessorArgs, FilterArgs, let M: u32>(\n        self,\n        options: NoteGetterOptions<Note, M, PreprocessorArgs, FilterArgs>,\n    ) -> BoundedVec<RetrievedNote<Note>, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>\n    where\n        Note: Packable<N = M>,\n    {\n        get_notes(self.context, self.storage_slot, options).0\n    }\n}\n\nimpl<Note> PrivateSet<Note, UtilityContext>\nwhere\n    Note: NoteType + NoteHash + Eq,\n{\n    /// Returns a collection of notes which belong to this PrivateSet, according\n    /// to the given selection `options`.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Arguments\n    ///\n    /// - `options` - See NoteGetterOptions. Enables the caller to specify the\n    ///               properties of the notes that must be returned by the oracle\n    ///               call to the PXE.\n    ///\n    /// docs:start:view_notes\n    pub unconstrained fn view_notes(\n        self,\n        options: NoteViewerOptions<Note, <Note as Packable>::N>,\n    ) -> BoundedVec<Note, MAX_NOTES_PER_PAGE>\n    where\n        Note: Packable,\n    {\n        view_notes(self.storage_slot, options)\n    }\n    // docs:end:view_notes\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/state_vars/private_set.nr"},"203":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/utils/array/append.nr"},"206":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/utils/array/subarray.nr"},"207":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/utils/array/subbvec.nr"},"209":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/utils/conversion/bytes_to_fields.nr"},"210":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/utils/conversion/fields_to_bytes.nr"},"212":{"source":"use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/utils/field.nr"},"214":{"source":"use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-nr/v2.0.2/aztec/src/utils/point.nr"},"226":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/emreb/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"245":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"291":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"307":{"source":"/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"316":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"330":{"source":"/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"331":{"source":"pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/point.nr"},"332":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"342":{"source":"use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr"},"344":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"357":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"360":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/home/emreb/nargo/github.com/AztecProtocol/aztec-packages/v2.0.2/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"}}}